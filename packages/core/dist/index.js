"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
function __rest(s2, e3) {
  var t3 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t3[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s2); i3 < p2.length; i3++) {
      if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i3]))
        t3[p2[i3]] = s2[p2[i3]];
    }
  return t3;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r3 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r3 = (c2 < 3 ? d2(r3) : c2 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    var context = {};
    for (var p2 in contextIn)
      context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i3])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i3 = 0; i3 < initializers.length; i3++) {
    value = useValue ? initializers[i3].call(thisArg, value) : initializers[i3].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x3) {
  return typeof x3 === "symbol" ? x3 : "".concat(x3);
}
function __setFunctionName(f2, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve3) {
      resolve3(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve3, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n3) {
    return function(v2) {
      return step([n3, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y && (t3 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t3 = y["return"]) && t3.call(y), 0) : y.next) && !(t3 = t3.call(y, op[1])).done)
          return t3;
        if (y = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m2, o3) {
  for (var p2 in m2)
    if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o3, p2))
      __createBinding(o3, m2, p2);
}
function __values(o3) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o3[s2], i3 = 0;
  if (m2)
    return m2.call(o3);
  if (o3 && typeof o3.length === "number")
    return {
      next: function() {
        if (o3 && i3 >= o3.length)
          o3 = void 0;
        return { value: o3 && o3[i3++], done: !o3 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o3, n3) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i3 = m2.call(o3), r3, ar = [], e3;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r3 = i3.next()).done)
      ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m2 = i3["return"]))
        m2.call(i3);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
    ar = ar.concat(__read(arguments[i3]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
    s2 += arguments[i3].length;
  for (var r3 = Array(s2), k2 = 0, i3 = 0; i3 < il; i3++)
    for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
      r3[k2] = a3[j2];
  return r3;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
  return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3;
  function verb(n3) {
    if (g2[n3])
      i3[n3] = function(v2) {
        return new Promise(function(a3, b3) {
          q2.push([n3, v2, a3, b3]) > 1 || resume(n3, v2);
        });
      };
  }
  function resume(n3, v2) {
    try {
      step(g2[n3](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step(r3) {
    r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o3) {
  var i3, p2;
  return i3 = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i3[Symbol.iterator] = function() {
    return this;
  }, i3;
  function verb(n3, f2) {
    i3[n3] = o3[n3] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o3[n3](v2)), done: false } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o3) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o3[Symbol.asyncIterator], i3;
  return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3);
  function verb(n3) {
    i3[n3] = o3[n3] && function(v2) {
      return new Promise(function(resolve3, reject) {
        v2 = o3[n3](v2), settle(resolve3, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve3, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve3({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e3) {
    env.error = env.hasError ? new _SuppressedError(e3, env.error, "An error was suppressed during disposal.") : e3;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e3) {
            fail(e3);
            return next();
          });
      } catch (e3) {
        fail(e3);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "../../node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
    extendStatics = function(d2, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
        d3.__proto__ = b4;
      } || function(d3, b4) {
        for (var p2 in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p2))
            d3[p2] = b4[p2];
      };
      return extendStatics(d2, b3);
    };
    __assign = function() {
      __assign = Object.assign || function __assign3(t3) {
        for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s2 = arguments[i3];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t3[p2] = s2[p2];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o3, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o3[k22] = m2[k2];
    };
    __setModuleDefault = Object.create ? function(o3, v2) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v2 });
    } : function(o3, v2) {
      o3["default"] = v2;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e3 = new Error(message);
      return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// ../../node_modules/@stoplight/spectral-core/node_modules/@stoplight/types/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@stoplight/spectral-core/node_modules/@stoplight/types/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpParamStyles = void 0;
    (function(HttpParamStyles2) {
      HttpParamStyles2["Simple"] = "simple";
      HttpParamStyles2["Matrix"] = "matrix";
      HttpParamStyles2["Label"] = "label";
      HttpParamStyles2["Form"] = "form";
      HttpParamStyles2["CommaDelimited"] = "commaDelimited";
      HttpParamStyles2["SpaceDelimited"] = "spaceDelimited";
      HttpParamStyles2["PipeDelimited"] = "pipeDelimited";
      HttpParamStyles2["DeepObject"] = "deepObject";
    })(exports.HttpParamStyles || (exports.HttpParamStyles = {}));
    exports.DiagnosticSeverity = void 0;
    (function(DiagnosticSeverity2) {
      DiagnosticSeverity2[DiagnosticSeverity2["Error"] = 0] = "Error";
      DiagnosticSeverity2[DiagnosticSeverity2["Warning"] = 1] = "Warning";
      DiagnosticSeverity2[DiagnosticSeverity2["Information"] = 2] = "Information";
      DiagnosticSeverity2[DiagnosticSeverity2["Hint"] = 3] = "Hint";
    })(exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    exports.NodeType = void 0;
    (function(NodeType2) {
      NodeType2["Article"] = "article";
      NodeType2["HttpService"] = "http_service";
      NodeType2["HttpServer"] = "http_server";
      NodeType2["HttpOperation"] = "http_operation";
      NodeType2["Model"] = "model";
      NodeType2["Generic"] = "generic";
      NodeType2["Unknown"] = "unknown";
      NodeType2["TableOfContents"] = "table_of_contents";
      NodeType2["SpectralRuleset"] = "spectral_ruleset";
      NodeType2["Styleguide"] = "styleguide";
      NodeType2["Image"] = "image";
    })(exports.NodeType || (exports.NodeType = {}));
    exports.NodeFormat = void 0;
    (function(NodeFormat2) {
      NodeFormat2["Json"] = "json";
      NodeFormat2["Markdown"] = "markdown";
      NodeFormat2["Yaml"] = "yaml";
      NodeFormat2["Apng"] = "apng";
      NodeFormat2["Avif"] = "avif";
      NodeFormat2["Bmp"] = "bmp";
      NodeFormat2["Gif"] = "gif";
      NodeFormat2["Jpeg"] = "jpeg";
      NodeFormat2["Png"] = "png";
      NodeFormat2["Svg"] = "svg";
      NodeFormat2["Webp"] = "webp";
    })(exports.NodeFormat || (exports.NodeFormat = {}));
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/consts.js
var require_consts = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/consts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_PARSER_OPTIONS = void 0;
    var types_1 = require_dist();
    exports.DEFAULT_PARSER_OPTIONS = Object.freeze({
      incompatibleValues: types_1.DiagnosticSeverity.Error,
      duplicateKeys: types_1.DiagnosticSeverity.Error
    });
  }
});

// ../../node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "../../node_modules/lodash/lodash.js"(exports, module2) {
    "use strict";
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e3) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index3 = -1, length = array == null ? 0 : array.length;
        while (++index3 < length) {
          var value = array[index3];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index3 = -1, length = array == null ? 0 : array.length;
        while (++index3 < length) {
          if (iteratee(array[index3], index3, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index3 = -1, length = array == null ? 0 : array.length;
        while (++index3 < length) {
          if (!predicate(array[index3], index3, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index3 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index3 < length) {
          var value = array[index3];
          if (predicate(value, index3, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index3 = -1, length = array == null ? 0 : array.length;
        while (++index3 < length) {
          if (comparator(value, array[index3])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index3 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index3 < length) {
          result[index3] = iteratee(array[index3], index3, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index3 = -1, length = values.length, offset = array.length;
        while (++index3 < length) {
          array[offset + index3] = values[index3];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index3 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index3];
        }
        while (++index3 < length) {
          accumulator = iteratee(accumulator, array[index3], index3, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index3 = -1, length = array == null ? 0 : array.length;
        while (++index3 < length) {
          if (predicate(array[index3], index3, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index3 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index3-- : ++index3 < length) {
          if (predicate(array[index3], index3, array)) {
            return index3;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index3 = fromIndex - 1, length = array.length;
        while (++index3 < length) {
          if (comparator(array[index3], value)) {
            return index3;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index3, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index3, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index3 = -1, length = array.length;
        while (++index3 < length) {
          var current = iteratee(array[index3]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n3, iteratee) {
        var index3 = -1, result = Array(n3);
        while (++index3 < n3) {
          result[index3] = iteratee(index3);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index3 = -1, length = strSymbols.length;
        while (++index3 < length && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
        }
        return index3;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index3 = strSymbols.length;
        while (index3-- && baseIndexOf(chrSymbols, strSymbols[index3], 0) > -1) {
        }
        return index3;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index3 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index3] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index3 = -1, length = array.length, resIndex = 0, result = [];
        while (++index3 < length) {
          var value = array[index3];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index3] = PLACEHOLDER;
            result[resIndex++] = index3;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index3 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index3] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index3 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index3] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index3 = fromIndex - 1, length = array.length;
        while (++index3 < length) {
          if (array[index3] === value) {
            return index3;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index3 = fromIndex + 1;
        while (index3--) {
          if (array[index3] === value) {
            return index3;
          }
        }
        return index3;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index3 = string.length;
        while (index3-- && reWhitespace.test(string.charAt(index3))) {
        }
        return index3;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e3) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject4(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index3 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index3 += dir;
              var iterIndex = -1, value = array[index3];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index3 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index3 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index3 = assocIndexOf(data, key);
          if (index3 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index3 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index3, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index3 = assocIndexOf(data, key);
          return index3 < 0 ? undefined2 : data[index3][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index3 = assocIndexOf(data, key);
          if (index3 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index3][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index3 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index3 < length) {
            var entry = entries[index3];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index3 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index3 < length) {
            this.add(values2[index3]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n3) {
          return shuffleSelf(copyArray(array), baseClamp(n3, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index3 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index3 < length) {
            result2[index3] = skip ? undefined2 : get4(object, paths[index3]);
          }
          return result2;
        }
        function baseClamp(number, lower2, upper2) {
          if (number === number) {
            if (upper2 !== undefined2) {
              number = number <= upper2 ? number : upper2;
            }
            if (lower2 !== undefined2) {
              number = number >= lower2 ? number : lower2;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject4(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index3 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index3 < length) {
              var value = array[index3], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index3, collection2) {
            result2 = !!predicate(value, index3, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index3 = -1, length = array.length;
          while (++index3 < length) {
            var value = array[index3], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index3, collection2) {
            if (predicate(value, index3, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index3 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index3 < length) {
            var value = array[index3];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction3(object[key]);
          });
        }
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          var index3 = 0, length = path2.length;
          while (object != null && index3 < length) {
            object = object[toKey(path2[index3++])];
          }
          return index3 && index3 == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index3 = -1, seen = caches[0];
          outer:
            while (++index3 < length && result2.length < maxLength) {
              var value = array[index3], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache2 = caches[othIndex];
                  if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          var func = object == null ? object : object[toKey(last(path2))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index3 = matchData.length, length = index3, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index3--) {
            var data = matchData[index3];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index3 < length) {
            data = matchData[index3];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject4(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject4(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index3 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index3] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object) {
            var objValue = get4(object, path2);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject4(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject4(objValue) || isFunction3(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n3) {
          var length = array.length;
          if (!length) {
            return;
          }
          n3 += n3 < 0 ? length : 0;
          return isIndex(n3, length) ? array[n3] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index3 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index3, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path2) {
            return hasIn(object, path2);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index3 = -1, length = paths.length, result2 = {};
          while (++index3 < length) {
            var path2 = paths[index3], value = baseGet(object, path2);
            if (predicate(value, path2)) {
              baseSet(result2, castPath(path2, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index3 = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index3 < length) {
            var fromIndex = 0, value = values2[index3], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index3 = indexes[length];
            if (length == lastIndex || index3 !== previous) {
              var previous = index3;
              if (isIndex(index3)) {
                splice.call(array, index3, 1);
              } else {
                baseUnset(array, index3);
              }
            }
          }
          return array;
        }
        function baseRandom(lower2, upper2) {
          return lower2 + nativeFloor(nativeRandom() * (upper2 - lower2 + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index3 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index3] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n3) {
          var result2 = "";
          if (!string || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n3 % 2) {
              result2 += string;
            }
            n3 = nativeFloor(n3 / 2);
            if (n3) {
              string += string;
            }
          } while (n3);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n3) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n3, 0, array.length));
        }
        function baseSet(object, path2, value, customizer) {
          if (!isObject4(object)) {
            return object;
          }
          path2 = castPath(path2, object);
          var index3 = -1, length = path2.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index3 < length) {
            var key = toKey(path2[index3]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index3 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject4(objValue) ? objValue : isIndex(path2[index3 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index3 = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index3 < length) {
            result2[index3] = array[index3 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index3, collection2) {
            result2 = predicate(value, index3, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low2 = 0, high = array == null ? low2 : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low2 < high) {
              var mid = low2 + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low2 = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low2 = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low2 < high) {
            var mid = nativeFloor((low2 + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low2 = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index3 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index3 < length) {
            var value = array[index3], computed = iteratee2 ? iteratee2(value) : value;
            if (!index3 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index3 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index3 < length) {
              var value = array[index3], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path2) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          return object == null || delete object[toKey(last(path2))];
        }
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index3 = fromRight ? length : -1;
          while ((fromRight ? index3-- : ++index3 < length) && predicate(array[index3], index3, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index3, fromRight ? index3 + 1 : length) : baseSlice(array, fromRight ? index3 + 1 : 0, fromRight ? length : index3);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index3 = -1, result2 = Array2(length);
          while (++index3 < length) {
            var array = arrays[index3], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index3) {
                result2[index3] = baseDifference(result2[index3] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index3 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index3 < length) {
            var value = index3 < valsLength ? values2[index3] : undefined2;
            assignFunc(result2, props[index3], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index3 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index3 < length) {
            var result2 = compareAscending(objCriteria[index3], othCriteria[index3]);
            if (result2) {
              if (index3 >= ordersLength) {
                return result2;
              }
              var order = orders[index3];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index3 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index3 < length) {
            array[index3] = source[index3];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index3 = -1, length = props.length;
          while (++index3 < length) {
            var key = props[index3];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index3 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index3 < length) {
              var source = sources[index3];
              if (source) {
                assigner(object, source, index3, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index3 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index3-- : ++index3 < length) {
              if (iteratee2(iterable[index3], index3, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index3 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index3];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject4(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index3 = length, placeholder = getHolder(wrapper);
            while (index3--) {
              args[index3] = arguments[index3];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index3 = findIndexFunc(collection, predicate, fromIndex);
            return index3 > -1 ? iterable[iteratee2 ? collection[index3] : index3] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index3 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index3--) {
              var func = funcs[index3];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index3 = wrapper ? index3 : length;
            while (++index3 < length) {
              func = funcs[index3];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index4 = 0, result2 = length ? funcs[index4].apply(this, args) : value;
              while (++index4 < length) {
                result2 = funcs[index4].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index3 = length;
            while (index3--) {
              args[index3] = arguments[index3];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject4(objValue) && isObject4(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index3 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index3 < arrLength) {
            var arrValue = array[index3], othValue = other[index3];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index3, other, array, stack) : customizer(arrValue, othValue, index3, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert2 = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert2 || (convert2 = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index3 = objLength;
          while (index3--) {
            var key = objProps[index3];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index3 < objLength) {
            key = objProps[index3];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e3) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index3 = -1, length = transforms.length;
          while (++index3 < length) {
            var data = transforms[index3], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          var index3 = -1, length = path2.length, result2 = false;
          while (++index3 < length) {
            var key = toKey(path2[index3]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index3 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index3, object) {
          if (!isObject4(object)) {
            return false;
          }
          var type = typeof index3;
          if (type == "number" ? isArrayLike(object) && isIndex(index3, object.length) : type == "string" && index3 in object) {
            return eq(object[index3], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction3 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject4(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache2.size === MAX_MEMOIZE_SIZE) {
              cache2.clear();
            }
            return key;
          });
          var cache2 = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index3 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index3 < length) {
              array[index3] = args[start + index3];
            }
            index3 = -1;
            var otherArgs = Array2(start + 1);
            while (++index3 < start) {
              otherArgs[index3] = args[index3];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index3 = indexes[length];
            array[length] = isIndex(index3, arrLength) ? oldArray[index3] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count2 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count2 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index3 = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index3 < size2) {
            var rand = baseRandom(index3, lastIndex), value = array[rand];
            array[rand] = array[index3];
            array[index3] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e3) {
            }
            try {
              return func + "";
            } catch (e3) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index3 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index3 < length) {
            result2[resIndex++] = baseSlice(array, index3, index3 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index3 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index3 < length) {
            var value = array[index3];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index3 = length;
          while (index3--) {
            args[index3 - 1] = arguments[index3];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          return baseSlice(array, n3 < 0 ? 0 : n3, length);
        }
        function dropRight(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          n3 = length - n3;
          return baseSlice(array, 0, n3 < 0 ? 0 : n3);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill2(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index3 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index3 < 0) {
            index3 = nativeMax(length + index3, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index3);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index3 = length - 1;
          if (fromIndex !== undefined2) {
            index3 = toInteger(fromIndex);
            index3 = fromIndex < 0 ? nativeMax(length + index3, 0) : nativeMin(index3, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index3, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index3 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index3 < length) {
            var pair = pairs[index3];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index3 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index3 < 0) {
            index3 = nativeMax(length + index3, 0);
          }
          return baseIndexOf(array, value, index3);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join3(array, separator2) {
          return array == null ? "" : nativeJoin.call(array, separator2);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index3 = length;
          if (fromIndex !== undefined2) {
            index3 = toInteger(fromIndex);
            index3 = index3 < 0 ? nativeMax(length + index3, 0) : nativeMin(index3, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index3) : baseFindIndex(array, baseIsNaN, index3, true);
        }
        function nth(array, n3) {
          return array && array.length ? baseNth(array, toInteger(n3)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index3) {
            return isIndex(index3, length) ? +index3 : index3;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index3 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index3 < length) {
            var value = array[index3];
            if (predicate(value, index3, array)) {
              result2.push(value);
              indexes.push(index3);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index3 = baseSortedIndex(array, value);
            if (index3 < length && eq(array[index3], value)) {
              return index3;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index3 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index3], value)) {
              return index3;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n3, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          return baseSlice(array, 0, n3 < 0 ? 0 : n3);
        }
        function takeRight(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          n3 = length - n3;
          return baseSlice(array, n3 < 0 ? 0 : n3, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq2(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy3(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith2(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index3) {
            return arrayMap(array, baseProperty(index3));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index3 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index3] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n3, guard) {
          if (guard ? isIterateeCall(collection, n3, guard) : n3 === undefined2) {
            n3 = 1;
          } else {
            n3 = toInteger(n3);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n3);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString3(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n3, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n3 = toInteger(n3);
          return function() {
            if (--n3 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n3, guard) {
          n3 = guard ? undefined2 : n3;
          n3 = func && n3 == null ? func.length : n3;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n3);
        }
        function before(n3, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n3 = toInteger(n3);
          return function() {
            if (--n3 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n3 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject4(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
            if (cache2.has(key)) {
              return cache2.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache2.set(key, result2) || cache2;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index3 = -1, length = nativeMin(args.length, funcsLength);
            while (++index3 < length) {
              args[index3] = transforms[index3].call(this, args[index3]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject4(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction3(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty3(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction3(value) {
          if (!isObject4(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject4(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull2(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString3(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString3(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject4(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject4(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index3 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index3 < length) {
            var source = sources[index3];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get4(object, path2, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path2);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index3 = -1, length = path2.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index3 < length) {
            var value = object == null ? undefined2 : object[toKey(path2[index3])];
            if (value === undefined2) {
              index3 = length;
              value = defaultValue;
            }
            object = isFunction3(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path2, value) {
          return object == null ? object : baseSet(object, path2, value);
        }
        function setWith(object, path2, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path2, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject4(object)) {
              accumulator = isFunction3(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index3, object2) {
            return iteratee2(accumulator, value, index3, object2);
          });
          return accumulator;
        }
        function unset(object, path2) {
          return object == null ? true : baseUnset(object, path2);
        }
        function update(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        function updateWith(object, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower2, upper2) {
          if (upper2 === undefined2) {
            upper2 = lower2;
            lower2 = undefined2;
          }
          if (upper2 !== undefined2) {
            upper2 = toNumber(upper2);
            upper2 = upper2 === upper2 ? upper2 : 0;
          }
          if (lower2 !== undefined2) {
            lower2 = toNumber(lower2);
            lower2 = lower2 === lower2 ? lower2 : 0;
          }
          return baseClamp(toNumber(number), lower2, upper2);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower2, upper2, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper2, floating)) {
            upper2 = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper2 == "boolean") {
              floating = upper2;
              upper2 = undefined2;
            } else if (typeof lower2 == "boolean") {
              floating = lower2;
              lower2 = undefined2;
            }
          }
          if (lower2 === undefined2 && upper2 === undefined2) {
            lower2 = 0;
            upper2 = 1;
          } else {
            lower2 = toFinite(lower2);
            if (upper2 === undefined2) {
              upper2 = lower2;
              lower2 = 0;
            } else {
              upper2 = toFinite(upper2);
            }
          }
          if (lower2 > upper2) {
            var temp = lower2;
            lower2 = upper2;
            upper2 = temp;
          }
          if (floating || lower2 % 1 || upper2 % 1) {
            var rand = nativeRandom();
            return nativeMin(lower2 + rand * (upper2 - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper2);
          }
          return baseRandom(lower2, upper2);
        }
        var camelCase = createCompounder(function(result2, word, index3) {
          word = word.toLowerCase();
          return result2 + (index3 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape3(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index3) {
          return result2 + (index3 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index3) {
          return result2 + (index3 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n3, guard) {
          if (guard ? isIterateeCall(string, n3, guard) : n3 === undefined2) {
            n3 = 1;
          } else {
            n3 = toInteger(n3);
          }
          return baseRepeat(toString(string), n3);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index3) {
          return result2 + (index3 ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator2, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator2, limit)) {
            separator2 = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator2 == "string" || separator2 != null && !isRegExp(separator2))) {
            separator2 = baseToString(separator2);
            if (!separator2 && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator2, limit);
        }
        var startCase = createCompounder(function(result2, word, index3) {
          return result2 + (index3 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index3 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index3, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index3 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject4(options)) {
            var separator2 = "separator" in options ? options.separator : separator2;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator2 === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator2)) {
            if (string.slice(end).search(separator2)) {
              var match, substring = result2;
              if (!separator2.global) {
                separator2 = RegExp2(separator2.source, toString(reFlags.exec(separator2)) + "g");
              }
              separator2.lastIndex = 0;
              while (match = separator2.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator2), end) != end) {
            var index3 = result2.lastIndexOf(separator2);
            if (index3 > -1) {
              result2 = result2.slice(0, index3);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index3) {
          return result2 + (index3 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e3) {
            return isError(e3) ? e3 : new Error2(e3);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index3 = -1;
            while (++index3 < length) {
              var pair = pairs[index3];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject4(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject4(options) && "chain" in options) || !!options.chain, isFunc = isFunction3(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n3) {
          n3 = toInteger(n3);
          return baseRest(function(args) {
            return baseNth(args, n3);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined2 : baseGet(object, path2);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n3, iteratee2) {
          n3 = toInteger(n3);
          if (n3 < 1 || n3 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index3 = MAX_ARRAY_LENGTH, length = nativeMin(n3, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n3 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index3 < n3) {
            iteratee2(index3);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill2;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit2;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq2;
        lodash.uniqBy = uniqBy3;
        lodash.uniqWith = uniqWith2;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape3;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find2;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get4;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty3;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction3;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject4;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString3;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join3;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index3) {
          LazyWrapper.prototype[methodName] = function(n3) {
            n3 = n3 === undefined2 ? 1 : nativeMax(toInteger(n3), 0);
            var result2 = this.__filtered__ && !index3 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n3, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n3, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n3) {
            return this.reverse()[methodName](n3).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index3) {
          var type = index3 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index3) {
          var takeName = "take" + (index3 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index3) {
          var dropName = "drop" + (index3 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(exports);
  }
});

// ../../node_modules/@stoplight/path/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  basename: () => c,
  deserializeSrn: () => x,
  dirname: () => a,
  extname: () => l,
  format: () => t,
  isAbsolute: () => s,
  isURL: () => f,
  join: () => p,
  normalize: () => o,
  parse: () => e,
  relative: () => h,
  resolve: () => g,
  sep: () => v,
  serializeSrn: () => m,
  startsWithWindowsDrive: () => d,
  stripRoot: () => b,
  toFSPath: () => o
});
function t(t3) {
  let n3 = "";
  return t3.absolute && ("file" === t3.protocol ? (t3.drive && (n3 += t3.drive), n3 += "/") : (n3 += t3.protocol + "://", t3.origin && (n3 += t3.origin + "/"))), "" === (n3 += t3.path.join("/")) && (n3 = "."), n3;
}
function n(t3, r3, e3, o3) {
  this.message = t3, this.expected = r3, this.found = e3, this.location = o3, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, n);
}
function e(t3) {
  if ("string" != typeof t3)
    throw new Error(`@stoplight/path: Cannot parse ${t3} because it is not a string`);
  return r(t3, {});
}
function o(n3) {
  return t(u(e(n3)));
}
function u(t3) {
  let n3 = t3.path;
  n3 = n3.filter((t4) => "" !== t4 && "." !== t4);
  const r3 = [];
  for (const e3 of n3)
    ".." === e3 && r3.length && ".." !== r3[r3.length - 1] ? r3.pop() : ".." === e3 && t3.absolute || r3.push(e3);
  return t3.path = r3, t3;
}
function i(t3) {
  let n3 = t3.lastIndexOf(".");
  ".." === t3 && (n3 = -1), "." === t3 && (n3 = -1);
  let r3 = t3, e3 = "";
  return n3 > 0 && (r3 = t3.slice(0, n3), e3 = t3.slice(n3)), { name: r3, ext: e3 };
}
function s(t3) {
  return e(t3).absolute;
}
function f(t3) {
  const n3 = e(t3);
  return "http" === n3.protocol || "https" === n3.protocol;
}
function h(n3, r3) {
  const o3 = u(e(r3));
  if (!o3.absolute)
    return t(o3);
  const i3 = u(e(n3));
  if (o3.origin !== i3.origin)
    return t(o3);
  if (!i3.absolute)
    return t(o3);
  if (i3.drive !== o3.drive)
    return t(o3);
  const c2 = Math.min(i3.path.length, o3.path.length);
  for (let t3 = 0; t3 < c2 && i3.path[0] === o3.path[0]; t3++)
    i3.path.shift(), o3.path.shift();
  return o3.path.unshift(...i3.path.fill("..")), t({ origin: null, drive: null, absolute: false, protocol: null, path: o3.path });
}
function g(...n3) {
  if (0 === n3.length)
    return ".";
  const r3 = u(e(n3[n3.length - 1]));
  return r3.absolute ? t(r3) : p(...n3);
}
function x(t3) {
  const [n3, r3, e3, ...o3] = t3.split("/"), u2 = o3.length ? `/${o3.join("/")}` : void 0;
  let c2, a3;
  return u2 && (c2 = o3.find((t4) => t4.includes("."))) && (a3 = i(c2).ext), { shortcode: n3, orgSlug: r3, projectSlug: e3, uri: u2, file: c2, ext: a3 };
}
function m({ shortcode: t3, orgSlug: n3, projectSlug: r3, uri: e3 = "" }) {
  return [t3, n3, r3, e3.replace(/^\//, "")].filter(Boolean).join("/");
}
var r, c, a, l, p, v, d, b;
var init_index_es = __esm({
  "../../node_modules/@stoplight/path/index.es.js"() {
    "use strict";
    !function(t3, n3) {
      function r3() {
        this.constructor = t3;
      }
      r3.prototype = n3.prototype, t3.prototype = new r3();
    }(n, Error), n.buildMessage = function(t3, n3) {
      var r3 = { literal: function(t4) {
        return '"' + o3(t4.text) + '"';
      }, class: function(t4) {
        var n4, r4 = "";
        for (n4 = 0; n4 < t4.parts.length; n4++)
          r4 += t4.parts[n4] instanceof Array ? u2(t4.parts[n4][0]) + "-" + u2(t4.parts[n4][1]) : u2(t4.parts[n4]);
        return "[" + (t4.inverted ? "^" : "") + r4 + "]";
      }, any: function(t4) {
        return "any character";
      }, end: function(t4) {
        return "end of input";
      }, other: function(t4) {
        return t4.description;
      } };
      function e3(t4) {
        return t4.charCodeAt(0).toString(16).toUpperCase();
      }
      function o3(t4) {
        return t4.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(t5) {
          return "\\x0" + e3(t5);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(t5) {
          return "\\x" + e3(t5);
        });
      }
      function u2(t4) {
        return t4.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(t5) {
          return "\\x0" + e3(t5);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(t5) {
          return "\\x" + e3(t5);
        });
      }
      return "Expected " + function(t4) {
        var n4, e4, o4, u3 = new Array(t4.length);
        for (n4 = 0; n4 < t4.length; n4++)
          u3[n4] = (o4 = t4[n4], r3[o4.type](o4));
        if (u3.sort(), u3.length > 0) {
          for (n4 = 1, e4 = 1; n4 < u3.length; n4++)
            u3[n4 - 1] !== u3[n4] && (u3[e4] = u3[n4], e4++);
          u3.length = e4;
        }
        switch (u3.length) {
          case 1:
            return u3[0];
          case 2:
            return u3[0] + " or " + u3[1];
          default:
            return u3.slice(0, -1).join(", ") + ", or " + u3[u3.length - 1];
        }
      }(t3) + " but " + function(t4) {
        return t4 ? '"' + o3(t4) + '"' : "end of input";
      }(n3) + " found.";
    };
    r = function(t3, r3) {
      r3 = void 0 !== r3 ? r3 : {};
      var e3, o3, u2, i3, c2 = {}, a3 = { Path: nt }, l2 = nt, s2 = function(t4, n3, r4, e4) {
        return { protocol: t4, origin: n3, absolute: true, ...r4, ...e4 };
      }, f2 = function(t4, n3, r4) {
        return { protocol: t4, origin: n3, absolute: true, ...r4, path: [] };
      }, p2 = "http://", h2 = W2("http://", true), g2 = function(t4) {
        return "http";
      }, v2 = "https://", d2 = W2("https://", true), b3 = function(t4) {
        return "https";
      }, x3 = "", m2 = function() {
        return null;
      }, C2 = function(t4, n3, r4) {
        return { protocol: t4, origin: null, absolute: true, ...n3, ...r4 };
      }, w2 = "file://", A2 = W2("file://", true), y = "file:", j2 = W2("file:", true), F2 = function(t4) {
        return "file";
      }, S2 = function(t4, n3) {
        return { protocol: "file", origin: null, absolute: true, ...t4, ...n3 };
      }, E2 = /^[A-Za-z]/, L2 = X2([["A", "Z"], ["a", "z"]], false, false), R2 = ":", $2 = W2(":", false), M2 = function(t4) {
        return { drive: t4.toLowerCase() + ":" };
      }, k2 = function() {
        return { drive: null };
      }, z2 = function() {
        return { drive: null };
      }, B2 = function(t4) {
        return { protocol: null, origin: null, absolute: false, drive: null, ...t4 };
      }, O2 = function(t4) {
        return { path: t4 };
      }, P2 = function(t4, n3) {
        return [t4, ...n3];
      }, T2 = function(t4) {
        return [t4];
      }, Z2 = ".", I2 = W2(".", false), U2 = "/", q2 = W2("/", false), D2 = "\\", G2 = W2("\\", false), H2 = /^[^\/\\]/, J2 = X2(["/", "\\"], true, false), K2 = 0, N2 = [{ line: 1, column: 1 }], Q2 = 0, V2 = [];
      if ("startRule" in r3) {
        if (!(r3.startRule in a3))
          throw new Error(`Can't start parsing from rule "` + r3.startRule + '".');
        l2 = a3[r3.startRule];
      }
      function W2(t4, n3) {
        return { type: "literal", text: t4, ignoreCase: n3 };
      }
      function X2(t4, n3, r4) {
        return { type: "class", parts: t4, inverted: n3, ignoreCase: r4 };
      }
      function Y2(n3) {
        var r4, e4 = N2[n3];
        if (e4)
          return e4;
        for (r4 = n3 - 1; !N2[r4]; )
          r4--;
        for (e4 = { line: (e4 = N2[r4]).line, column: e4.column }; r4 < n3; )
          10 === t3.charCodeAt(r4) ? (e4.line++, e4.column = 1) : e4.column++, r4++;
        return N2[n3] = e4, e4;
      }
      function _2(t4, n3) {
        var r4 = Y2(t4), e4 = Y2(n3);
        return { start: { offset: t4, line: r4.line, column: r4.column }, end: { offset: n3, line: e4.line, column: e4.column } };
      }
      function tt(t4) {
        K2 < Q2 || (K2 > Q2 && (Q2 = K2, V2 = []), V2.push(t4));
      }
      function nt() {
        var n3;
        return (n3 = function() {
          var t4, n4, r4, e4, o4;
          return t4 = K2, (n4 = rt()) !== c2 && (r4 = et()) !== c2 && (e4 = ut()) !== c2 && (o4 = it()) !== c2 ? (n4 = s2(n4, r4, e4, o4), t4 = n4) : (K2 = t4, t4 = c2), t4 === c2 && (t4 = K2, (n4 = rt()) !== c2 && (r4 = et()) !== c2 && (e4 = function() {
            var t5;
            return (t5 = x3) !== c2 && (t5 = z2()), t5;
          }()) !== c2 ? (n4 = f2(n4, r4, e4), t4 = n4) : (K2 = t4, t4 = c2)), t4;
        }()) === c2 && (n3 = function() {
          var n4, r4, e4, o4;
          return n4 = K2, (r4 = function() {
            var n5;
            return t3.substr(K2, 7).toLowerCase() === w2 ? (n5 = t3.substr(K2, 7), K2 += 7) : (n5 = c2, tt(A2)), n5 === c2 && (t3.substr(K2, 5).toLowerCase() === y ? (n5 = t3.substr(K2, 5), K2 += 5) : (n5 = c2, tt(j2))), n5 !== c2 && (n5 = F2()), n5;
          }()) !== c2 && (e4 = ot()) !== c2 && (o4 = it()) !== c2 ? (r4 = C2(r4, e4, o4), n4 = r4) : (K2 = n4, n4 = c2), n4;
        }()) === c2 && (n3 = function() {
          var t4, n4, r4;
          return t4 = K2, (n4 = ot()) !== c2 && (r4 = it()) !== c2 ? (n4 = S2(n4, r4), t4 = n4) : (K2 = t4, t4 = c2), t4;
        }()) === c2 && (n3 = function() {
          var n4, r4, e4;
          return n4 = K2, (r4 = function() {
            var n5;
            return (n5 = function() {
              var n6, r5, e5;
              return n6 = K2, 46 === t3.charCodeAt(K2) ? (r5 = Z2, K2++) : (r5 = c2, tt(I2)), r5 !== c2 && (e5 = at()) !== c2 ? n6 = r5 = [r5, e5] : (K2 = n6, n6 = c2), n6;
            }()) === c2 && (n5 = x3), n5;
          }()) !== c2 && (e4 = it()) !== c2 ? (r4 = B2(e4), n4 = r4) : (K2 = n4, n4 = c2), n4;
        }()), n3;
      }
      function rt() {
        var n3, r4;
        return t3.substr(K2, 7).toLowerCase() === p2 ? (r4 = t3.substr(K2, 7), K2 += 7) : (r4 = c2, tt(h2)), r4 !== c2 && (r4 = g2()), (n3 = r4) === c2 && (n3 = function() {
          var n4;
          return t3.substr(K2, 8).toLowerCase() === v2 ? (n4 = t3.substr(K2, 8), K2 += 8) : (n4 = c2, tt(d2)), n4 !== c2 && (n4 = b3()), n4;
        }()), n3;
      }
      function et() {
        var n3, r4, e4;
        if (n3 = K2, r4 = [], (e4 = lt()) !== c2)
          for (; e4 !== c2; )
            r4.push(e4), e4 = lt();
        else
          r4 = c2;
        return (n3 = r4 !== c2 ? t3.substring(n3, K2) : r4) === c2 && (n3 = K2, (r4 = x3) !== c2 && (r4 = m2()), n3 = r4), n3;
      }
      function ot() {
        var n3;
        return (n3 = function() {
          var n4, r4, e4, o4;
          return n4 = K2, (r4 = at()) === c2 && (r4 = null), r4 !== c2 ? (E2.test(t3.charAt(K2)) ? (e4 = t3.charAt(K2), K2++) : (e4 = c2, tt(L2)), e4 !== c2 ? (58 === t3.charCodeAt(K2) ? (o4 = R2, K2++) : (o4 = c2, tt($2)), o4 !== c2 && at() !== c2 ? (r4 = M2(e4), n4 = r4) : (K2 = n4, n4 = c2)) : (K2 = n4, n4 = c2)) : (K2 = n4, n4 = c2), n4;
        }()) === c2 && (n3 = ut()), n3;
      }
      function ut() {
        var t4;
        return (t4 = at()) !== c2 && (t4 = k2()), t4;
      }
      function it() {
        var t4;
        return (t4 = function t5() {
          var n3, r4, e4;
          return n3 = K2, (r4 = ct()) !== c2 && at() !== c2 && (e4 = t5()) !== c2 ? (r4 = P2(r4, e4), n3 = r4) : (K2 = n3, n3 = c2), n3 === c2 && (n3 = K2, (r4 = ct()) !== c2 && (r4 = T2(r4)), n3 = r4), n3;
        }()) !== c2 && (t4 = O2(t4)), t4;
      }
      function ct() {
        var n3, r4, e4;
        if (n3 = K2, r4 = [], (e4 = lt()) !== c2)
          for (; e4 !== c2; )
            r4.push(e4), e4 = lt();
        else
          r4 = c2;
        return (n3 = r4 !== c2 ? t3.substring(n3, K2) : r4) === c2 && (n3 = x3), n3;
      }
      function at() {
        var n3;
        return 47 === t3.charCodeAt(K2) ? (n3 = U2, K2++) : (n3 = c2, tt(q2)), n3 === c2 && (92 === t3.charCodeAt(K2) ? (n3 = D2, K2++) : (n3 = c2, tt(G2))), n3;
      }
      function lt() {
        var n3;
        return H2.test(t3.charAt(K2)) ? (n3 = t3.charAt(K2), K2++) : (n3 = c2, tt(J2)), n3;
      }
      if ((e3 = l2()) !== c2 && K2 === t3.length)
        return e3;
      throw e3 !== c2 && K2 < t3.length && tt({ type: "end" }), o3 = V2, u2 = Q2 < t3.length ? t3.charAt(Q2) : null, i3 = Q2 < t3.length ? _2(Q2, Q2 + 1) : _2(Q2, Q2), new n(n.buildMessage(o3, u2), o3, u2, i3);
    };
    c = (t3, n3) => {
      const r3 = u(e(t3)).path.pop();
      if (!r3)
        return "";
      const { name: o3, ext: c2 } = i(r3);
      return true === n3 || n3 === c2 ? o3 : `${o3}${c2}`;
    };
    a = (n3) => {
      const r3 = u(e(n3));
      return r3.path.pop(), t(u(r3));
    };
    l = (t3) => {
      const n3 = u(e(t3)).path.pop();
      if (!n3)
        return "";
      const { ext: r3 } = i(n3);
      return r3;
    };
    p = (...n3) => {
      if (0 === n3.length)
        return ".";
      const r3 = n3.map(e), o3 = Object.assign({}, r3[0]);
      for (let t3 = 1; t3 < r3.length; t3++) {
        const e3 = r3[t3];
        if (e3.absolute)
          throw new Error('Cannot join an absolute path "' + n3[t3] + '" in the middle of other paths.');
        for (const t4 of e3.path)
          o3.path.push(t4);
      }
      return t(u(o3));
    };
    v = "/";
    d = (t3) => {
      return null !== e(t3).drive;
    };
    b = (t3) => e(t3).path.filter(Boolean).join("/");
  }
});

// ../../node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len = text.length;
  var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count2, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count2 || !exact) {
      var ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count2) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    var end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    var result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      var ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        var ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    var code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        var start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var init_scanner = __esm({
  "../../node_modules/jsonc-parser/lib/esm/impl/scanner.js"() {
    "use strict";
  }
});

// ../../node_modules/jsonc-parser/lib/esm/impl/format.js
var init_format = __esm({
  "../../node_modules/jsonc-parser/lib/esm/impl/format.js"() {
    "use strict";
    init_scanner();
  }
});

// ../../node_modules/jsonc-parser/lib/esm/impl/parser.js
function getNodePath(node) {
  if (!node.parent || !node.parent.children) {
    return [];
  }
  var path2 = getNodePath(node.parent);
  if (node.parent.type === "property") {
    var key = node.parent.children[0].value;
    path2.push(key);
  } else if (node.parent.type === "array") {
    var index3 = node.parent.children.indexOf(node);
    if (index3 !== -1) {
      path2.push(index3);
    }
  }
  return path2;
}
function contains(node, offset, includeRightBound) {
  if (includeRightBound === void 0) {
    includeRightBound = false;
  }
  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
}
function findNodeAtOffset(node, offset, includeRightBound) {
  if (includeRightBound === void 0) {
    includeRightBound = false;
  }
  if (contains(node, offset, includeRightBound)) {
    var children = node.children;
    if (Array.isArray(children)) {
      for (var i3 = 0; i3 < children.length && children[i3].offset <= offset; i3++) {
        var item = findNodeAtOffset(children[i3], offset, includeRightBound);
        if (item) {
          return item;
        }
      }
    }
    return node;
  }
  return void 0;
}
function visit(text, visitor, options) {
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options && options.disallowComments;
  var allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(
            14
            /* InvalidUnicode */
          );
          break;
        case 5:
          handleError(
            15
            /* InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError(
            13
            /* UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError(
              11
              /* UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError(
            12
            /* UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError(
            16
            /* InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(
              10
              /* InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(
            1
            /* InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var value = 0;
        try {
          value = JSON.parse(_scanner.getTokenValue());
          if (typeof value !== "number") {
            handleError(
              2
              /* InvalidNumberFormat */
            );
            value = 0;
          }
        } catch (e3) {
          handleError(
            2
            /* InvalidNumberFormat */
          );
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [
        2,
        5
        /* CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [
          2,
          5
          /* CommaToken */
        ]);
      }
    } else {
      handleError(5, [], [
        2,
        5
        /* CommaToken */
      ]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [
          2,
          5
          /* CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [
        2
        /* CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseValue()) {
        handleError(4, [], [
          4,
          5
          /* CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError(8, [
        4
        /* CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
var ParseOptions;
var init_parser = __esm({
  "../../node_modules/jsonc-parser/lib/esm/impl/parser.js"() {
    "use strict";
    init_scanner();
    (function(ParseOptions2) {
      ParseOptions2.DEFAULT = {
        allowTrailingComma: false
      };
    })(ParseOptions || (ParseOptions = {}));
  }
});

// ../../node_modules/jsonc-parser/lib/esm/impl/edit.js
var init_edit = __esm({
  "../../node_modules/jsonc-parser/lib/esm/impl/edit.js"() {
    "use strict";
    init_format();
    init_parser();
  }
});

// ../../node_modules/jsonc-parser/lib/esm/main.js
function printParseErrorCode(code) {
  switch (code) {
    case 1:
      return "InvalidSymbol";
    case 2:
      return "InvalidNumberFormat";
    case 3:
      return "PropertyNameExpected";
    case 4:
      return "ValueExpected";
    case 5:
      return "ColonExpected";
    case 6:
      return "CommaExpected";
    case 7:
      return "CloseBraceExpected";
    case 8:
      return "CloseBracketExpected";
    case 9:
      return "EndOfFileExpected";
    case 10:
      return "InvalidCommentToken";
    case 11:
      return "UnexpectedEndOfComment";
    case 12:
      return "UnexpectedEndOfString";
    case 13:
      return "UnexpectedEndOfNumber";
    case 14:
      return "InvalidUnicode";
    case 15:
      return "InvalidEscapeCharacter";
    case 16:
      return "InvalidCharacter";
  }
  return "<unknown ParseErrorCode>";
}
var createScanner2, findNodeAtOffset2, getNodePath2, visit2;
var init_main = __esm({
  "../../node_modules/jsonc-parser/lib/esm/main.js"() {
    "use strict";
    init_format();
    init_edit();
    init_scanner();
    init_parser();
    createScanner2 = createScanner;
    findNodeAtOffset2 = findNodeAtOffset;
    getNodePath2 = getNodePath;
    visit2 = visit;
  }
});

// ../../node_modules/@stoplight/ordered-object-literal/src/index.mjs
function createObj(target, order = Reflect.ownKeys(target)) {
  assertObjectLiteral(target);
  const t3 = new Proxy(target, traps);
  setOrder(t3, order);
  return t3;
}
function setOrder(target, order) {
  if (ORDER_KEY in target) {
    target[ORDER_KEY].length = 0;
    target[ORDER_KEY].push(...order);
    return true;
  } else {
    return Reflect.defineProperty(target, ORDER_KEY, {
      configurable: true,
      value: order
    });
  }
}
function getOrder(target) {
  return target[ORDER_KEY];
}
function isObject3(maybeObj) {
  return maybeObj !== null && typeof maybeObj === "object";
}
function isObjectLiteral(obj) {
  if (!isObject3(obj))
    return false;
  if (obj[Symbol.toStringTag] !== void 0) {
    const proto = Object.getPrototypeOf(obj);
    return proto === null || proto === Object.prototype;
  }
  return toStringTag(obj) === "Object";
}
function toStringTag(obj) {
  const tag = obj[Symbol.toStringTag];
  if (typeof tag === "string") {
    return tag;
  }
  const name = Reflect.apply(Object.prototype.toString, obj, []);
  return name.slice(8, name.length - 1);
}
function assertObjectLiteral(maybeObj, message) {
  if (isDevEnv() && !isObjectLiteral(maybeObj)) {
    throw new TypeError(message);
  }
}
function isDevEnv() {
  if (typeof process === "undefined" || !isObject3(process) || !isObject3(process.env)) {
    return false;
  }
  return process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test";
}
var TIMESTAMP, ORDER_KEY_ID, ORDER_KEY, STRINGIFIED_ORDER_KEY, traps;
var init_src = __esm({
  "../../node_modules/@stoplight/ordered-object-literal/src/index.mjs"() {
    "use strict";
    TIMESTAMP = Math.floor(Date.now() / 36e5);
    ORDER_KEY_ID = `__object_order_${TIMESTAMP}__`;
    ORDER_KEY = Symbol.for(ORDER_KEY_ID);
    STRINGIFIED_ORDER_KEY = String(ORDER_KEY);
    traps = {
      defineProperty(target, key, descriptor) {
        if (!(key in target) && ORDER_KEY in target) {
          target[ORDER_KEY].push(key);
        } else if ("value" in descriptor && key === ORDER_KEY && descriptor.value.lastIndexOf(ORDER_KEY) === -1) {
          descriptor.value.push(ORDER_KEY);
        }
        return Reflect.defineProperty(target, key, descriptor);
      },
      deleteProperty(target, key) {
        const hasKey = key in target;
        const deleted = Reflect.deleteProperty(target, key);
        if (deleted && hasKey && ORDER_KEY in target) {
          const index3 = target[ORDER_KEY].indexOf(key);
          if (index3 !== -1) {
            target[ORDER_KEY].splice(index3, 1);
          }
        }
        return deleted;
      },
      ownKeys(target) {
        if (ORDER_KEY in target) {
          return target[ORDER_KEY];
        }
        return Reflect.ownKeys(target);
      },
      set(target, key, value) {
        const hasKey = key in target;
        const set = Reflect.set(target, key, value);
        if (set && !hasKey && ORDER_KEY in target) {
          target[ORDER_KEY].push(key);
        }
        return set;
      }
    };
  }
});

// ../../node_modules/@stoplight/types/dist/index.mjs
var HttpOperationSecurityDeclarationTypes, HttpParamStyles, DiagnosticSeverity, NodeType, NodeFormat;
var init_dist = __esm({
  "../../node_modules/@stoplight/types/dist/index.mjs"() {
    "use strict";
    (function(HttpOperationSecurityDeclarationTypes2) {
      HttpOperationSecurityDeclarationTypes2["None"] = "none";
      HttpOperationSecurityDeclarationTypes2["Declared"] = "declared";
      HttpOperationSecurityDeclarationTypes2["InheritedFromService"] = "inheritedFromService";
    })(HttpOperationSecurityDeclarationTypes || (HttpOperationSecurityDeclarationTypes = {}));
    (function(HttpParamStyles2) {
      HttpParamStyles2["Unspecified"] = "unspecified";
      HttpParamStyles2["Simple"] = "simple";
      HttpParamStyles2["Matrix"] = "matrix";
      HttpParamStyles2["Label"] = "label";
      HttpParamStyles2["Form"] = "form";
      HttpParamStyles2["CommaDelimited"] = "commaDelimited";
      HttpParamStyles2["SpaceDelimited"] = "spaceDelimited";
      HttpParamStyles2["PipeDelimited"] = "pipeDelimited";
      HttpParamStyles2["DeepObject"] = "deepObject";
      HttpParamStyles2["TabDelimited"] = "tabDelimited";
    })(HttpParamStyles || (HttpParamStyles = {}));
    (function(DiagnosticSeverity2) {
      DiagnosticSeverity2[DiagnosticSeverity2["Error"] = 0] = "Error";
      DiagnosticSeverity2[DiagnosticSeverity2["Warning"] = 1] = "Warning";
      DiagnosticSeverity2[DiagnosticSeverity2["Information"] = 2] = "Information";
      DiagnosticSeverity2[DiagnosticSeverity2["Hint"] = 3] = "Hint";
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(NodeType2) {
      NodeType2["Article"] = "article";
      NodeType2["HttpService"] = "http_service";
      NodeType2["HttpServer"] = "http_server";
      NodeType2["HttpOperation"] = "http_operation";
      NodeType2["HttpCallback"] = "http_callback";
      NodeType2["Model"] = "model";
      NodeType2["Generic"] = "generic";
      NodeType2["Unknown"] = "unknown";
      NodeType2["TableOfContents"] = "table_of_contents";
      NodeType2["SpectralRuleset"] = "spectral_ruleset";
      NodeType2["Styleguide"] = "styleguide";
      NodeType2["Image"] = "image";
      NodeType2["StoplightResolutions"] = "stoplight_resolutions";
      NodeType2["StoplightOverride"] = "stoplight_override";
    })(NodeType || (NodeType = {}));
    (function(NodeFormat2) {
      NodeFormat2["Json"] = "json";
      NodeFormat2["Markdown"] = "markdown";
      NodeFormat2["Yaml"] = "yaml";
      NodeFormat2["Javascript"] = "javascript";
      NodeFormat2["Apng"] = "apng";
      NodeFormat2["Avif"] = "avif";
      NodeFormat2["Bmp"] = "bmp";
      NodeFormat2["Gif"] = "gif";
      NodeFormat2["Jpeg"] = "jpeg";
      NodeFormat2["Png"] = "png";
      NodeFormat2["Svg"] = "svg";
      NodeFormat2["Webp"] = "webp";
    })(NodeFormat || (NodeFormat = {}));
  }
});

// ../../node_modules/safe-stable-stringify/stable.js
var require_stable = __commonJS({
  "../../node_modules/safe-stable-stringify/stable.js"(exports, module2) {
    "use strict";
    module2.exports = stringify2;
    var indentation = "";
    var strEscapeSequencesRegExp = /[\x00-\x1f\x22\x5c]/;
    var strEscapeSequencesReplacer = /[\x00-\x1f\x22\x5c]/g;
    var meta = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000b",
      "\\f",
      "\\r",
      "\\u000e",
      "\\u000f",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001a",
      "\\u001b",
      "\\u001c",
      "\\u001d",
      "\\u001e",
      "\\u001f",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\"
    ];
    function escapeFn(str) {
      return meta[str.charCodeAt(0)];
    }
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return str;
      }
      if (str.length > 100) {
        return str.replace(strEscapeSequencesReplacer, escapeFn);
      }
      var result = "";
      var last = 0;
      for (var i3 = 0; i3 < str.length; i3++) {
        const point = str.charCodeAt(i3);
        if (point === 34 || point === 92 || point < 32) {
          if (last === i3) {
            result += meta[point];
          } else {
            result += `${str.slice(last, i3)}${meta[point]}`;
          }
          last = i3 + 1;
        }
      }
      if (last === 0) {
        result = str;
      } else if (last !== i3) {
        result += str.slice(last);
      }
      return result;
    }
    function stringifyFullFn(key, parent, stack, replacer, indent) {
      var i3, res, join3;
      const originalIndentation = indentation;
      var value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "object":
          if (value === null) {
            return "null";
          }
          for (i3 = 0; i3 < stack.length; i3++) {
            if (stack[i3] === value) {
              return '"[Circular]"';
            }
          }
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            stack.push(value);
            res = "[";
            indentation += indent;
            res += `
${indentation}`;
            join3 = `,
${indentation}`;
            for (i3 = 0; i3 < value.length - 1; i3++) {
              const tmp2 = stringifyFullFn(i3, value, stack, replacer, indent);
              res += tmp2 !== void 0 ? tmp2 : "null";
              res += join3;
            }
            const tmp = stringifyFullFn(i3, value, stack, replacer, indent);
            res += tmp !== void 0 ? tmp : "null";
            if (indentation !== "") {
              res += `
${originalIndentation}`;
            }
            res += "]";
            stack.pop();
            indentation = originalIndentation;
            return res;
          }
          var keys = insertSort(Object.keys(value));
          if (keys.length === 0) {
            return "{}";
          }
          stack.push(value);
          res = "{";
          indentation += indent;
          res += `
${indentation}`;
          join3 = `,
${indentation}`;
          var separator2 = "";
          for (i3 = 0; i3 < keys.length; i3++) {
            key = keys[i3];
            const tmp = stringifyFullFn(key, value, stack, replacer, indent);
            if (tmp !== void 0) {
              res += `${separator2}"${strEscape(key)}": ${tmp}`;
              separator2 = join3;
            }
          }
          if (separator2 !== "") {
            res += `
${originalIndentation}`;
          } else {
            res = "{";
          }
          res += "}";
          stack.pop();
          indentation = originalIndentation;
          return res;
        case "string":
          return `"${strEscape(value)}"`;
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
      }
    }
    function stringifyFullArr(key, value, stack, replacer, indent) {
      var i3, res, join3;
      const originalIndentation = indentation;
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "object":
          if (value === null) {
            return "null";
          }
          for (i3 = 0; i3 < stack.length; i3++) {
            if (stack[i3] === value) {
              return '"[Circular]"';
            }
          }
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            stack.push(value);
            res = "[";
            indentation += indent;
            res += `
${indentation}`;
            join3 = `,
${indentation}`;
            for (i3 = 0; i3 < value.length - 1; i3++) {
              const tmp2 = stringifyFullArr(i3, value[i3], stack, replacer, indent);
              res += tmp2 !== void 0 ? tmp2 : "null";
              res += join3;
            }
            const tmp = stringifyFullArr(i3, value[i3], stack, replacer, indent);
            res += tmp !== void 0 ? tmp : "null";
            if (indentation !== "") {
              res += `
${originalIndentation}`;
            }
            res += "]";
            stack.pop();
            indentation = originalIndentation;
            return res;
          }
          if (replacer.length === 0) {
            return "{}";
          }
          stack.push(value);
          res = "{";
          indentation += indent;
          res += `
${indentation}`;
          join3 = `,
${indentation}`;
          var separator2 = "";
          for (i3 = 0; i3 < replacer.length; i3++) {
            if (typeof replacer[i3] === "string" || typeof replacer[i3] === "number") {
              key = replacer[i3];
              const tmp = stringifyFullArr(key, value[key], stack, replacer, indent);
              if (tmp !== void 0) {
                res += `${separator2}"${strEscape(key)}": ${tmp}`;
                separator2 = join3;
              }
            }
          }
          if (separator2 !== "") {
            res += `
${originalIndentation}`;
          } else {
            res = "{";
          }
          res += "}";
          stack.pop();
          indentation = originalIndentation;
          return res;
        case "string":
          return `"${strEscape(value)}"`;
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
      }
    }
    function stringifyIndent(key, value, stack, indent) {
      var i3, res, join3;
      const originalIndentation = indentation;
      switch (typeof value) {
        case "object":
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, indent);
            }
            if (value === null) {
              return "null";
            }
          }
          for (i3 = 0; i3 < stack.length; i3++) {
            if (stack[i3] === value) {
              return '"[Circular]"';
            }
          }
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            stack.push(value);
            res = "[";
            indentation += indent;
            res += `
${indentation}`;
            join3 = `,
${indentation}`;
            for (i3 = 0; i3 < value.length - 1; i3++) {
              const tmp2 = stringifyIndent(i3, value[i3], stack, indent);
              res += tmp2 !== void 0 ? tmp2 : "null";
              res += join3;
            }
            const tmp = stringifyIndent(i3, value[i3], stack, indent);
            res += tmp !== void 0 ? tmp : "null";
            if (indentation !== "") {
              res += `
${originalIndentation}`;
            }
            res += "]";
            stack.pop();
            indentation = originalIndentation;
            return res;
          }
          var keys = insertSort(Object.keys(value));
          if (keys.length === 0) {
            return "{}";
          }
          stack.push(value);
          res = "{";
          indentation += indent;
          res += `
${indentation}`;
          join3 = `,
${indentation}`;
          var separator2 = "";
          for (i3 = 0; i3 < keys.length; i3++) {
            key = keys[i3];
            const tmp = stringifyIndent(key, value[key], stack, indent);
            if (tmp !== void 0) {
              res += `${separator2}"${strEscape(key)}": ${tmp}`;
              separator2 = join3;
            }
          }
          if (separator2 !== "") {
            res += `
${originalIndentation}`;
          } else {
            res = "{";
          }
          res += "}";
          stack.pop();
          indentation = originalIndentation;
          return res;
        case "string":
          return `"${strEscape(value)}"`;
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
      }
    }
    function stringifyReplacerArr(key, value, stack, replacer) {
      var i3, res;
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "object":
          if (value === null) {
            return "null";
          }
          for (i3 = 0; i3 < stack.length; i3++) {
            if (stack[i3] === value) {
              return '"[Circular]"';
            }
          }
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            stack.push(value);
            res = "[";
            for (i3 = 0; i3 < value.length - 1; i3++) {
              const tmp2 = stringifyReplacerArr(i3, value[i3], stack, replacer);
              res += tmp2 !== void 0 ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifyReplacerArr(i3, value[i3], stack, replacer);
            res += tmp !== void 0 ? tmp : "null";
            res += "]";
            stack.pop();
            return res;
          }
          if (replacer.length === 0) {
            return "{}";
          }
          stack.push(value);
          res = "{";
          var separator2 = "";
          for (i3 = 0; i3 < replacer.length; i3++) {
            if (typeof replacer[i3] === "string" || typeof replacer[i3] === "number") {
              key = replacer[i3];
              const tmp = stringifyReplacerArr(key, value[key], stack, replacer);
              if (tmp !== void 0) {
                res += `${separator2}"${strEscape(key)}":${tmp}`;
                separator2 = ",";
              }
            }
          }
          res += "}";
          stack.pop();
          return res;
        case "string":
          return `"${strEscape(value)}"`;
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
      }
    }
    function stringifyReplacerFn(key, parent, stack, replacer) {
      var i3, res;
      var value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "object":
          if (value === null) {
            return "null";
          }
          for (i3 = 0; i3 < stack.length; i3++) {
            if (stack[i3] === value) {
              return '"[Circular]"';
            }
          }
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            stack.push(value);
            res = "[";
            for (i3 = 0; i3 < value.length - 1; i3++) {
              const tmp2 = stringifyReplacerFn(i3, value, stack, replacer);
              res += tmp2 !== void 0 ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifyReplacerFn(i3, value, stack, replacer);
            res += tmp !== void 0 ? tmp : "null";
            res += "]";
            stack.pop();
            return res;
          }
          var keys = insertSort(Object.keys(value));
          if (keys.length === 0) {
            return "{}";
          }
          stack.push(value);
          res = "{";
          var separator2 = "";
          for (i3 = 0; i3 < keys.length; i3++) {
            key = keys[i3];
            const tmp = stringifyReplacerFn(key, value, stack, replacer);
            if (tmp !== void 0) {
              res += `${separator2}"${strEscape(key)}":${tmp}`;
              separator2 = ",";
            }
          }
          res += "}";
          stack.pop();
          return res;
        case "string":
          return `"${strEscape(value)}"`;
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
      }
    }
    function stringifySimple(key, value, stack) {
      var i3, res;
      switch (typeof value) {
        case "object":
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          for (i3 = 0; i3 < stack.length; i3++) {
            if (stack[i3] === value) {
              return '"[Circular]"';
            }
          }
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            stack.push(value);
            res = "[";
            for (i3 = 0; i3 < value.length - 1; i3++) {
              const tmp2 = stringifySimple(i3, value[i3], stack);
              res += tmp2 !== void 0 ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(i3, value[i3], stack);
            res += tmp !== void 0 ? tmp : "null";
            res += "]";
            stack.pop();
            return res;
          }
          var keys = insertSort(Object.keys(value));
          if (keys.length === 0) {
            return "{}";
          }
          stack.push(value);
          var separator2 = "";
          res = "{";
          for (i3 = 0; i3 < keys.length; i3++) {
            key = keys[i3];
            const tmp = stringifySimple(key, value[key], stack);
            if (tmp !== void 0) {
              res += `${separator2}"${strEscape(key)}":${tmp}`;
              separator2 = ",";
            }
          }
          res += "}";
          stack.pop();
          return res;
        case "string":
          return `"${strEscape(value)}"`;
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
      }
    }
    function insertSort(arr) {
      for (var i3 = 1; i3 < arr.length; i3++) {
        const tmp = arr[i3];
        var j2 = i3;
        while (j2 !== 0 && arr[j2 - 1] > tmp) {
          arr[j2] = arr[j2 - 1];
          j2--;
        }
        arr[j2] = tmp;
      }
      return arr;
    }
    function stringify2(value, replacer, spacer) {
      var i3;
      var indent = "";
      indentation = "";
      if (arguments.length > 1) {
        if (typeof spacer === "number") {
          for (i3 = 0; i3 < spacer; i3 += 1) {
            indent += " ";
          }
        } else if (typeof spacer === "string") {
          indent = spacer;
        }
        if (indent !== "") {
          if (replacer !== void 0 && replacer !== null) {
            if (typeof replacer === "function") {
              return stringifyFullFn("", { "": value }, [], replacer, indent);
            }
            if (Array.isArray(replacer)) {
              return stringifyFullArr("", value, [], replacer, indent);
            }
          }
          return stringifyIndent("", value, [], indent);
        }
        if (typeof replacer === "function") {
          return stringifyReplacerFn("", { "": value }, [], replacer);
        }
        if (Array.isArray(replacer)) {
          return stringifyReplacerArr("", value, [], replacer);
        }
      }
      return stringifySimple("", value, []);
    }
  }
});

// ../../node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "../../node_modules/safe-stable-stringify/index.js"(exports, module2) {
    "use strict";
    var stringify2 = require_stable();
    module2.exports = stringify2;
    stringify2.default = stringify2;
  }
});

// ../../node_modules/@stoplight/json/index.es.js
var index_es_exports2 = {};
__export(index_es_exports2, {
  BUNDLE_ROOT: () => Z,
  ERRORS_ROOT: () => q,
  KEYS: () => Ae,
  bundleTarget: () => G,
  decodePointer: () => U,
  decodePointerFragment: () => Q,
  decodePointerUriFragment: () => U,
  decycle: () => X,
  encodePointer: () => Y,
  encodePointerFragment: () => x2,
  encodePointerUriFragment: () => k,
  encodeUriPointer: () => N,
  extractPointerFromRef: () => ee,
  extractSourceFromRef: () => V,
  getFirstPrimitiveProperty: () => te,
  getJsonPathForPosition: () => re,
  getLastPathSegment: () => ne,
  getLocationForJsonPath: () => oe,
  hasRef: () => $,
  isExternalRef: () => M,
  isLocalRef: () => E,
  isPlainObject: () => w,
  parseTree: () => ae,
  parseWithPointers: () => ie,
  pathToPointer: () => P,
  pointerToPath: () => K,
  remapRefs: () => F,
  renameObjectKey: () => le,
  reparentBundleTarget: () => pe,
  resolveExternalRef: () => ye,
  resolveExternalRefWithLocation: () => ge,
  resolveInlineRef: () => B,
  resolveInlineRefWithLocation: () => z,
  safeParse: () => de,
  safeStringify: () => ve,
  startsWith: () => be,
  stringify: () => we,
  toPropertyPath: () => Oe,
  trapAccess: () => Ee,
  traverse: () => D,
  trimStart: () => Se
});
function w(e3) {
  if ("object" != typeof e3 || null === e3)
    return false;
  const t3 = Object.getPrototypeOf(e3);
  return null === t3 || t3 === Object.prototype || "function" == typeof e3.constructor && Function.toString.call(Object) === Function.toString.call(e3.constructor);
}
function O(e3, t3, r3) {
  if (!w(e3) && !Array.isArray(e3) || !(t3 in e3))
    throw new ReferenceError(`Could not resolve '${r3}'`);
}
function j(e3) {
  if ("string" != typeof e3.$ref)
    throw new TypeError("$ref should be a string");
}
function N(e3) {
  return e3.replace(_, encodeURIComponent);
}
function T(e3) {
  try {
    return decodeURIComponent(e3);
  } catch (t3) {
    return e3;
  }
}
function F(e3, t3, r3) {
  D(e3, { onProperty({ property: e4, propertyValue: n3, parent: o3 }) {
    "$ref" === e4 && "string" == typeof n3 && n3.startsWith(t3) && (o3.$ref = `${r3}${n3.slice(t3.length)}`);
  } });
}
function W(e3, t3) {
  return w(t3) && w(e3) && ("summary" in e3 || "description" in e3) ? Object.assign(Object.assign(Object.assign({}, t3), "description" in e3 ? { description: e3.description } : null), "summary" in e3 ? { summary: e3.summary } : null) : t3;
}
function* L(e3, t3, r3) {
  A(e3.value) && (j(e3.value), yield [-1, e3.value]);
  for (const [n3, o3] of t3.entries())
    O(e3.value, o3, r3), e3.value = e3.value[o3], A(e3.value) && (j(e3.value), yield [n3, e3.value]);
}
function B(e3, t3) {
  return z(e3, t3).value;
}
function z(e3, t3) {
  return function e4(t4, r3, n3, o3) {
    if (null !== V(r3))
      throw new ReferenceError("Cannot resolve external references");
    const i3 = K(r3);
    let a3 = [...i3];
    "#" === r3 && A(t4) && (j(t4), i3.unshift(...K(t4.$ref)));
    const s2 = { value: t4 };
    for (const [c2, u2] of L(s2, i3, r3)) {
      if (n3.includes(u2))
        return { source: null, location: null != o3 ? o3 : a3, value: n3[n3.length - 1] };
      n3.push(u2);
      const r4 = e4(t4, u2.$ref, n3, a3);
      s2.value = r4.value, (a3 = r4.location).push(...i3.slice(c2 + 1));
    }
    return { source: null, location: a3, value: n3.length > 0 ? W(n3[n3.length - 1], s2.value) : s2.value };
  }(e3, t3, []);
}
function ne(e3) {
  return Q(e3.split("/").pop() || "");
}
function ae(e3, t3 = [], r3) {
  const n3 = ce(e3);
  let o3 = { type: "array", offset: -1, length: -1, children: [], parent: void 0 }, i3 = null, a3 = [];
  const s2 = /* @__PURE__ */ new WeakMap(), c2 = [];
  function u2(e4) {
    "property" === o3.type && (o3.length = e4 - o3.offset, o3 = o3.parent);
  }
  function l2(e4, t4, r4) {
    return { start: { line: e4, character: t4 }, end: { line: e4, character: t4 + r4 } };
  }
  function f2(e4) {
    return o3.children.push(e4), e4;
  }
  function p2(e4) {
    Array.isArray(a3) ? a3.push(e4) : null !== i3 && (a3[i3] = e4);
  }
  function m2(e4) {
    p2(e4), c2.push(a3), a3 = e4, i3 = null;
  }
  function b3() {
    a3 = c2.pop();
  }
  visit2(e3, { onObjectBegin: (e4, t4, n4, i4) => {
    o3 = f2({ type: "object", offset: e4, length: -1, parent: o3, children: [], range: l2(n4, i4, t4) }), false === r3.ignoreDuplicateKeys && s2.set(o3, []), m2(function(e5) {
      return e5 ? createObj({}) : {};
    }(true === r3.preserveKeyOrder));
  }, onObjectProperty: (e4, n4, c3, u3, p3) => {
    if ((o3 = f2({ type: "property", offset: n4, length: -1, parent: o3, children: [] })).children.push({ type: "string", value: e4, offset: n4, length: c3, parent: o3 }), false === r3.ignoreDuplicateKeys) {
      const r4 = s2.get(o3.parent);
      r4 && (0 !== r4.length && r4.includes(e4) ? t3.push({ range: l2(u3, p3, c3), message: "DuplicateKey", severity: DiagnosticSeverity.Error, path: ue(o3), code: 20 }) : r4.push(e4));
    }
    true === r3.preserveKeyOrder && function(e5, t4) {
      if (!(t4 in e5))
        return;
      const r4 = getOrder(e5), n5 = r4.indexOf(t4);
      -1 !== n5 && (r4.splice(n5, 1), r4.push(t4));
    }(a3, e4), i3 = e4;
  }, onObjectEnd: (e4, t4, n4, i4) => {
    false === r3.ignoreDuplicateKeys && s2.delete(o3), o3.length = e4 + t4 - o3.offset, o3.range && (o3.range.end.line = n4, o3.range.end.character = i4 + t4), o3 = o3.parent, u2(e4 + t4), b3();
  }, onArrayBegin: (e4, t4, r4, n4) => {
    o3 = f2({ type: "array", offset: e4, length: -1, parent: o3, children: [], range: l2(r4, n4, t4) }), m2([]);
  }, onArrayEnd: (e4, t4, r4, n4) => {
    o3.length = e4 + t4 - o3.offset, o3.range && (o3.range.end.line = r4, o3.range.end.character = n4 + t4), o3 = o3.parent, u2(e4 + t4), b3();
  }, onLiteralValue: (e4, t4, r4, n4, i4) => {
    f2({ type: se(e4), offset: t4, length: r4, parent: o3, value: e4, range: l2(n4, i4, r4) }), u2(t4 + r4), p2(e4);
  }, onSeparator: (e4, t4) => {
    "property" === o3.type && (":" === e4 ? o3.colonOffset = t4 : "," === e4 && u2(t4));
  }, onError: (e4, r4, n4, o4, i4) => {
    t3.push({ range: l2(o4, i4, n4), message: printParseErrorCode(e4), severity: DiagnosticSeverity.Error, code: e4 });
  } }, r3);
  const w2 = o3.children[0];
  return w2 && delete w2.parent, { ast: w2, data: a3[0], lineMap: n3 };
}
function se(e3) {
  switch (typeof e3) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    default:
      return "null";
  }
}
function ue(e3, t3 = []) {
  return "property" === e3.type && t3.unshift(e3.children[0].value), void 0 !== e3.parent ? ("array" === e3.parent.type && void 0 !== e3.parent.parent && t3.unshift(e3.parent.children.indexOf(e3)), ue(e3.parent, t3)) : t3;
}
function fe(e3) {
  return w(e3) || Array.isArray(e3);
}
function pe(e3, t3, r3) {
  if (r3.length <= 1 || t3.length <= 1)
    throw Error("Source/target path must not be empty and point at root");
  if (0 === t3.indexOf(r3))
    throw Error("Target path cannot be contained within source");
  const n3 = K(t3);
  let o3 = e3;
  for (const e4 of n3) {
    if (!fe(o3))
      return;
    o3 = o3[e4];
  }
  if (!fe(o3))
    return;
  const i3 = K(r3);
  let a3 = e3;
  for (const [e4, t4] of i3.entries()) {
    if (!fe(a3) || t4 in a3)
      return;
    const r4 = e4 === i3.length - 1 ? o3 : {};
    a3[t4] = r4, a3 = r4;
  }
  delete e3[n3[0]], function e4(t4, r4, n4) {
    for (const o4 of Object.keys(t4)) {
      const i4 = t4[o4];
      if ("$ref" !== o4)
        fe(i4) && e4(i4, r4, n4);
      else {
        if ("string" != typeof i4 || !E(i4))
          continue;
        0 === i4.indexOf(r4) && (t4[o4] = i4.replace(r4, n4));
      }
    }
  }(e3, t3, r3);
}
async function he(e3, t3, r3, n3, o3) {
  let i3 = function(e4, t4) {
    const r4 = V(t4);
    return null === r4 ? e4 : s(r4) ? r4 : p(a(e4), r4);
  }(t3, r3);
  const a3 = ee(r3) || "#", l2 = await e3[i3], f2 = K(a3);
  let p2 = [...f2];
  const h2 = { value: l2 };
  for (const [r4, s2] of L(h2, f2, a3)) {
    if (n3.includes(s2))
      return { source: t3, location: null != o3 ? o3 : p2, value: n3[n3.length - 1] };
    n3.push(s2);
    const a4 = await he(e3, i3, s2.$ref, n3, p2);
    ({ source: i3, location: p2 } = a4), h2.value = a4.value, p2.push(...f2.slice(r4 + 1));
  }
  return { source: i3, location: p2, value: n3.length > 0 ? W(n3[n3.length - 1], h2.value) : h2.value };
}
async function ye(e3, t3, r3) {
  return (await ge(e3, t3, r3)).value;
}
function ge(e3, t3, r3) {
  return he(e3, t3, r3, []);
}
function Oe(e3) {
  return e3.replace(/^(\/|#\/)/, "").split("/").map(Q).map(je).join(".");
}
function je(e3) {
  return e3.includes(".") ? `["${e3.replace(/"/g, '\\"')}"]` : e3;
}
function Se(e3, t3) {
  if ("string" == typeof e3 && "string" == typeof t3)
    return (0, import_lodash2.trimStart)(e3, t3);
  if (!(e3 && Array.isArray(e3) && e3.length && t3 && Array.isArray(t3) && t3.length))
    return e3;
  let r3 = 0;
  for (const n3 in e3)
    if (e3.hasOwnProperty(n3)) {
      if (e3[n3] !== t3[n3])
        break;
      r3++;
    }
  return e3.slice(r3);
}
var import_lodash2, import_safe_stable_stringify, A, $, E, S, x2, _, k, P, I, R, U, K, J, C, D, M, V, Z, q, G, H, Q, X, Y, ee, te, re, oe, ie, ce, le, de, me, ve, be, we, Ae, $e, Ee;
var init_index_es2 = __esm({
  "../../node_modules/@stoplight/json/index.es.js"() {
    "use strict";
    import_lodash2 = __toESM(require_lodash());
    init_index_es();
    init_main();
    init_src();
    init_dist();
    import_safe_stable_stringify = __toESM(require_safe_stable_stringify());
    A = (e3) => w(e3) && "$ref" in e3;
    $ = (e3) => A(e3) && "string" == typeof e3.$ref;
    E = (e3) => e3.length > 0 && ("#" === e3 || /^#\S*$/.test(e3));
    S = (e3, t3, r3) => {
      const n3 = e3.toString();
      let o3 = "", i3 = n3, a3 = 0, s2 = i3.indexOf(t3);
      for (; s2 > -1; )
        o3 += n3.substring(a3, a3 + s2) + r3, i3 = i3.substring(s2 + t3.length, i3.length), a3 += s2 + t3.length, s2 = i3.indexOf(t3);
      return i3.length > 0 && (o3 += n3.substring(n3.length - i3.length, n3.length)), o3;
    };
    x2 = (e3) => "number" == typeof e3 ? e3 : S(S(e3, "~", "~0"), "/", "~1");
    _ = /[^a-zA–Z0–9_.!~*'()\/\-\u{D800}-\u{DFFF}]/gu;
    k = (e3) => {
      const t3 = x2(e3);
      return "number" == typeof t3 ? t3 : N(t3);
    };
    P = (e3) => I(e3);
    I = (e3) => {
      if (e3 && "object" != typeof e3)
        throw new TypeError("Invalid type: path must be an array of segments.");
      return 0 === e3.length ? "#" : `#/${e3.map(k).join("/")}`;
    };
    R = /%[0-9a-f]+/gi;
    U = (e3) => {
      let t3;
      try {
        t3 = decodeURIComponent(e3);
      } catch (r3) {
        t3 = e3.replace(R, T);
      }
      return S(S(t3, "~1", "/"), "~0", "~");
    };
    K = (e3) => J(e3);
    J = (e3) => {
      if ("string" != typeof e3)
        throw new TypeError("Invalid type: JSON Pointers are represented as strings.");
      if (0 === e3.length || "#" !== e3[0])
        throw new URIError("Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.");
      if (1 === e3.length)
        return [];
      if ("/" !== e3[1])
        throw new URIError("Invalid JSON Pointer syntax.");
      return ((e4) => {
        const t3 = e4.length, r3 = [];
        let n3 = -1;
        for (; ++n3 < t3; )
          r3.push(U(e4[n3]));
        return r3;
      })(e3.substring(2).split("/"));
    };
    C = (e3, t3, r3) => {
      const n3 = { value: e3, path: r3 };
      t3.onEnter && t3.onEnter(n3);
      for (const n4 of Object.keys(e3)) {
        const o3 = e3[n4];
        t3.onProperty && t3.onProperty({ parent: e3, parentPath: r3, property: n4, propertyValue: o3 }), "object" == typeof o3 && null !== o3 && C(o3, t3, r3.concat(n4));
      }
      t3.onLeave && t3.onLeave(n3);
    };
    D = (e3, t3) => {
      "object" == typeof e3 && null !== e3 && C(e3, "function" == typeof t3 ? { onProperty: t3 } : t3, []);
    };
    M = (e3) => e3.length > 0 && "#" !== e3[0];
    V = (e3) => {
      if ("string" != typeof e3 || 0 === e3.length || !M(e3))
        return null;
      const t3 = e3.indexOf("#");
      return -1 === t3 ? e3 : e3.slice(0, t3);
    };
    Z = "#/__bundled__";
    q = "#/__errors__";
    G = ({ document: t3, path: r3, bundleRoot: n3 = "#/__bundled__", errorsRoot: o3 = "#/__errors__", cloneDocument: i3 = true, keyProvider: a3 }, s2) => {
      if (r3 === n3 || r3 === o3)
        throw new Error("Roots do not make any sense");
      const c2 = i3 ? (0, import_lodash2.cloneDeep)(t3) : t3;
      return H(c2, K(n3), K(o3), r3, a3)(r3, { [r3]: true }, s2);
    };
    H = (e3, a3, s2, c2, u2) => {
      const l2 = /* @__PURE__ */ new Set(), f2 = (p2, h2, y, g2 = {}, d2 = {}, m2 = {}) => {
        const v2 = K(p2), b3 = (0, import_lodash2.get)(e3, v2);
        D(y || b3, { onEnter: ({ value: s3 }) => {
          if ($(s3) && E(s3.$ref)) {
            const y2 = s3.$ref;
            if (m2[y2])
              return;
            if (y2 === p2 && (g2[y2] = "#"), g2[y2])
              return void (s3.$ref = g2[y2]);
            let v3, b4, w3, O2, j2;
            try {
              let r3;
              v3 = K(y2), u2 && (r3 = u2({ document: e3, path: v3 })), r3 || (r3 = (({ document: e4, path: r4 }) => {
                if (0 === r4.length)
                  return "root";
                if (Array.isArray((0, import_lodash2.get)(e4, r4.slice(0, -1))))
                  return `${r4[r4.length - 2]}_${r4[r4.length - 1]}`;
                return String(r4[r4.length - 1]);
              })({ document: e3, path: v3 })), w3 = r3;
              let n3 = 1;
              for (; l2.has(w3); )
                if (w3 = `${r3}_${++n3}`, n3 > 20)
                  throw new Error(`Keys ${r3}_2 through ${r3}_20 already taken.`);
              l2.add(w3), b4 = [...a3, w3], O2 = P(b4);
            } catch (e4) {
              m2[y2] = e4 instanceof Error ? e4.message : String(e4);
            }
            if (!v3 || !b4 || !O2)
              return;
            if ("object" == typeof e3 && null !== e3 && !(j2 = (0, import_lodash2.get)(e3, v3)))
              try {
                j2 = B(Object(e3), y2);
              } catch (e4) {
              }
            void 0 !== j2 && (g2[y2] = O2, s3.$ref = O2, (0, import_lodash2.has)(d2, b4) || (Array.isArray(j2) ? (0, import_lodash2.set)(d2, b4, new Array(j2.length).fill(null)) : "object" == typeof j2 && (0, import_lodash2.setWith)(d2, b4, {}, Object), (0, import_lodash2.set)(d2, b4, j2), "#" === y2 ? function(e4, t3, n3, o3) {
              const a4 = n3.map((e5) => `[${JSON.stringify(e5)}]`).join(""), s4 = JSON.parse(JSON.stringify((0, import_lodash2.omit)(Object(e4), a4))), c3 = {};
              (0, import_lodash2.set)(t3, o3, s4), (0, import_lodash2.set)(s4, n3, c3), F(s4, "#", P(o3)), c3.$ref = "#";
            }(e3, d2, K(c2), b4) : h2[y2] || (h2[y2] = true, f2(p2, h2, j2, g2, d2, m2), h2[y2] = false)));
          }
        } });
        const w2 = (0, import_lodash2.get)(d2, a3);
        return w2 && Object.keys(w2).length && (0, import_lodash2.set)(b3, a3, w2), (Object.keys(m2).length || (0, import_lodash2.has)(e3, s2)) && (0, import_lodash2.set)(b3, s2, (0, import_lodash2.has)(e3, s2) ? (0, import_lodash2.get)(e3, s2) : m2), b3;
      };
      return f2;
    };
    Q = (e3) => S(S(e3, "~1", "/"), "~0", "~");
    X = (e3, t3) => {
      const r3 = /* @__PURE__ */ new WeakMap();
      return function e4(n3, o3) {
        let i3;
        if (t3 && (n3 = t3(n3)), w(n3) || Array.isArray(n3)) {
          const t4 = r3.get(n3);
          return t4 ? { $ref: t4 } : (r3.set(n3, P(o3)), Array.isArray(n3) ? i3 = n3.map((t5, r4) => e4(t5, [...o3, String(r4)])) : (i3 = {}, Object.keys(n3).forEach((t5) => {
            i3[t5] = e4(n3[t5], [...o3, t5]);
          })), r3.delete(n3), i3);
        }
        return n3;
      }(e3, []);
    };
    Y = (e3) => S(S(e3, "~", "~0"), "//", "/~1");
    ee = (e3) => {
      if ("string" != typeof e3 || 0 === e3.length)
        return null;
      const t3 = e3.indexOf("#");
      return -1 === t3 ? null : e3.slice(t3);
    };
    te = (e3) => {
      const t3 = createScanner2(e3, true);
      if (t3.scan(), 1 !== t3.getToken())
        return;
      if (t3.scan(), 2 === t3.getToken())
        return;
      if (10 !== t3.getToken())
        throw new SyntaxError("Unexpected character");
      const r3 = t3.getTokenValue();
      if (t3.scan(), 6 !== t3.getToken())
        throw new SyntaxError("Colon expected");
      switch (t3.scan(), t3.getToken()) {
        case 10:
          return [r3, t3.getTokenValue()];
        case 11:
          return [r3, Number(t3.getTokenValue())];
        case 8:
          return [r3, true];
        case 9:
          return [r3, false];
        case 7:
          return [r3, null];
        case 16:
          throw new SyntaxError("Unexpected character");
        case 17:
          throw new SyntaxError("Unexpected end of file");
        default:
          return;
      }
    };
    re = ({ lineMap: e3, ast: t3 }, r3) => {
      const n3 = e3[r3.line], o3 = e3[r3.line + 1];
      if (void 0 === n3)
        return;
      const i3 = findNodeAtOffset2(t3, void 0 === o3 ? n3 + r3.character : Math.min(o3, n3 + r3.character), true);
      if (void 0 === i3)
        return;
      const a3 = getNodePath2(i3);
      return 0 !== a3.length ? a3 : void 0;
    };
    oe = ({ ast: e3 }, t3, r3 = false) => {
      const n3 = function(e4, t4, r4) {
        e:
          for (const n4 of t4) {
            const t5 = Number.isInteger(Number(n4)) ? Number(n4) : n4;
            if ("string" == typeof t5 || "number" == typeof t5 && "array" !== e4.type) {
              if ("object" !== e4.type || !Array.isArray(e4.children))
                return r4 ? e4 : void 0;
              for (const r5 of e4.children)
                if (Array.isArray(r5.children) && r5.children[0].value === String(t5) && 2 === r5.children.length) {
                  e4 = r5.children[1];
                  continue e;
                }
              return r4 ? e4 : void 0;
            }
            if ("array" !== e4.type || t5 < 0 || !Array.isArray(e4.children) || t5 >= e4.children.length)
              return r4 ? e4 : void 0;
            e4 = e4.children[t5];
          }
        return e4;
      }(e3, t3, r3);
      if (void 0 !== n3 && void 0 !== n3.range)
        return { range: n3.range };
    };
    ie = (e3, t3 = { disallowComments: true }) => {
      const r3 = [], { ast: n3, data: o3, lineMap: i3 } = ae(e3, r3, t3);
      return { data: o3, diagnostics: r3, ast: n3, lineMap: i3 };
    };
    ce = (e3) => {
      const t3 = [0];
      let r3 = 0;
      for (; r3 < e3.length; r3++)
        "\n" === e3[r3] && t3.push(r3 + 1);
      return t3.push(r3 + 1), t3;
    };
    le = (e3, t3, r3) => {
      if (!e3 || !Object.hasOwnProperty.call(e3, t3) || t3 === r3)
        return e3;
      const n3 = {};
      for (const [o3, i3] of Object.entries(e3))
        o3 === t3 ? n3[r3] = i3 : o3 in n3 || (n3[o3] = i3);
      return n3;
    };
    de = (e3, t3) => {
      if ("string" != typeof e3)
        return e3;
      try {
        const r3 = me(e3);
        return "string" == typeof r3 ? r3 : JSON.parse(e3, t3);
      } catch (e4) {
        return;
      }
    };
    me = (e3) => {
      const t3 = Number(e3);
      return Number.isFinite(t3) ? String(t3) === e3 ? t3 : e3 : NaN;
    };
    ve = (e3, t3, r3) => {
      if ("string" == typeof e3)
        return e3;
      try {
        return JSON.stringify(e3, t3, r3);
      } catch (n3) {
        return (0, import_safe_stable_stringify.default)(e3, t3, r3);
      }
    };
    be = (e3, t3) => {
      if (e3 instanceof Array) {
        if (t3 instanceof Array) {
          if (t3.length > e3.length)
            return false;
          for (const r3 in t3) {
            if (!t3.hasOwnProperty(r3))
              continue;
            const n3 = parseInt(e3[r3]), o3 = parseInt(t3[r3]);
            if (isNaN(n3) && isNaN(o3)) {
              if (e3[r3] !== t3[r3])
                return false;
            } else if (n3 !== o3)
              return false;
          }
        }
      } else {
        if ("string" != typeof e3)
          return false;
        if ("string" == typeof t3)
          return e3.startsWith(t3);
      }
      return true;
    };
    we = (e3, t3, r3) => {
      const n3 = ve(e3, t3, r3);
      if (void 0 === n3)
        throw new Error("The value could not be stringified");
      return n3;
    };
    Ae = Symbol.for(ORDER_KEY_ID);
    $e = { ownKeys: (e3) => Ae in e3 ? e3[Ae] : Reflect.ownKeys(e3) };
    Ee = (e3) => new Proxy(e3, $e);
  }
});

// ../../node_modules/@stoplight/spectral-parsers/dist/json.js
var require_json = __commonJS({
  "../../node_modules/@stoplight/spectral-parsers/dist/json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Json = exports.parseJson = void 0;
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var parseJson = (input) => (0, json_1.parseWithPointers)(input, {
      ignoreDuplicateKeys: false,
      preserveKeyOrder: true
    });
    exports.parseJson = parseJson;
    exports.Json = {
      parse: exports.parseJson,
      getLocationForJsonPath: json_1.getLocationForJsonPath,
      trapAccess: json_1.trapAccess
    };
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/yamlAST.js
var require_yamlAST = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/yamlAST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Kind;
    (function(Kind2) {
      Kind2[Kind2["SCALAR"] = 0] = "SCALAR";
      Kind2[Kind2["MAPPING"] = 1] = "MAPPING";
      Kind2[Kind2["MAP"] = 2] = "MAP";
      Kind2[Kind2["SEQ"] = 3] = "SEQ";
      Kind2[Kind2["ANCHOR_REF"] = 4] = "ANCHOR_REF";
      Kind2[Kind2["INCLUDE_REF"] = 5] = "INCLUDE_REF";
    })(Kind = exports.Kind || (exports.Kind = {}));
    function newMapping(key, value) {
      var end = value ? value.endPosition : key.endPosition + 1;
      var node = {
        key,
        value,
        startPosition: key.startPosition,
        endPosition: end,
        kind: Kind.MAPPING,
        parent: null,
        errors: []
      };
      return node;
    }
    exports.newMapping = newMapping;
    function newAnchorRef(key, start, end, value) {
      return {
        errors: [],
        referencesAnchor: key,
        value,
        startPosition: start,
        endPosition: end,
        kind: Kind.ANCHOR_REF,
        parent: null
      };
    }
    exports.newAnchorRef = newAnchorRef;
    function newScalar(v2 = "") {
      const result = {
        errors: [],
        startPosition: -1,
        endPosition: -1,
        value: "" + v2,
        kind: Kind.SCALAR,
        parent: null,
        doubleQuoted: false,
        rawValue: "" + v2
      };
      if (typeof v2 !== "string") {
        result.valueObject = v2;
      }
      return result;
    }
    exports.newScalar = newScalar;
    function newItems() {
      return {
        errors: [],
        startPosition: -1,
        endPosition: -1,
        items: [],
        kind: Kind.SEQ,
        parent: null
      };
    }
    exports.newItems = newItems;
    function newSeq() {
      return newItems();
    }
    exports.newSeq = newSeq;
    function newMap(mappings) {
      return {
        errors: [],
        startPosition: -1,
        endPosition: -1,
        mappings: mappings ? mappings : [],
        kind: Kind.MAP,
        parent: null
      };
    }
    exports.newMap = newMap;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/common.js
var require_common = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isNothing(subject) {
      return typeof subject === "undefined" || null === subject;
    }
    exports.isNothing = isNothing;
    function isObject4(subject) {
      return typeof subject === "object" && null !== subject;
    }
    exports.isObject = isObject4;
    function toArray(sequence) {
      if (Array.isArray(sequence)) {
        return sequence;
      } else if (isNothing(sequence)) {
        return [];
      }
      return [sequence];
    }
    exports.toArray = toArray;
    function extend(target, source) {
      var index3, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index3 = 0, length = sourceKeys.length; index3 < length; index3 += 1) {
          key = sourceKeys[index3];
          target[key] = source[key];
        }
      }
      return target;
    }
    exports.extend = extend;
    function repeat(string, count2) {
      var result = "", cycle;
      for (cycle = 0; cycle < count2; cycle += 1) {
        result += string;
      }
      return result;
    }
    exports.repeat = repeat;
    function isNegativeZero(number) {
      return 0 === number && Number.NEGATIVE_INFINITY === 1 / number;
    }
    exports.isNegativeZero = isNegativeZero;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/exception.js
var require_exception = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/exception.js"(exports, module2) {
    "use strict";
    var YAMLException = class _YAMLException {
      constructor(reason, mark = null, isWarning = false) {
        this.name = "YAMLException";
        this.reason = reason;
        this.mark = mark;
        this.message = this.toString(false);
        this.isWarning = isWarning;
      }
      static isInstance(instance) {
        if (instance != null && instance.getClassIdentifier && typeof instance.getClassIdentifier == "function") {
          for (let currentIdentifier of instance.getClassIdentifier()) {
            if (currentIdentifier == _YAMLException.CLASS_IDENTIFIER)
              return true;
          }
        }
        return false;
      }
      getClassIdentifier() {
        var superIdentifiers = [];
        return superIdentifiers.concat(_YAMLException.CLASS_IDENTIFIER);
      }
      toString(compact = false) {
        var result;
        result = "JS-YAML: " + (this.reason || "(unknown reason)");
        if (!compact && this.mark) {
          result += " " + this.mark.toString();
        }
        return result;
      }
    };
    YAMLException.CLASS_IDENTIFIER = "yaml-ast-parser.YAMLException";
    module2.exports = YAMLException;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/mark.js
var require_mark = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/mark.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var Mark = class {
      constructor(name, buffer, position, line, column) {
        this.name = name;
        this.buffer = buffer;
        this.position = position;
        this.line = line;
        this.column = column;
      }
      getSnippet(indent = 0, maxLength = 75) {
        var head, start, tail, end, snippet;
        if (!this.buffer) {
          return null;
        }
        indent = indent || 4;
        maxLength = maxLength || 75;
        head = "";
        start = this.position;
        while (start > 0 && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1))) {
          start -= 1;
          if (this.position - start > maxLength / 2 - 1) {
            head = " ... ";
            start += 5;
            break;
          }
        }
        tail = "";
        end = this.position;
        while (end < this.buffer.length && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end))) {
          end += 1;
          if (end - this.position > maxLength / 2 - 1) {
            tail = " ... ";
            end -= 5;
            break;
          }
        }
        snippet = this.buffer.slice(start, end);
        return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
      }
      toString(compact = true) {
        var snippet, where = "";
        if (this.name) {
          where += 'in "' + this.name + '" ';
        }
        where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
        if (!compact) {
          snippet = this.getSnippet();
          if (snippet) {
            where += ":\n" + snippet;
          }
        }
        return where;
      }
    };
    module2.exports = Mark;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type.js
var require_type = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (null !== map) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    var Type = class {
      constructor(tag, options) {
        options = options || {};
        Object.keys(options).forEach(function(name) {
          if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
          }
        });
        this.tag = tag;
        this.kind = options["kind"] || null;
        this.resolve = options["resolve"] || function() {
          return true;
        };
        this.construct = options["construct"] || function(data) {
          return data;
        };
        this.instanceOf = options["instanceOf"] || null;
        this.predicate = options["predicate"] || null;
        this.represent = options["represent"] || null;
        this.defaultStyle = options["defaultStyle"] || null;
        this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
        if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
          throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
        }
      }
    };
    exports.Type = Type;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema.js
var require_schema = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common();
    var YAMLException = require_exception();
    var type_1 = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index3) {
        return -1 === exclude.indexOf(index3);
      });
    }
    function compileMap() {
      var result = {}, index3, length;
      function collectType(type) {
        result[type.tag] = type;
      }
      for (index3 = 0, length = arguments.length; index3 < length; index3 += 1) {
        arguments[index3].forEach(collectType);
      }
      return result;
    }
    var Schema = class {
      constructor(definition) {
        this.include = definition.include || [];
        this.implicit = definition.implicit || [];
        this.explicit = definition.explicit || [];
        this.implicit.forEach(function(type) {
          if (type.loadKind && "scalar" !== type.loadKind) {
            throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
          }
        });
        this.compiledImplicit = compileList(this, "implicit", []);
        this.compiledExplicit = compileList(this, "explicit", []);
        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
      }
    };
    exports.Schema = Schema;
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types = common.toArray(types);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types.every(function(type) {
        return type instanceof type_1.Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types
      });
    };
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/str.js
var require_str = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/str.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    module2.exports = new type_1.Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return null !== data ? data : "";
      }
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/seq.js
var require_seq = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/seq.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    module2.exports = new type_1.Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return null !== data ? data : [];
      }
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/map.js
var require_map = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/map.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    module2.exports = new type_1.Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return null !== data ? data : {};
      }
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/failsafe.js
var require_failsafe = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/failsafe.js"(exports, module2) {
    "use strict";
    var schema_1 = require_schema();
    module2.exports = new schema_1.Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/null.js
var require_null = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/null.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    function resolveYamlNull(data) {
      if (null === data) {
        return true;
      }
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull2(object) {
      return null === object;
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull2,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/bool.js
var require_bool = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/bool.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    function resolveYamlBoolean(data) {
      if (null === data) {
        return false;
      }
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean2(object) {
      return "[object Boolean]" === Object.prototype.toString.call(object);
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean2,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/int.js
var require_int = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/int.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var type_1 = require_type();
    function isHexCode(c2) {
      return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
    }
    function isOctCode(c2) {
      return 48 <= c2 && c2 <= 55;
    }
    function isDecCode(c2) {
      return 48 <= c2 && c2 <= 57;
    }
    function resolveYamlInteger(data) {
      if (null === data) {
        return false;
      }
      var max = data.length, index3 = 0, hasDigits = false, ch;
      if (!max) {
        return false;
      }
      ch = data[index3];
      if (ch === "-" || ch === "+") {
        ch = data[++index3];
      }
      if (ch === "0") {
        if (index3 + 1 === max) {
          return true;
        }
        ch = data[++index3];
        if (ch === "b") {
          index3++;
          for (; index3 < max; index3++) {
            ch = data[index3];
            if (ch === "_") {
              continue;
            }
            if (ch !== "0" && ch !== "1") {
              return false;
            }
            hasDigits = true;
          }
          return hasDigits;
        }
        if (ch === "x") {
          index3++;
          for (; index3 < max; index3++) {
            ch = data[index3];
            if (ch === "_") {
              continue;
            }
            if (!isHexCode(data.charCodeAt(index3))) {
              return false;
            }
            hasDigits = true;
          }
          return hasDigits;
        }
        for (; index3 < max; index3++) {
          ch = data[index3];
          if (ch === "_") {
            continue;
          }
          if (!isOctCode(data.charCodeAt(index3))) {
            hasDigits = false;
            break;
          }
          hasDigits = true;
        }
        if (hasDigits) {
          return hasDigits;
        }
      }
      for (; index3 < max; index3++) {
        ch = data[index3];
        if (ch === "_") {
          continue;
        }
        if (ch === ":") {
          break;
        }
        if (!isDecCode(data.charCodeAt(index3))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits) {
        return false;
      }
      if (ch !== ":") {
        return true;
      }
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index3));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-") {
          sign = -1;
        }
        value = value.slice(1);
        ch = value[0];
      }
      if ("0" === value) {
        return 0;
      }
      if (ch === "0") {
        if (value[1] === "b") {
          return sign * parseInt(value.slice(2), 2);
        }
        if (value[1] === "x") {
          return sign * parseInt(value, 16);
        }
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v2) {
          digits.unshift(parseInt(v2, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d2) {
          value += d2 * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      const type = Object.prototype.toString.call(object);
      return "[object Number]" === type && (0 === object % 1 && !common.isNegativeZero(object)) || "[object BigInt]" === type;
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(object) {
          return "0b" + object.toString(2);
        },
        octal: function(object) {
          return "0" + object.toString(8);
        },
        decimal: function(object) {
          return object.toString(10);
        },
        hexadecimal: function(object) {
          return "0x" + object.toString(16).toUpperCase();
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/float.js
var require_float = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/float.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var type_1 = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?|\\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (null === data) {
        return false;
      }
      var value, sign, base, digits;
      if (!YAML_FLOAT_PATTERN.test(data)) {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign = "-" === value[0] ? -1 : 1;
      digits = [];
      if (0 <= "+-".indexOf(value[0])) {
        value = value.slice(1);
      }
      if (".inf" === value) {
        return 1 === sign ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (".nan" === value) {
        return NaN;
      } else if (0 <= value.indexOf(":")) {
        value.split(":").forEach(function(v2) {
          digits.unshift(parseFloat(v2, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d2) {
          value += d2 * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    function representYamlFloat(object, style) {
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      return object.toString(10);
    }
    function isFloat(object) {
      return "[object Number]" === Object.prototype.toString.call(object) && (0 !== object % 1 || common.isNegativeZero(object));
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/json.js
var require_json2 = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/json.js"(exports, module2) {
    "use strict";
    var schema_1 = require_schema();
    module2.exports = new schema_1.Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/core.js
var require_core = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/core.js"(exports, module2) {
    "use strict";
    var schema_1 = require_schema();
    module2.exports = new schema_1.Schema({
      include: [
        require_json2()
      ]
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/timestamp.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$");
    function resolveYamlTimestamp(data) {
      if (null === data) {
        return false;
      }
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (null === match) {
        return false;
      }
      return true;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (null === match) {
        throw new Error("Date resolve error");
      }
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction = fraction + "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if ("-" === match[9]) {
          delta = -delta;
        }
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) {
        date.setTime(date.getTime() - delta);
      }
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/merge.js
var require_merge = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/merge.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    function resolveYamlMerge(data) {
      return "<<" === data || null === data;
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/binary.js
var require_binary = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/binary.js"(exports, module2) {
    "use strict";
    var NodeBuffer = require("buffer").Buffer;
    var type_1 = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (null === data) {
        return false;
      }
      var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64) {
          continue;
        }
        if (code < 0) {
          return false;
        }
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var code, idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/omap.js
var require_omap = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/omap.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (null === data) {
        return true;
      }
      var objectKeys = [], index3, length, pair, pairKey, pairHasKey, object = data;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        pair = object[index3];
        pairHasKey = false;
        if ("[object Object]" !== _toString.call(pair)) {
          return false;
        }
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey) {
              pairHasKey = true;
            } else {
              return false;
            }
          }
        }
        if (!pairHasKey) {
          return false;
        }
        if (-1 === objectKeys.indexOf(pairKey)) {
          objectKeys.push(pairKey);
        } else {
          return false;
        }
      }
      return true;
    }
    function constructYamlOmap(data) {
      return null !== data ? data : [];
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/pairs.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    var ast = require_yamlAST();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (null === data) {
        return true;
      }
      if (data.kind != ast.Kind.SEQ) {
        return false;
      }
      var index3, length, pair, keys, result, object = data.items;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        pair = object[index3];
        if ("[object Object]" !== _toString.call(pair)) {
          return false;
        }
        if (!Array.isArray(pair.mappings)) {
          return false;
        }
        if (1 !== pair.mappings.length) {
          return false;
        }
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (null === data || !Array.isArray(data.items)) {
        return [];
      }
      let index3, length, keys, result, object = data.items;
      result = ast.newItems();
      result.parent = data.parent;
      result.startPosition = data.startPosition;
      result.endPosition = data.endPosition;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        let pair = object[index3];
        let mapping = pair.mappings[0];
        let pairSeq = ast.newItems();
        pairSeq.parent = result;
        pairSeq.startPosition = mapping.key.startPosition;
        pairSeq.endPosition = mapping.value.startPosition;
        mapping.key.parent = pairSeq;
        mapping.value.parent = pairSeq;
        pairSeq.items = [mapping.key, mapping.value];
        result.items.push(pairSeq);
      }
      return result;
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/set.js
var require_set = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/set.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    var ast = require_yamlAST();
    function resolveYamlSet(data) {
      if (null === data) {
        return true;
      }
      if (data.kind != ast.Kind.MAP) {
        return false;
      }
      return true;
    }
    function constructYamlSet(data) {
      return null !== data ? data : {};
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/default_safe.js
var require_default_safe = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/default_safe.js"(exports, module2) {
    "use strict";
    var schema_1 = require_schema();
    var schema = new schema_1.Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
    module2.exports = schema;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/js/undefined.js
var require_undefined = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/js/undefined.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined2(object) {
      return "undefined" === typeof object;
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined2,
      represent: representJavascriptUndefined
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/js/regexp.js
var require_regexp = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/type/js/regexp.js"(exports, module2) {
    "use strict";
    var type_1 = require_type();
    function resolveJavascriptRegExp(data) {
      if (null === data) {
        return false;
      }
      if (0 === data.length) {
        return false;
      }
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if ("/" === regexp[0]) {
        if (tail) {
          modifiers = tail[1];
        }
        if (modifiers.length > 3) {
          return false;
        }
        if (regexp[regexp.length - modifiers.length - 1] !== "/") {
          return false;
        }
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      try {
        var dummy = new RegExp(regexp, modifiers);
        return true;
      } catch (error) {
        return false;
      }
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if ("/" === regexp[0]) {
        if (tail) {
          modifiers = tail[1];
        }
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global) {
        result += "g";
      }
      if (object.multiline) {
        result += "m";
      }
      if (object.ignoreCase) {
        result += "i";
      }
      return result;
    }
    function isRegExp(object) {
      return "[object RegExp]" === Object.prototype.toString.call(object);
    }
    module2.exports = new type_1.Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/default_full.js
var require_default_full = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/schema/default_full.js"(exports, module2) {
    "use strict";
    var schema_1 = require_schema();
    var schema = new schema_1.Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp()
      ]
    });
    schema_1.Schema.DEFAULT = schema;
    module2.exports = schema;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/loader.js
var require_loader = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/loader.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ast = require_yamlAST();
    var common = require_common();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function is_EOL(c2) {
      return c2 === 10 || c2 === 13;
    }
    function is_WHITE_SPACE(c2) {
      return c2 === 9 || c2 === 32;
    }
    function is_WS_OR_EOL(c2) {
      return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
    }
    function is_FLOW_INDICATOR(c2) {
      return 44 === c2 || 91 === c2 || 93 === c2 || 123 === c2 || 125 === c2;
    }
    function fromHexCode(c2) {
      var lc;
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      lc = c2 | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c2) {
      if (c2 === 120) {
        return 2;
      }
      if (c2 === 117) {
        return 4;
      }
      if (c2 === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c2) {
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c2) {
      return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c2) {
      if (c2 <= 65535) {
        return String.fromCharCode(c2);
      }
      return String.fromCharCode((c2 - 65536 >> 10) + 55296, (c2 - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    var customEscapeCheck = new Array(256);
    var customEscapeMap = new Array(256);
    for (i3 = 0; i3 < 256; i3++) {
      customEscapeMap[i3] = simpleEscapeMap[i3] = simpleEscapeSequence(i3);
      simpleEscapeCheck[i3] = simpleEscapeMap[i3] ? 1 : 0;
      customEscapeCheck[i3] = 1;
      if (!simpleEscapeCheck[i3]) {
        customEscapeMap[i3] = "\\" + String.fromCharCode(i3);
      }
    }
    var i3;
    var State = class {
      constructor(input, options) {
        this.errorMap = {};
        this.errors = [];
        this.lines = [];
        this.input = input;
        this.filename = options["filename"] || null;
        this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
        this.onWarning = options["onWarning"] || null;
        this.legacy = options["legacy"] || false;
        this.allowAnyEscape = options["allowAnyEscape"] || false;
        this.ignoreDuplicateKeys = options["ignoreDuplicateKeys"] || false;
        this.implicitTypes = this.schema.compiledImplicit;
        this.typeMap = this.schema.compiledTypeMap;
        this.length = input.length;
        this.position = 0;
        this.line = 0;
        this.lineStart = 0;
        this.lineIndent = 0;
        this.documents = [];
      }
    };
    function generateError(state, message, isWarning = false) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart), isWarning);
    }
    function throwErrorFromPosition(state, position, message, isWarning = false, toLineEnd = false) {
      var line = positionToLine(state, position);
      if (!line) {
        return;
      }
      var hash = message + position;
      if (state.errorMap[hash]) {
        return;
      }
      var mark = new Mark(state.filename, state.input, position, line.line, position - line.start);
      if (toLineEnd) {
        mark.toLineEnd = true;
      }
      var error = new YAMLException(message, mark, isWarning);
      state.errors.push(error);
    }
    function throwError(state, message) {
      var error = generateError(state, message);
      var hash = error.message + error.mark.position;
      if (state.errorMap[hash]) {
        return;
      }
      state.errors.push(error);
      state.errorMap[hash] = 1;
      var or = state.position;
      while (true) {
        if (state.position >= state.input.length - 1) {
          return;
        }
        var c2 = state.input.charAt(state.position);
        if (c2 == "\n") {
          state.position--;
          if (state.position == or) {
            state.position += 1;
          }
          return;
        }
        if (c2 == "\r") {
          state.position--;
          if (state.position == or) {
            state.position += 1;
          }
          return;
        }
        state.position++;
      }
    }
    function throwWarning(state, message) {
      var error = generateError(state, message);
      if (state.onWarning) {
        state.onWarning.call(null, error);
      } else {
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (null !== state.version) {
          throwError(state, "duplication of %YAML directive");
        }
        if (1 !== args.length) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (null === match) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (1 !== major) {
          throwError(state, "found incompatible YAML document (version 1.2 is required)");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (2 !== minor) {
          throwError(state, "found incompatible YAML document (version 1.2 is required)");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (2 !== args.length) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      var scalar = state.result;
      if (scalar.startPosition == -1) {
        scalar.startPosition = start;
      }
      if (start <= end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(9 === _character || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        scalar.value += _result;
        scalar.endPosition = end;
      }
    }
    function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
      var index3, quantity;
      if (keyNode == null) {
        return;
      }
      if (null === _result) {
        _result = {
          startPosition: keyNode.startPosition,
          endPosition: valueNode.endPosition,
          parent: null,
          errors: [],
          mappings: [],
          kind: ast.Kind.MAP
        };
      }
      var mapping = ast.newMapping(keyNode, valueNode);
      mapping.parent = _result;
      keyNode.parent = mapping;
      if (valueNode != null) {
        valueNode.parent = mapping;
      }
      !state.ignoreDuplicateKeys && _result.mappings.forEach((sibling) => {
        if (sibling.key && sibling.key.value === (mapping.key && mapping.key.value)) {
          throwErrorFromPosition(state, mapping.key.startPosition, "duplicate key");
          throwErrorFromPosition(state, sibling.key.startPosition, "duplicate key");
        }
      });
      _result.mappings.push(mapping);
      _result.endPosition = valueNode ? valueNode.endPosition : keyNode.endPosition + 1;
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (10 === ch) {
        state.position++;
      } else if (13 === ch) {
        state.position++;
        if (10 === state.input.charCodeAt(state.position)) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.lines.push({
        start: state.lineStart,
        line: state.line
      });
    }
    function positionToLine(state, position) {
      var line;
      for (var i4 = 0; i4 < state.lines.length; i4++) {
        if (state.lines[i4].start > position) {
          break;
        }
        line = state.lines[i4];
      }
      if (!line) {
        return {
          start: 0,
          line: 0
        };
      }
      return line;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (0 !== ch) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9) {
            state.errors.push(generateError(state, "Using tabs can lead to unpredictable results", true));
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && 35 === ch) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && 0 !== ch);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (32 === ch) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((45 === ch || 46 === ch) && state.input.charCodeAt(_position + 1) === ch && state.input.charCodeAt(_position + 2) === ch) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, scalar, count2) {
      if (1 === count2) {
        scalar.value += " ";
      } else if (count2 > 1) {
        scalar.value += common.repeat("\n", count2 - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      var state_result = ast.newScalar();
      state_result.plainScalar = true;
      state.result = state_result;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || 35 === ch || 38 === ch || 42 === ch || 33 === ch || 124 === ch || 62 === ch || 39 === ch || 34 === ch || 37 === ch || 64 === ch || 96 === ch) {
        return false;
      }
      if (63 === ch || 45 === ch) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (0 !== ch) {
        if (58 === ch) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (35 === ch) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state_result, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
        if (state.position >= state.input.length) {
          return false;
        }
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result.startPosition != -1) {
        state_result.rawValue = state.input.substring(state_result.startPosition, state_result.endPosition);
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (39 !== ch) {
        return false;
      }
      var scalar = ast.newScalar();
      scalar.singleQuoted = true;
      state.kind = "scalar";
      state.result = scalar;
      scalar.startPosition = state.position;
      state.position++;
      captureStart = captureEnd = state.position;
      while (0 !== (ch = state.input.charCodeAt(state.position))) {
        if (39 === ch) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          scalar.endPosition = state.position;
          if (39 === ch) {
            captureStart = captureEnd = state.position;
            state.position++;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
          scalar.endPosition = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, tmpEsc, ch;
      ch = state.input.charCodeAt(state.position);
      if (34 !== ch) {
        return false;
      }
      state.kind = "scalar";
      var scalar = ast.newScalar();
      scalar.doubleQuoted = true;
      state.result = scalar;
      scalar.startPosition = state.position;
      state.position++;
      captureStart = captureEnd = state.position;
      while (0 !== (ch = state.input.charCodeAt(state.position))) {
        if (34 === ch) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          scalar.endPosition = state.position;
          scalar.rawValue = state.input.substring(scalar.startPosition, scalar.endPosition);
          return true;
        } else if (92 === ch) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && (state.allowAnyEscape ? customEscapeCheck[ch] : simpleEscapeCheck[ch])) {
            scalar.value += state.allowAnyEscape ? customEscapeMap[ch] : simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            scalar.value += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = ast.newItems();
        _result.startPosition = state.position;
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = ast.newMap();
        _result.startPosition = state.position;
      } else {
        return false;
      }
      if (null !== state.anchor) {
        _result.anchorId = state.anchor;
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (0 !== ch) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          _result.endPosition = state.position;
          return true;
        } else if (!readNext) {
          var p2 = state.position;
          throwError(state, "missed comma between flow collection entries");
          state.position = p2 + 1;
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (63 === ch) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && 58 === ch) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        } else if (isPair) {
          var mp = storeMappingPair(state, null, keyTag, keyNode, valueNode);
          mp.parent = _result;
          _result.items.push(mp);
        } else {
          if (keyNode) {
            keyNode.parent = _result;
          }
          _result.items.push(keyNode);
        }
        _result.endPosition = state.position + 1;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (44 === ch) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      var sc = ast.newScalar();
      state.kind = "scalar";
      state.result = sc;
      sc.startPosition = state.position;
      while (0 !== ch) {
        ch = state.input.charCodeAt(++state.position);
        if (43 === ch || 45 === ch) {
          if (CHOMPING_CLIP === chomping) {
            chomping = 43 === ch ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (35 === ch) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && 0 !== ch);
        }
      }
      while (0 !== ch) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && 32 === ch) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            sc.value += common.repeat("\n", emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (detectedIndent) {
              sc.value += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            sc.value += common.repeat("\n", emptyLines + 1);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            sc.value += common.repeat("\n", emptyLines + 1);
          } else if (0 === emptyLines) {
            if (detectedIndent) {
              sc.value += " ";
            }
          } else {
            sc.value += common.repeat("\n", emptyLines);
          }
        } else if (detectedIndent) {
          sc.value += common.repeat("\n", emptyLines + 1);
        } else {
        }
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && 0 !== ch) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      sc.endPosition = state.position;
      var i4 = state.position - 1;
      var needMinus = false;
      while (true) {
        var c2 = state.input[i4];
        if (c2 == "\r" || c2 == "\n") {
          if (needMinus) {
            i4--;
          }
          break;
        }
        if (c2 != " " && c2 != "	") {
          break;
        }
        i4--;
      }
      sc.endPosition = i4;
      sc.rawValue = state.input.substring(sc.startPosition, sc.endPosition);
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newItems(), following, detected = false, ch;
      if (null !== state.anchor) {
        _result.anchorId = state.anchor;
        state.anchorMap[state.anchor] = _result;
      }
      _result.startPosition = state.position;
      ch = state.input.charCodeAt(state.position);
      while (0 !== ch) {
        if (45 !== ch) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.items.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        if (state.result) {
          state.result.parent = _result;
          _result.items.push(state.result);
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && 0 !== ch) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      _result.endPosition = state.position;
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        _result.endPosition = state.position;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newMap(), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      _result.startPosition = state.position;
      if (null !== state.anchor) {
        _result.anchorId = state.anchor;
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (0 !== ch) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((63 === ch || 58 === ch) && is_WS_OR_EOL(following)) {
          if (63 === ch) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (58 === ch) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (state.position == state.lineStart && testDocumentSeparator(state)) {
              break;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            while (state.position > 0) {
              ch = state.input.charCodeAt(--state.position);
              if (is_EOL(ch)) {
                state.position++;
                break;
              }
            }
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, valueNode);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && 0 !== ch) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (33 !== ch) {
        return false;
      }
      if (null !== state.tag) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (60 === ch) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (33 === ch) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (0 !== ch && 62 !== ch);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (0 !== ch && !is_WS_OR_EOL(ch)) {
          if (33 === ch) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if ("!" === tagHandle) {
        state.tag = "!" + tagName;
      } else if ("!!" === tagHandle) {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (38 !== ch) {
        return false;
      }
      if (null !== state.anchor) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, len = state.length, input = state.input, ch;
      ch = state.input.charCodeAt(state.position);
      if (42 !== ch) {
        return false;
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position <= _position) {
        throwError(state, "name of an alias node must contain at least one character");
        state.position = _position + 1;
      }
      alias = state.input.slice(_position, state.position);
      if (!state.anchorMap.hasOwnProperty(alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
        if (state.position <= _position) {
          state.position = _position + 1;
        }
      }
      state.result = ast.newAnchorRef(alias, _position, state.position, state.anchorMap[alias]);
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent, _result;
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      let tagStart = state.position;
      let tagColumn = state.position - state.lineStart;
      if (1 === indentStatus) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (1 === indentStatus) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (null !== state.tag || null !== state.anchor) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (null === state.tag) {
                state.tag = "?";
              }
            }
            if (null !== state.anchor) {
              state.anchorMap[state.anchor] = state.result;
              state.result.anchorId = state.anchor;
            }
          }
        } else if (0 === indentStatus) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (null !== state.tag && "!" !== state.tag) {
        if (state.tag == "!include") {
          if (!state.result) {
            state.result = ast.newScalar();
            state.result.startPosition = state.position;
            state.result.endPosition = state.position;
            throwError(state, "!include without value");
          }
          state.result.kind = ast.Kind.INCLUDE_REF;
        } else if ("?" === state.tag) {
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            var vl = state.result["value"];
            if (type.resolve(vl)) {
              state.result.valueObject = type.construct(state.result["value"]);
              state.tag = type.tag;
              if (null !== state.anchor) {
                state.result.anchorId = state.anchor;
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
          type = state.typeMap[state.tag];
          if (null !== state.result && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (null !== state.anchor) {
              state.result.anchorId = state.anchor;
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwErrorFromPosition(state, tagStart, "unknown tag <" + state.tag + ">", false, true);
        }
      }
      return null !== state.tag || null !== state.anchor || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while (0 !== (ch = state.input.charCodeAt(state.position))) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || 37 !== ch) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (0 !== ch && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (0 !== ch) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (35 === ch) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (0 !== ch && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch)) {
            break;
          }
          _position = state.position;
          while (0 !== ch && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (0 !== ch) {
          readLineBreak(state);
        }
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
          state.position++;
        }
      }
      skipSeparationSpace(state, true, -1);
      if (0 === state.lineIndent && 45 === state.input.charCodeAt(state.position) && 45 === state.input.charCodeAt(state.position + 1) && 45 === state.input.charCodeAt(state.position + 2)) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (46 === state.input.charCodeAt(state.position)) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      let inputLength = input.length;
      if (inputLength !== 0) {
        if (10 !== input.charCodeAt(inputLength - 1) && 13 !== input.charCodeAt(inputLength - 1)) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      state.input += "\0";
      while (32 === state.input.charCodeAt(state.position)) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        var q2 = state.position;
        readDocument(state);
        if (state.position <= q2) {
          for (; state.position < state.length - 1; state.position++) {
            var c2 = state.input.charAt(state.position);
            if (c2 == "\n") {
              break;
            }
          }
        }
      }
      let documents = state.documents;
      let docsCount = documents.length;
      if (docsCount > 0) {
        documents[docsCount - 1].endPosition = inputLength;
      }
      for (let x3 of documents) {
        x3.errors = state.errors;
        if (x3.startPosition > x3.endPosition) {
          x3.startPosition = x3.endPosition;
        }
      }
      return documents;
    }
    function loadAll(input, iterator, options = {}) {
      var documents = loadDocuments(input, options), index3, length;
      for (index3 = 0, length = documents.length; index3 < length; index3 += 1) {
        iterator(documents[index3]);
      }
    }
    exports.loadAll = loadAll;
    function load(input, options = {}) {
      var documents = loadDocuments(input, options), index3, length;
      if (0 === documents.length) {
        return void 0;
      } else if (1 === documents.length) {
        return documents[0];
      }
      var e3 = new YAMLException("expected a single document in the stream, but found more");
      e3.mark = new Mark("", "", 0, 0, 0);
      e3.mark.position = documents[0].endPosition;
      documents[0].errors.push(e3);
      return documents[0];
    }
    exports.load = load;
    function safeLoadAll(input, output, options = {}) {
      loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    exports.safeLoadAll = safeLoadAll;
    function safeLoad(input, options = {}) {
      return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    exports.safeLoad = safeLoad;
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/dumper.js
var require_dumper = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/dumper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index3, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index3 = 0, length = keys.length; index3 < length; index3 += 1) {
        tag = keys[index3];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options) {
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index3, length, type;
      for (index3 = 0, length = state.implicitTypes.length; index3 < length; index3 += 1) {
        type = state.implicitTypes[index3];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c2) {
      return c2 === CHAR_SPACE || c2 === CHAR_TAB;
    }
    function isPrintable(c2) {
      return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
    }
    function isNsChar(c2) {
      return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c2, prev) {
      return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c2) {
      return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i3;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i3 = 0; i3 < string.length; i3++) {
          char = string.charCodeAt(i3);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i3 > 0 ? string.charCodeAt(i3 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i3 = 0; i3 < string.length; i3++) {
          char = string.charCodeAt(i3);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i3 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i3;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i3 > 0 ? string.charCodeAt(i3 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i3 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i3 = 0; i3 < string.length; i3++) {
        char = string.charCodeAt(i3);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i3 + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i3++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i3] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index3, length;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        if (writeNode(state, level, object[index3], false, false)) {
          if (index3 !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index3, length;
      for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
        if (writeNode(state, level + 1, object[index3], true, true)) {
          if (!compact || index3 !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index3, length, objectKey, objectValue, pairBuffer;
      for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
        pairBuffer = "";
        if (index3 !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index3];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index3, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
        pairBuffer = "";
        if (!compact || index3 !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index3];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index3, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index3 = 0, length = typeList.length; index3 < length; index3 += 1) {
        type = typeList[index3];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index3, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index3 = 0, length = duplicatesIndexes.length; index3 < length; index3 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index3]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index3, length;
      if (object !== null && typeof object === "object") {
        index3 = objects.indexOf(object);
        if (index3 !== -1) {
          if (duplicatesIndexes.indexOf(index3) === -1) {
            duplicatesIndexes.push(index3);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index3 = 0, length = object.length; index3 < length; index3 += 1) {
              inspectNode(object[index3], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index3 = 0, length = objectKeyList.length; index3 < length; index3 += 1) {
              inspectNode(object[objectKeyList[index3]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!options.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true)) {
        return state.dump + "\n";
      }
      return "";
    }
    exports.dump = dump;
    function safeDump(input, options) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    exports.safeDump = safeDump;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/scalarInference.js
var require_scalarInference = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/scalarInference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function parseYamlBoolean(input) {
      if (["true", "True", "TRUE"].lastIndexOf(input) >= 0) {
        return true;
      } else if (["false", "False", "FALSE"].lastIndexOf(input) >= 0) {
        return false;
      }
      throw `Invalid boolean "${input}"`;
    }
    exports.parseYamlBoolean = parseYamlBoolean;
    function safeParseYamlInteger(input) {
      if (input.lastIndexOf("0o", 0) === 0) {
        return parseInt(input.substring(2), 8);
      }
      return parseInt(input);
    }
    function parseYamlInteger(input) {
      const result = safeParseYamlInteger(input);
      if (Number.isNaN(result)) {
        throw `Invalid integer "${input}"`;
      }
      return result;
    }
    exports.parseYamlInteger = parseYamlInteger;
    function parseYamlBigInteger(input) {
      const result = parseYamlInteger(input);
      if (result > Number.MAX_SAFE_INTEGER && input.lastIndexOf("0o", 0) === -1) {
        return BigInt(input);
      }
      return result;
    }
    exports.parseYamlBigInteger = parseYamlBigInteger;
    function parseYamlFloat(input) {
      if ([".nan", ".NaN", ".NAN"].lastIndexOf(input) >= 0) {
        return NaN;
      }
      const infinity = /^([-+])?(?:\.inf|\.Inf|\.INF)$/;
      const match = infinity.exec(input);
      if (match) {
        return match[1] === "-" ? -Infinity : Infinity;
      }
      const result = parseFloat(input);
      if (!isNaN(result)) {
        return result;
      }
      throw `Invalid float "${input}"`;
    }
    exports.parseYamlFloat = parseYamlFloat;
    var ScalarType;
    (function(ScalarType2) {
      ScalarType2[ScalarType2["null"] = 0] = "null";
      ScalarType2[ScalarType2["bool"] = 1] = "bool";
      ScalarType2[ScalarType2["int"] = 2] = "int";
      ScalarType2[ScalarType2["float"] = 3] = "float";
      ScalarType2[ScalarType2["string"] = 4] = "string";
    })(ScalarType = exports.ScalarType || (exports.ScalarType = {}));
    function determineScalarType(node) {
      if (node === void 0) {
        return ScalarType.null;
      }
      if (node.doubleQuoted || !node.plainScalar || node["singleQuoted"]) {
        return ScalarType.string;
      }
      const value = node.value;
      if (["null", "Null", "NULL", "~", ""].indexOf(value) >= 0) {
        return ScalarType.null;
      }
      if (value === null || value === void 0) {
        return ScalarType.null;
      }
      if (["true", "True", "TRUE", "false", "False", "FALSE"].indexOf(value) >= 0) {
        return ScalarType.bool;
      }
      const base10 = /^[-+]?[0-9]+$/;
      const base8 = /^0o[0-7]+$/;
      const base16 = /^0x[0-9a-fA-F]+$/;
      if (base10.test(value) || base8.test(value) || base16.test(value)) {
        return ScalarType.int;
      }
      const float = /^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$/;
      const infinity = /^[-+]?(\.inf|\.Inf|\.INF)$/;
      if (float.test(value) || infinity.test(value) || [".nan", ".NaN", ".NAN"].indexOf(value) >= 0) {
        return ScalarType.float;
      }
      return ScalarType.string;
    }
    exports.determineScalarType = determineScalarType;
  }
});

// ../../node_modules/@stoplight/yaml-ast-parser/dist/src/index.js
var require_src = __commonJS({
  "../../node_modules/@stoplight/yaml-ast-parser/dist/src/index.js"(exports) {
    "use strict";
    function __export2(m2) {
      for (var p2 in m2)
        if (!exports.hasOwnProperty(p2))
          exports[p2] = m2[p2];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var loader_1 = require_loader();
    exports.load = loader_1.load;
    exports.loadAll = loader_1.loadAll;
    exports.safeLoad = loader_1.safeLoad;
    exports.safeLoadAll = loader_1.safeLoadAll;
    var dumper_1 = require_dumper();
    exports.dump = dumper_1.dump;
    exports.safeDump = dumper_1.safeDump;
    exports.YAMLException = require_exception();
    __export2(require_yamlAST());
    __export2(require_scalarInference());
  }
});

// ../../node_modules/@stoplight/yaml/types.js
var require_types = __commonJS({
  "../../node_modules/@stoplight/yaml/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var yaml_ast_parser_1 = require_src();
    exports.Kind = yaml_ast_parser_1.Kind;
    exports.ScalarType = yaml_ast_parser_1.ScalarType;
  }
});

// ../../node_modules/@stoplight/yaml/utils.js
var require_utils = __commonJS({
  "../../node_modules/@stoplight/yaml/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObject = (sth) => sth !== null && typeof sth === "object";
  }
});

// ../../node_modules/@stoplight/yaml/buildJsonPath.js
var require_buildJsonPath = __commonJS({
  "../../node_modules/@stoplight/yaml/buildJsonPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var utils_1 = require_utils();
    function buildJsonPath(node) {
      const path2 = [];
      let prevNode = node;
      while (node) {
        switch (node.kind) {
          case types_1.Kind.SCALAR:
            path2.unshift(node.value);
            break;
          case types_1.Kind.MAPPING:
            if (prevNode !== node.key) {
              if (path2.length > 0 && utils_1.isObject(node.value) && node.value.value === path2[0]) {
                path2[0] = node.key.value;
              } else {
                path2.unshift(node.key.value);
              }
            }
            break;
          case types_1.Kind.SEQ:
            if (prevNode) {
              const index3 = node.items.indexOf(prevNode);
              if (prevNode.kind === types_1.Kind.SCALAR) {
                path2[0] = index3;
              } else if (index3 !== -1) {
                path2.unshift(index3);
              }
            }
            break;
        }
        prevNode = node;
        node = node.parent;
      }
      return path2;
    }
    exports.buildJsonPath = buildJsonPath;
  }
});

// ../../node_modules/@stoplight/yaml/dereferenceAnchor.js
var require_dereferenceAnchor = __commonJS({
  "../../node_modules/@stoplight/yaml/dereferenceAnchor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var utils_1 = require_utils();
    exports.dereferenceAnchor = (node, anchorId) => {
      if (!utils_1.isObject(node))
        return node;
      if (node.kind === types_1.Kind.ANCHOR_REF && node.referencesAnchor === anchorId)
        return null;
      switch (node.kind) {
        case types_1.Kind.MAP:
          return Object.assign({}, node, { mappings: node.mappings.map((mapping) => exports.dereferenceAnchor(mapping, anchorId)) });
        case types_1.Kind.SEQ:
          return Object.assign({}, node, { items: node.items.map((item) => exports.dereferenceAnchor(item, anchorId)) });
        case types_1.Kind.MAPPING:
          return Object.assign({}, node, { value: exports.dereferenceAnchor(node.value, anchorId) });
        case types_1.Kind.SCALAR:
          return node;
        case types_1.Kind.ANCHOR_REF:
          if (utils_1.isObject(node.value) && isSelfReferencingAnchorRef(node)) {
            return null;
          }
          return node;
        default:
          return node;
      }
    };
    var isSelfReferencingAnchorRef = (anchorRef) => {
      const { referencesAnchor } = anchorRef;
      let node = anchorRef;
      while (node = node.parent) {
        if ("anchorId" in node && node.anchorId === referencesAnchor) {
          return true;
        }
      }
      return false;
    };
  }
});

// ../../node_modules/@stoplight/yaml/getJsonPathForPosition.js
var require_getJsonPathForPosition = __commonJS({
  "../../node_modules/@stoplight/yaml/getJsonPathForPosition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buildJsonPath_1 = require_buildJsonPath();
    var types_1 = require_types();
    var utils_1 = require_utils();
    exports.getJsonPathForPosition = ({ ast, lineMap }, { line, character }) => {
      if (line >= lineMap.length || character >= lineMap[line]) {
        return;
      }
      const startOffset = line === 0 ? 0 : lineMap[line - 1] + 1;
      const node = findClosestScalar(ast, Math.min(lineMap[line] - 1, startOffset + character), line, lineMap);
      if (!utils_1.isObject(node))
        return;
      const path2 = buildJsonPath_1.buildJsonPath(node);
      if (path2.length === 0)
        return;
      return path2;
    };
    function* walk(node) {
      switch (node.kind) {
        case types_1.Kind.MAP:
          if (node.mappings.length !== 0) {
            for (const mapping of node.mappings) {
              if (utils_1.isObject(mapping)) {
                yield mapping;
              }
            }
          }
          break;
        case types_1.Kind.MAPPING:
          if (utils_1.isObject(node.key)) {
            yield node.key;
          }
          if (utils_1.isObject(node.value)) {
            yield node.value;
          }
          break;
        case types_1.Kind.SEQ:
          if (node.items.length !== 0) {
            for (const item of node.items) {
              if (utils_1.isObject(item)) {
                yield item;
              }
            }
          }
          break;
        case types_1.Kind.SCALAR:
          yield node;
          break;
      }
    }
    function getFirstScalarChild(node, line, lineMap) {
      const startOffset = lineMap[line - 1] + 1;
      const endOffset = lineMap[line];
      switch (node.kind) {
        case types_1.Kind.MAPPING:
          return node.key;
        case types_1.Kind.MAP:
          if (node.mappings.length !== 0) {
            for (const mapping of node.mappings) {
              if (mapping.startPosition > startOffset && mapping.startPosition <= endOffset) {
                return getFirstScalarChild(mapping, line, lineMap);
              }
            }
          }
          break;
        case types_1.Kind.SEQ:
          if (node.items.length !== 0) {
            for (const item of node.items) {
              if (item !== null && item.startPosition > startOffset && item.startPosition <= endOffset) {
                return getFirstScalarChild(item, line, lineMap);
              }
            }
          }
          break;
      }
      return node;
    }
    function findClosestScalar(container, offset, line, lineMap) {
      for (const node of walk(container)) {
        if (node.startPosition <= offset && offset <= node.endPosition) {
          return node.kind === types_1.Kind.SCALAR ? node : findClosestScalar(node, offset, line, lineMap);
        }
      }
      if (lineMap[line - 1] === lineMap[line] - 1) {
        return container;
      }
      if (container.startPosition < lineMap[line - 1] && offset <= container.endPosition) {
        if (container.kind !== types_1.Kind.MAPPING) {
          return getFirstScalarChild(container, line, lineMap);
        }
        if (container.value && container.key.endPosition < offset) {
          return getFirstScalarChild(container.value, line, lineMap);
        }
      }
      return container;
    }
  }
});

// ../../node_modules/@stoplight/yaml/lineForPosition.js
var require_lineForPosition = __commonJS({
  "../../node_modules/@stoplight/yaml/lineForPosition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lineForPosition = (pos, lines, start = 0, end) => {
      if (pos === 0 || lines.length === 0 || pos < lines[0]) {
        return 0;
      }
      if (typeof end === "undefined") {
        end = lines.length;
      }
      const target = Math.floor((end - start) / 2) + start;
      if (pos >= lines[target] && !lines[target + 1]) {
        return target + 1;
      }
      const nextLinePos = lines[Math.min(target + 1, lines.length)];
      if (pos === lines[target] - 1) {
        return target;
      }
      if (pos >= lines[target] && pos <= nextLinePos) {
        if (pos === nextLinePos) {
          return target + 2;
        }
        return target + 1;
      }
      if (pos > lines[target]) {
        return exports.lineForPosition(pos, lines, target + 1, end);
      } else {
        return exports.lineForPosition(pos, lines, start, target - 1);
      }
    };
  }
});

// ../../node_modules/@stoplight/yaml/getLocationForJsonPath.js
var require_getLocationForJsonPath = __commonJS({
  "../../node_modules/@stoplight/yaml/getLocationForJsonPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lineForPosition_1 = require_lineForPosition();
    var types_1 = require_types();
    var utils_1 = require_utils();
    exports.getLocationForJsonPath = ({ ast, lineMap, metadata }, path2, closest = false) => {
      const node = findNodeAtPath(ast, path2, { closest, mergeKeys: metadata !== void 0 && metadata.mergeKeys === true });
      if (node === void 0)
        return;
      return getLoc(lineMap, {
        start: getStartPosition(node, lineMap.length > 0 ? lineMap[0] : 0),
        end: getEndPosition(node)
      });
    };
    function getStartPosition(node, offset) {
      if (node.parent && node.parent.kind === types_1.Kind.MAPPING) {
        if (node.parent.value === null) {
          return node.parent.endPosition;
        }
        if (node.kind !== types_1.Kind.SCALAR) {
          return node.parent.key.endPosition + 1;
        }
      }
      if (node.parent === null && offset - node.startPosition === 0) {
        return 0;
      }
      return node.startPosition;
    }
    function getEndPosition(node) {
      switch (node.kind) {
        case types_1.Kind.SEQ:
          const { items } = node;
          if (items.length !== 0) {
            const lastItem = items[items.length - 1];
            if (lastItem !== null) {
              return getEndPosition(lastItem);
            }
          }
          break;
        case types_1.Kind.MAPPING:
          if (node.value !== null) {
            return getEndPosition(node.value);
          }
          break;
        case types_1.Kind.MAP:
          if (node.value !== null && node.mappings.length !== 0) {
            return getEndPosition(node.mappings[node.mappings.length - 1]);
          }
          break;
        case types_1.Kind.SCALAR:
          if (node.parent !== null && node.parent.kind === types_1.Kind.MAPPING && node.parent.value === null) {
            return node.parent.endPosition;
          }
          break;
      }
      return node.endPosition;
    }
    function findNodeAtPath(node, path2, { closest, mergeKeys }) {
      pathLoop:
        for (const segment of path2) {
          if (!utils_1.isObject(node)) {
            return closest ? node : void 0;
          }
          switch (node.kind) {
            case types_1.Kind.MAP:
              const mappings = getMappings(node.mappings, mergeKeys);
              for (let i3 = mappings.length - 1; i3 >= 0; i3--) {
                const item = mappings[i3];
                if (item.key.value === segment) {
                  if (item.value === null) {
                    node = item.key;
                  } else {
                    node = item.value;
                  }
                  continue pathLoop;
                }
              }
              return closest ? node : void 0;
            case types_1.Kind.SEQ:
              for (let i3 = 0; i3 < node.items.length; i3++) {
                if (i3 === Number(segment)) {
                  const item = node.items[i3];
                  if (item === null) {
                    break;
                  }
                  node = item;
                  continue pathLoop;
                }
              }
              return closest ? node : void 0;
            default:
              return closest ? node : void 0;
          }
        }
      return node;
    }
    function getMappings(mappings, mergeKeys) {
      if (!mergeKeys)
        return mappings;
      return mappings.reduce((mergedMappings, mapping) => {
        if (utils_1.isObject(mapping)) {
          if (mapping.key.value === "<<") {
            mergedMappings.push(...reduceMergeKeys(mapping.value));
          } else {
            mergedMappings.push(mapping);
          }
        }
        return mergedMappings;
      }, []);
    }
    function reduceMergeKeys(node) {
      if (!utils_1.isObject(node))
        return [];
      switch (node.kind) {
        case types_1.Kind.SEQ:
          return node.items.reduceRight((items, item) => {
            items.push(...reduceMergeKeys(item));
            return items;
          }, []);
        case types_1.Kind.MAP:
          return node.mappings;
        case types_1.Kind.ANCHOR_REF:
          return reduceMergeKeys(node.value);
        default:
          return [];
      }
    }
    var getLoc = (lineMap, { start = 0, end = 0 }) => {
      const startLine = lineForPosition_1.lineForPosition(start, lineMap);
      const endLine = lineForPosition_1.lineForPosition(end, lineMap);
      return {
        range: {
          start: {
            line: startLine,
            character: start - (startLine === 0 ? 0 : lineMap[startLine - 1])
          },
          end: {
            line: endLine,
            character: end - (endLine === 0 ? 0 : lineMap[endLine - 1])
          }
        }
      };
    };
  }
});

// ../../node_modules/@stoplight/ordered-object-literal/src/index.cjs
var require_src2 = __commonJS({
  "../../node_modules/@stoplight/ordered-object-literal/src/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TIMESTAMP2 = Math.floor(Date.now() / 36e5);
    var ORDER_KEY_ID2 = `__object_order_${TIMESTAMP2}__`;
    var ORDER_KEY2 = Symbol.for(ORDER_KEY_ID2);
    var STRINGIFIED_ORDER_KEY2 = String(ORDER_KEY2);
    var traps2 = {
      defineProperty(target, key, descriptor) {
        if (!(key in target) && ORDER_KEY2 in target) {
          target[ORDER_KEY2].push(key);
        } else if ("value" in descriptor && key === ORDER_KEY2 && descriptor.value.lastIndexOf(ORDER_KEY2) === -1) {
          descriptor.value.push(ORDER_KEY2);
        }
        return Reflect.defineProperty(target, key, descriptor);
      },
      deleteProperty(target, key) {
        const hasKey = key in target;
        const deleted = Reflect.deleteProperty(target, key);
        if (deleted && hasKey && ORDER_KEY2 in target) {
          const index3 = target[ORDER_KEY2].indexOf(key);
          if (index3 !== -1) {
            target[ORDER_KEY2].splice(index3, 1);
          }
        }
        return deleted;
      },
      ownKeys(target) {
        if (ORDER_KEY2 in target) {
          return target[ORDER_KEY2];
        }
        return Reflect.ownKeys(target);
      },
      set(target, key, value) {
        const hasKey = key in target;
        const set = Reflect.set(target, key, value);
        if (set && !hasKey && ORDER_KEY2 in target) {
          target[ORDER_KEY2].push(key);
        }
        return set;
      }
    };
    function createObj2(target, order = Reflect.ownKeys(target)) {
      assertObjectLiteral2(target);
      const t3 = new Proxy(target, traps2);
      setOrder2(t3, order);
      return t3;
    }
    function setOrder2(target, order) {
      if (ORDER_KEY2 in target) {
        target[ORDER_KEY2].length = 0;
        target[ORDER_KEY2].push(...order);
        return true;
      } else {
        return Reflect.defineProperty(target, ORDER_KEY2, {
          configurable: true,
          value: order
        });
      }
    }
    function getOrder2(target) {
      return target[ORDER_KEY2];
    }
    function serializeArray(target) {
      const newTarget = target.slice();
      for (let i3 = 0; i3 < newTarget.length; i3 += 1) {
        const value = newTarget[i3];
        if (isObject4(value)) {
          newTarget[i3] = Array.isArray(value) ? serializeArray(value) : serialize(value, true);
        }
      }
      return newTarget;
    }
    function serialize(target, deep) {
      assertObjectLiteral2(target, "Invalid target provided");
      const newTarget = { ...target };
      if (ORDER_KEY2 in target) {
        Object.defineProperty(newTarget, STRINGIFIED_ORDER_KEY2, {
          enumerable: true,
          value: target[ORDER_KEY2].filter((item) => item !== ORDER_KEY2)
        });
      }
      if (deep) {
        for (const key of Object.keys(target)) {
          if (key === STRINGIFIED_ORDER_KEY2)
            continue;
          const value = target[key];
          if (isObject4(value)) {
            newTarget[key] = Array.isArray(value) ? serializeArray(value) : serialize(value, true);
          }
        }
      }
      return newTarget;
    }
    function deserializeArray(target) {
      for (let i3 = 0; i3 < target.length; i3 += 1) {
        const value = target[i3];
        if (isObject4(value)) {
          target[i3] = Array.isArray(value) ? deserializeArray(value) : deserialize(value, true);
        }
      }
      return target;
    }
    function deserialize(target, deep) {
      assertObjectLiteral2(target, "Invalid target provided");
      const newTarget = createObj2(
        target,
        STRINGIFIED_ORDER_KEY2 in target ? target[STRINGIFIED_ORDER_KEY2] : Reflect.ownKeys(target)
      );
      delete newTarget[STRINGIFIED_ORDER_KEY2];
      if (deep) {
        for (const key of Object.keys(target)) {
          const value = target[key];
          if (isObject4(value)) {
            target[key] = Array.isArray(value) ? deserializeArray(value) : deserialize(value, true);
          }
        }
      }
      return newTarget;
    }
    function isOrderedObject(target) {
      return ORDER_KEY2 in target;
    }
    function isObject4(maybeObj) {
      return maybeObj !== null && typeof maybeObj === "object";
    }
    function isObjectLiteral2(obj) {
      if (!isObject4(obj))
        return false;
      if (obj[Symbol.toStringTag] !== void 0) {
        const proto = Object.getPrototypeOf(obj);
        return proto === null || proto === Object.prototype;
      }
      return toStringTag2(obj) === "Object";
    }
    function toStringTag2(obj) {
      const tag = obj[Symbol.toStringTag];
      if (typeof tag === "string") {
        return tag;
      }
      const name = Reflect.apply(Object.prototype.toString, obj, []);
      return name.slice(8, name.length - 1);
    }
    function assertObjectLiteral2(maybeObj, message) {
      if (isDevEnv2() && !isObjectLiteral2(maybeObj)) {
        throw new TypeError(message);
      }
    }
    function isDevEnv2() {
      if (typeof process === "undefined" || !isObject4(process) || !isObject4(process.env)) {
        return false;
      }
      return process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test";
    }
    exports.ORDER_KEY_ID = ORDER_KEY_ID2;
    exports.default = createObj2;
    exports.deserialize = deserialize;
    exports.getOrder = getOrder2;
    exports.isOrderedObject = isOrderedObject;
    exports.serialize = serialize;
    exports.setOrder = setOrder2;
  }
});

// ../../node_modules/@stoplight/types/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@stoplight/types/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpOperationSecurityDeclarationTypes = void 0;
    (function(HttpOperationSecurityDeclarationTypes2) {
      HttpOperationSecurityDeclarationTypes2["None"] = "none";
      HttpOperationSecurityDeclarationTypes2["Declared"] = "declared";
      HttpOperationSecurityDeclarationTypes2["InheritedFromService"] = "inheritedFromService";
    })(exports.HttpOperationSecurityDeclarationTypes || (exports.HttpOperationSecurityDeclarationTypes = {}));
    exports.HttpParamStyles = void 0;
    (function(HttpParamStyles2) {
      HttpParamStyles2["Unspecified"] = "unspecified";
      HttpParamStyles2["Simple"] = "simple";
      HttpParamStyles2["Matrix"] = "matrix";
      HttpParamStyles2["Label"] = "label";
      HttpParamStyles2["Form"] = "form";
      HttpParamStyles2["CommaDelimited"] = "commaDelimited";
      HttpParamStyles2["SpaceDelimited"] = "spaceDelimited";
      HttpParamStyles2["PipeDelimited"] = "pipeDelimited";
      HttpParamStyles2["DeepObject"] = "deepObject";
      HttpParamStyles2["TabDelimited"] = "tabDelimited";
    })(exports.HttpParamStyles || (exports.HttpParamStyles = {}));
    exports.DiagnosticSeverity = void 0;
    (function(DiagnosticSeverity2) {
      DiagnosticSeverity2[DiagnosticSeverity2["Error"] = 0] = "Error";
      DiagnosticSeverity2[DiagnosticSeverity2["Warning"] = 1] = "Warning";
      DiagnosticSeverity2[DiagnosticSeverity2["Information"] = 2] = "Information";
      DiagnosticSeverity2[DiagnosticSeverity2["Hint"] = 3] = "Hint";
    })(exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    exports.NodeType = void 0;
    (function(NodeType2) {
      NodeType2["Article"] = "article";
      NodeType2["HttpService"] = "http_service";
      NodeType2["HttpServer"] = "http_server";
      NodeType2["HttpOperation"] = "http_operation";
      NodeType2["HttpCallback"] = "http_callback";
      NodeType2["Model"] = "model";
      NodeType2["Generic"] = "generic";
      NodeType2["Unknown"] = "unknown";
      NodeType2["TableOfContents"] = "table_of_contents";
      NodeType2["SpectralRuleset"] = "spectral_ruleset";
      NodeType2["Styleguide"] = "styleguide";
      NodeType2["Image"] = "image";
      NodeType2["StoplightResolutions"] = "stoplight_resolutions";
      NodeType2["StoplightOverride"] = "stoplight_override";
    })(exports.NodeType || (exports.NodeType = {}));
    exports.NodeFormat = void 0;
    (function(NodeFormat2) {
      NodeFormat2["Json"] = "json";
      NodeFormat2["Markdown"] = "markdown";
      NodeFormat2["Yaml"] = "yaml";
      NodeFormat2["Javascript"] = "javascript";
      NodeFormat2["Apng"] = "apng";
      NodeFormat2["Avif"] = "avif";
      NodeFormat2["Bmp"] = "bmp";
      NodeFormat2["Gif"] = "gif";
      NodeFormat2["Jpeg"] = "jpeg";
      NodeFormat2["Png"] = "png";
      NodeFormat2["Svg"] = "svg";
      NodeFormat2["Webp"] = "webp";
    })(exports.NodeFormat || (exports.NodeFormat = {}));
  }
});

// ../../node_modules/@stoplight/yaml/parseWithPointers.js
var require_parseWithPointers = __commonJS({
  "../../node_modules/@stoplight/yaml/parseWithPointers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ordered_object_literal_1 = require_src2();
    var types_1 = require_dist2();
    var yaml_ast_parser_1 = require_src();
    var buildJsonPath_1 = require_buildJsonPath();
    var dereferenceAnchor_1 = require_dereferenceAnchor();
    var lineForPosition_1 = require_lineForPosition();
    var types_2 = require_types();
    var utils_1 = require_utils();
    exports.parseWithPointers = (value, options) => {
      const lineMap = computeLineMap(value);
      const ast = yaml_ast_parser_1.load(value, Object.assign({}, options, { ignoreDuplicateKeys: true }));
      const parsed = {
        ast,
        lineMap,
        data: void 0,
        diagnostics: [],
        metadata: options
      };
      if (!ast)
        return parsed;
      parsed.data = exports.walkAST(ast, options, lineMap, parsed.diagnostics);
      if (ast.errors) {
        parsed.diagnostics.push(...transformErrors(ast.errors, lineMap));
      }
      if (parsed.diagnostics.length > 0) {
        parsed.diagnostics.sort((itemA, itemB) => itemA.range.start.line - itemB.range.start.line);
      }
      if (Array.isArray(parsed.ast.errors)) {
        parsed.ast.errors.length = 0;
      }
      return parsed;
    };
    exports.walkAST = (node, options, lineMap, diagnostics) => {
      if (node) {
        switch (node.kind) {
          case types_2.Kind.MAP: {
            const preserveKeyOrder = options !== void 0 && options.preserveKeyOrder === true;
            const container = createMapContainer(preserveKeyOrder);
            const seenKeys = [];
            const handleMergeKeys = options !== void 0 && options.mergeKeys === true;
            const yamlMode = options !== void 0 && options.json === false;
            const handleDuplicates = options !== void 0 && options.ignoreDuplicateKeys === false;
            for (const mapping of node.mappings) {
              if (!validateMappingKey(mapping, lineMap, diagnostics, yamlMode))
                continue;
              const key = String(getScalarValue(mapping.key));
              if ((yamlMode || handleDuplicates) && (!handleMergeKeys || key !== "<<")) {
                if (seenKeys.includes(key)) {
                  if (yamlMode) {
                    throw new Error("Duplicate YAML mapping key encountered");
                  }
                  if (handleDuplicates) {
                    diagnostics.push(createYAMLException(mapping.key, lineMap, "duplicate key"));
                  }
                } else {
                  seenKeys.push(key);
                }
              }
              if (handleMergeKeys && key === "<<") {
                const reduced = reduceMergeKeys(exports.walkAST(mapping.value, options, lineMap, diagnostics), preserveKeyOrder);
                Object.assign(container, reduced);
              } else {
                container[key] = exports.walkAST(mapping.value, options, lineMap, diagnostics);
                if (preserveKeyOrder) {
                  pushKey(container, key);
                }
              }
            }
            return container;
          }
          case types_2.Kind.SEQ:
            return node.items.map((item) => exports.walkAST(item, options, lineMap, diagnostics));
          case types_2.Kind.SCALAR: {
            const bigInt = options !== void 0 && options.bigInt === true;
            const value = getScalarValue(node);
            return !bigInt && typeof value === "bigint" ? Number(value) : value;
          }
          case types_2.Kind.ANCHOR_REF: {
            if (utils_1.isObject(node.value)) {
              node.value = dereferenceAnchor_1.dereferenceAnchor(node.value, node.referencesAnchor);
            }
            return exports.walkAST(node.value, options, lineMap, diagnostics);
          }
          default:
            return null;
        }
      }
      return node;
    };
    function getScalarValue(node) {
      switch (yaml_ast_parser_1.determineScalarType(node)) {
        case types_2.ScalarType.null:
          return null;
        case types_2.ScalarType.string:
          return String(node.value);
        case types_2.ScalarType.bool:
          return yaml_ast_parser_1.parseYamlBoolean(node.value);
        case types_2.ScalarType.int:
          return yaml_ast_parser_1.parseYamlBigInteger(node.value);
        case types_2.ScalarType.float:
          return yaml_ast_parser_1.parseYamlFloat(node.value);
      }
    }
    var computeLineMap = (input) => {
      const lineMap = [];
      let i3 = 0;
      for (; i3 < input.length; i3++) {
        if (input[i3] === "\n") {
          lineMap.push(i3 + 1);
        }
      }
      lineMap.push(i3 + 1);
      return lineMap;
    };
    function getLineLength(lineMap, line) {
      if (line === 0) {
        return Math.max(0, lineMap[0] - 1);
      }
      return Math.max(0, lineMap[line] - lineMap[line - 1] - 1);
    }
    var transformErrors = (errors, lineMap) => {
      const validations = [];
      let possiblyUnexpectedFlow = -1;
      let i3 = 0;
      for (const error of errors) {
        const validation = {
          code: error.name,
          message: error.reason,
          severity: error.isWarning ? types_1.DiagnosticSeverity.Warning : types_1.DiagnosticSeverity.Error,
          range: {
            start: {
              line: error.mark.line,
              character: error.mark.column
            },
            end: {
              line: error.mark.line,
              character: error.mark.toLineEnd ? getLineLength(lineMap, error.mark.line) : error.mark.column
            }
          }
        };
        const isBrokenFlow = error.reason === "missed comma between flow collection entries";
        if (isBrokenFlow) {
          possiblyUnexpectedFlow = possiblyUnexpectedFlow === -1 ? i3 : possiblyUnexpectedFlow;
        } else if (possiblyUnexpectedFlow !== -1) {
          validations[possiblyUnexpectedFlow].range.end = validation.range.end;
          validations[possiblyUnexpectedFlow].message = "invalid mixed usage of block and flow styles";
          validations.length = possiblyUnexpectedFlow + 1;
          i3 = validations.length;
          possiblyUnexpectedFlow = -1;
        }
        validations.push(validation);
        i3++;
      }
      return validations;
    };
    var reduceMergeKeys = (items, preserveKeyOrder) => {
      if (Array.isArray(items)) {
        const reduced = items.reduceRight(preserveKeyOrder ? (merged, item) => {
          const keys = Object.keys(item);
          Object.assign(merged, item);
          for (let i3 = keys.length - 1; i3 >= 0; i3--) {
            unshiftKey(merged, keys[i3]);
          }
          return merged;
        } : (merged, item) => Object.assign(merged, item), createMapContainer(preserveKeyOrder));
        return reduced;
      }
      return typeof items !== "object" || items === null ? null : Object(items);
    };
    function createMapContainer(preserveKeyOrder) {
      return preserveKeyOrder ? ordered_object_literal_1.default({}) : {};
    }
    function deleteKey(container, key) {
      if (!(key in container))
        return;
      const order = ordered_object_literal_1.getOrder(container);
      const index3 = order.indexOf(key);
      if (index3 !== -1) {
        order.splice(index3, 1);
      }
    }
    function unshiftKey(container, key) {
      deleteKey(container, key);
      ordered_object_literal_1.getOrder(container).unshift(key);
    }
    function pushKey(container, key) {
      deleteKey(container, key);
      ordered_object_literal_1.getOrder(container).push(key);
    }
    function validateMappingKey(mapping, lineMap, diagnostics, yamlMode) {
      if (mapping.key.kind !== types_2.Kind.SCALAR) {
        if (!yamlMode) {
          diagnostics.push(createYAMLIncompatibilityException(mapping.key, lineMap, "mapping key must be a string scalar", yamlMode));
        }
        return false;
      }
      if (!yamlMode) {
        const type = typeof getScalarValue(mapping.key);
        if (type !== "string") {
          diagnostics.push(createYAMLIncompatibilityException(mapping.key, lineMap, `mapping key must be a string scalar rather than ${mapping.key.valueObject === null ? "null" : type}`, yamlMode));
        }
      }
      return true;
    }
    function createYAMLIncompatibilityException(node, lineMap, message, yamlMode) {
      const exception = createYAMLException(node, lineMap, message);
      exception.code = "YAMLIncompatibleValue";
      exception.severity = yamlMode ? types_1.DiagnosticSeverity.Hint : types_1.DiagnosticSeverity.Warning;
      return exception;
    }
    function createYAMLException(node, lineMap, message) {
      const startLine = lineForPosition_1.lineForPosition(node.startPosition, lineMap);
      const endLine = lineForPosition_1.lineForPosition(node.endPosition, lineMap);
      return {
        code: "YAMLException",
        message,
        severity: types_1.DiagnosticSeverity.Error,
        path: buildJsonPath_1.buildJsonPath(node),
        range: {
          start: {
            line: startLine,
            character: startLine === 0 ? node.startPosition : node.startPosition - lineMap[startLine - 1]
          },
          end: {
            line: endLine,
            character: endLine === 0 ? node.endPosition : node.endPosition - lineMap[endLine - 1]
          }
        }
      };
    }
  }
});

// ../../node_modules/@stoplight/yaml/parse.js
var require_parse = __commonJS({
  "../../node_modules/@stoplight/yaml/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var yaml_ast_parser_1 = require_src();
    var parseWithPointers_1 = require_parseWithPointers();
    exports.parse = (value) => parseWithPointers_1.walkAST(yaml_ast_parser_1.load(value), void 0, [], []);
  }
});

// ../../node_modules/@stoplight/yaml/safeStringify.js
var require_safeStringify = __commonJS({
  "../../node_modules/@stoplight/yaml/safeStringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var yaml_ast_parser_1 = require_src();
    exports.safeStringify = (value, options) => typeof value === "string" ? value : yaml_ast_parser_1.safeDump(value, options);
  }
});

// ../../node_modules/@stoplight/yaml/trapAccess.js
var require_trapAccess = __commonJS({
  "../../node_modules/@stoplight/yaml/trapAccess.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ordered_object_literal_1 = require_src2();
    exports.KEYS = Symbol.for(ordered_object_literal_1.ORDER_KEY_ID);
    var traps2 = {
      ownKeys(target) {
        return exports.KEYS in target ? target[exports.KEYS] : Reflect.ownKeys(target);
      }
    };
    exports.trapAccess = (target) => new Proxy(target, traps2);
  }
});

// ../../node_modules/@stoplight/yaml/index.js
var require_yaml = __commonJS({
  "../../node_modules/@stoplight/yaml/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_buildJsonPath(), exports);
    tslib_1.__exportStar(require_dereferenceAnchor(), exports);
    tslib_1.__exportStar(require_getJsonPathForPosition(), exports);
    tslib_1.__exportStar(require_getLocationForJsonPath(), exports);
    tslib_1.__exportStar(require_lineForPosition(), exports);
    tslib_1.__exportStar(require_parse(), exports);
    tslib_1.__exportStar(require_parseWithPointers(), exports);
    tslib_1.__exportStar(require_safeStringify(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_trapAccess(), exports);
  }
});

// ../../node_modules/@stoplight/spectral-parsers/dist/yaml.js
var require_yaml2 = __commonJS({
  "../../node_modules/@stoplight/spectral-parsers/dist/yaml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Yaml = exports.parseYaml = void 0;
    var yaml_1 = require_yaml();
    var parseYaml = (input) => (0, yaml_1.parseWithPointers)(input, {
      ignoreDuplicateKeys: false,
      mergeKeys: true,
      preserveKeyOrder: true
    });
    exports.parseYaml = parseYaml;
    exports.Yaml = {
      parse: exports.parseYaml,
      getLocationForJsonPath: yaml_1.getLocationForJsonPath,
      trapAccess: yaml_1.trapAccess
    };
  }
});

// ../../node_modules/@stoplight/spectral-parsers/dist/types.js
var require_types2 = __commonJS({
  "../../node_modules/@stoplight/spectral-parsers/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@stoplight/spectral-parsers/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/@stoplight/spectral-parsers/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    (0, tslib_1.__exportStar)(require_json(), exports);
    (0, tslib_1.__exportStar)(require_yaml2(), exports);
    (0, tslib_1.__exportStar)(require_types2(), exports);
  }
});

// ../../node_modules/@stoplight/json-ref-readers/node_modules/tslib/tslib.es6.js
var tslib_es6_exports2 = {};
__export(tslib_es6_exports2, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator2,
  __asyncGenerator: () => __asyncGenerator2,
  __asyncValues: () => __asyncValues2,
  __await: () => __await2,
  __awaiter: () => __awaiter2,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding2,
  __decorate: () => __decorate2,
  __exportStar: () => __exportStar2,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar2,
  __makeTemplateObject: () => __makeTemplateObject2,
  __metadata: () => __metadata2,
  __param: () => __param2,
  __read: () => __read2,
  __rest: () => __rest2,
  __spread: () => __spread2,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2
});
function __extends2(d2, b3) {
  extendStatics2(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
function __rest2(s2, e3) {
  var t3 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t3[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s2); i3 < p2.length; i3++) {
      if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i3]))
        t3[p2[i3]] = s2[p2[i3]];
    }
  return t3;
}
function __decorate2(decorators, target, key, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r3 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d2 = decorators[i3])
        r3 = (c2 < 3 ? d2(r3) : c2 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
}
function __param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve3) {
      resolve3(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve3, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n3) {
    return function(v2) {
      return step([n3, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y && (t3 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t3 = y["return"]) && t3.call(y), 0) : y.next) && !(t3 = t3.call(y, op[1])).done)
          return t3;
        if (y = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding2(o3, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o3[k22] = m2[k2];
}
function __exportStar2(m2, exports) {
  for (var p2 in m2)
    if (p2 !== "default" && !exports.hasOwnProperty(p2))
      exports[p2] = m2[p2];
}
function __values2(o3) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o3[s2], i3 = 0;
  if (m2)
    return m2.call(o3);
  if (o3 && typeof o3.length === "number")
    return {
      next: function() {
        if (o3 && i3 >= o3.length)
          o3 = void 0;
        return { value: o3 && o3[i3++], done: !o3 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o3, n3) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i3 = m2.call(o3), r3, ar = [], e3;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r3 = i3.next()).done)
      ar.push(r3.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m2 = i3["return"]))
        m2.call(i3);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spread2() {
  for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
    ar = ar.concat(__read2(arguments[i3]));
  return ar;
}
function __spreadArrays2() {
  for (var s2 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
    s2 += arguments[i3].length;
  for (var r3 = Array(s2), k2 = 0, i3 = 0; i3 < il; i3++)
    for (var a3 = arguments[i3], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
      r3[k2] = a3[j2];
  return r3;
}
function __await2(v2) {
  return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i3, q2 = [];
  return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3;
  function verb(n3) {
    if (g2[n3])
      i3[n3] = function(v2) {
        return new Promise(function(a3, b3) {
          q2.push([n3, v2, a3, b3]) > 1 || resume(n3, v2);
        });
      };
  }
  function resume(n3, v2) {
    try {
      step(g2[n3](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step(r3) {
    r3.value instanceof __await2 ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator2(o3) {
  var i3, p2;
  return i3 = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i3[Symbol.iterator] = function() {
    return this;
  }, i3;
  function verb(n3, f2) {
    i3[n3] = o3[n3] ? function(v2) {
      return (p2 = !p2) ? { value: __await2(o3[n3](v2)), done: n3 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues2(o3) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o3[Symbol.asyncIterator], i3;
  return m2 ? m2.call(o3) : (o3 = typeof __values2 === "function" ? __values2(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3);
  function verb(n3) {
    i3[n3] = o3[n3] && function(v2) {
      return new Promise(function(resolve3, reject) {
        v2 = o3[n3](v2), settle(resolve3, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve3, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve3({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject2(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar2(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (Object.hasOwnProperty.call(mod, k2))
        result[k2] = mod[k2];
  }
  result.default = mod;
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet2(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet2(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics2, __assign2;
var init_tslib_es62 = __esm({
  "../../node_modules/@stoplight/json-ref-readers/node_modules/tslib/tslib.es6.js"() {
    "use strict";
    extendStatics2 = function(d2, b3) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
        d3.__proto__ = b4;
      } || function(d3, b4) {
        for (var p2 in b4)
          if (b4.hasOwnProperty(p2))
            d3[p2] = b4[p2];
      };
      return extendStatics2(d2, b3);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t3) {
        for (var s2, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
          s2 = arguments[i3];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t3[p2] = s2[p2];
        }
        return t3;
      };
      return __assign2.apply(this, arguments);
    };
  }
});

// ../../node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/webidl-conversions/lib/index.js"(exports, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x3) {
      return x3 < 0 ? -1 : 1;
    }
    function evenRound(x3) {
      if (x3 % 1 === 0.5 && (x3 & 1) === 0) {
        return Math.floor(x3);
      } else {
        return Math.round(x3);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V2, opts) {
        if (!opts)
          opts = {};
        let x3 = +V2;
        if (opts.enforceRange) {
          if (!Number.isFinite(x3)) {
            throw new TypeError("Argument is not a finite number");
          }
          x3 = sign(x3) * Math.floor(Math.abs(x3));
          if (x3 < lowerBound || x3 > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x3;
        }
        if (!isNaN(x3) && opts.clamp) {
          x3 = evenRound(x3);
          if (x3 < lowerBound)
            x3 = lowerBound;
          if (x3 > upperBound)
            x3 = upperBound;
          return x3;
        }
        if (!Number.isFinite(x3) || x3 === 0) {
          return 0;
        }
        x3 = sign(x3) * Math.floor(Math.abs(x3));
        x3 = x3 % moduloVal;
        if (!typeOpts.unsigned && x3 >= moduloBound) {
          return x3 - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x3 < 0) {
            x3 += moduloVal;
          } else if (x3 === -0) {
            return 0;
          }
        }
        return x3;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V2) {
      const x3 = +V2;
      if (!Number.isFinite(x3)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x3;
    };
    conversions["unrestricted double"] = function(V2) {
      const x3 = +V2;
      if (isNaN(x3)) {
        throw new TypeError("Argument is NaN");
      }
      return x3;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V2, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V2 === null) {
        return "";
      }
      return String(V2);
    };
    conversions["ByteString"] = function(V2, opts) {
      const x3 = String(V2);
      let c2 = void 0;
      for (let i3 = 0; (c2 = x3.codePointAt(i3)) !== void 0; ++i3) {
        if (c2 > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x3;
    };
    conversions["USVString"] = function(V2) {
      const S2 = String(V2);
      const n3 = S2.length;
      const U2 = [];
      for (let i3 = 0; i3 < n3; ++i3) {
        const c2 = S2.charCodeAt(i3);
        if (c2 < 55296 || c2 > 57343) {
          U2.push(String.fromCodePoint(c2));
        } else if (56320 <= c2 && c2 <= 57343) {
          U2.push(String.fromCodePoint(65533));
        } else {
          if (i3 === n3 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            const d2 = S2.charCodeAt(i3 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              const a3 = c2 & 1023;
              const b3 = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a3 + b3));
              ++i3;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U2.join("");
    };
    conversions["Date"] = function(V2, opts) {
      if (!(V2 instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V2)) {
        return void 0;
      }
      return V2;
    };
    conversions["RegExp"] = function(V2, opts) {
      if (!(V2 instanceof RegExp)) {
        V2 = new RegExp(V2);
      }
      return V2;
    };
  }
});

// ../../node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/whatwg-url/lib/utils.js"(exports, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i3 = 0; i3 < keys.length; ++i3) {
        Object.defineProperty(target, keys[i3], Object.getOwnPropertyDescriptor(source, keys[i3]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// ../../node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../../node_modules/tr46/lib/mappingTable.json"(exports, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../../node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../../node_modules/tr46/index.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s2) {
        return s2.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i3 = 0; i3 < len; ++i3) {
        var codePoint = domain_name.codePointAt(i3);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i3 = 0; i3 < len; ++i3) {
        var status = findStatus(label.codePointAt(i3));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i3 = 0; i3 < labels.length; ++i3) {
        try {
          var validation = validateLabel(labels[i3]);
          labels[i3] = validation.label;
          result.error = result.error || validation.error;
        } catch (e3) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l2) {
        try {
          return punycode.toASCII(l2);
        } catch (e3) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i3 = 0; i3 < labels.length; ++i3) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../../node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../../node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c2 = input[idx];
      return isNaN(c2) ? void 0 : String.fromCodePoint(c2);
    }
    function isASCIIDigit(c2) {
      return c2 >= 48 && c2 <= 57;
    }
    function isASCIIAlpha(c2) {
      return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122;
    }
    function isASCIIAlphanumeric(c2) {
      return isASCIIAlpha(c2) || isASCIIDigit(c2);
    }
    function isASCIIHex(c2) {
      return isASCIIDigit(c2) || c2 >= 65 && c2 <= 70 || c2 >= 97 && c2 <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c2) {
      let hex = c2.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c2) {
      const buf = new Buffer(c2);
      let str = "";
      for (let i3 = 0; i3 < buf.length; ++i3) {
        str += percentEncode(buf[i3]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i3 = 0; i3 < input.length; ++i3) {
        if (input[i3] !== 37) {
          output.push(input[i3]);
        } else if (input[i3] === 37 && isASCIIHex(input[i3 + 1]) && isASCIIHex(input[i3 + 2])) {
          output.push(parseInt(input.slice(i3 + 1, i3 + 3).toString(), 16));
          i3 += 2;
        } else {
          output.push(input[i3]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c2) {
      return c2 <= 31 || c2 > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c2) {
      return isC0ControlPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c2) {
      return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
    }
    function percentEncodeChar(c2, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c2);
      if (encodeSetPredicate(c2)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R2 = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R2 = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R2 = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex3 = R2 === 10 ? /[^0-9]/ : R2 === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex3.test(input)) {
        return failure;
      }
      return parseInt(input, R2);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n3 = parseIPv4Number(part);
        if (n3 === failure) {
          return input;
        }
        numbers.push(n3);
      }
      for (let i3 = 0; i3 < numbers.length - 1; ++i3) {
        if (numbers[i3] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n3 of numbers) {
        ipv4 += n3 * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n3 = address;
      for (let i3 = 1; i3 <= 4; ++i3) {
        output = String(n3 % 256) + output;
        if (i3 !== 4) {
          output = "." + output;
        }
        n3 = Math.floor(n3 / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator2 = pieceIndex === 0 ? "::" : ":";
          output += separator2;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i3 = 0; i3 < decoded.length; ++i3) {
        output += percentEncodeChar(decoded[i3], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i3 = 0; i3 < arr.length; ++i3) {
        if (arr[i3] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i3;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c2 = this.input[this.pointer];
        const cStr = isNaN(c2) ? void 0 : String.fromCodePoint(c2);
        const ret = this["parse " + this.state](c2, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c2, cStr) {
      if (isASCIIAlpha(c2)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
      if (isASCIIAlphanumeric(c2) || c2 === 43 || c2 === 45 || c2 === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c2 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
      if (this.base === null || this.base.cannotBeABaseURL && c2 !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c2 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c2) {
      if (c2 === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c2)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c2 === 47) {
        this.state = "relative slash";
      } else if (c2 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c2 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c2) {
      if (isSpecial(this.url) && (c2 === 47 || c2 === 92)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c2 === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c2) {
      if (c2 === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c2) {
      if (c2 !== 47 && c2 !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c2, cStr) {
      if (c2 === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c2, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c2 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c2 === 91) {
          this.arrFlag = true;
        } else if (c2 === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
      if (isASCIIDigit(c2)) {
        this.buffer += cStr;
      } else if (isNaN(c2) || c2 === 47 || c2 === 63 || c2 === 35 || isSpecial(this.url) && c2 === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile2(c2) {
      this.url.scheme = "file";
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c2)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c2 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c2 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c2, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c2) {
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c2, cStr) {
      if (isNaN(c2) || c2 === 47 || c2 === 92 || c2 === 63 || c2 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c2) {
      if (isSpecial(this.url)) {
        if (c2 === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c2 !== 47 && c2 !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c2 !== void 0) {
        this.state = "path";
        if (c2 !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c2) {
      if (isNaN(c2) || c2 === 47 || isSpecial(this.url) && c2 === 92 || !this.stateOverride && (c2 === 63 || c2 === 35)) {
        if (isSpecial(this.url) && c2 === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c2 !== 47 && !(isSpecial(this.url) && c2 === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c2 === void 0 || c2 === 63 || c2 === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c2 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c2, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c2) {
      if (c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c2) && c2 !== 37) {
          this.parseError = true;
        }
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c2)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c2, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
      if (isNaN(c2) || !this.stateOverride && c2 === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i3 = 0; i3 < buffer.length; ++i3) {
          if (buffer[i3] < 33 || buffer[i3] > 126 || buffer[i3] === 34 || buffer[i3] === 35 || buffer[i3] === 60 || buffer[i3] === 62) {
            this.url.query += percentEncode(buffer[i3]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i3]);
          }
        }
        this.buffer = "";
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
      if (isNaN(c2)) {
      } else if (c2 === 0) {
        this.parseError = true;
      } else {
        if (c2 === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c2, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e3) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i3 = 0; i3 < decoded.length; ++i3) {
        url.username += percentEncodeChar(decoded[i3], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i3 = 0; i3 < decoded.length; ++i3) {
        url.password += percentEncodeChar(decoded[i3], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../../node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v2) {
        const parsedURL = usm.basicURLParse(v2);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v2) {
        usm.basicURLParse(v2 + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v2);
      }
      get password() {
        return this._url.password;
      }
      set password(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v2);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v2, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v2 === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v2, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v2) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v2, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v2) {
        const url = this._url;
        if (v2 === "") {
          url.query = null;
          return;
        }
        const input = v2[0] === "?" ? v2.substring(1) : v2;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v2) {
        if (v2 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v2[0] === "#" ? v2.substring(1) : v2;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../../node_modules/whatwg-url/lib/URL.js"(exports, module2) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils2();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL3(url) {
      if (!this || this[impl] || !(this instanceof URL3)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i3 = 0; i3 < arguments.length && i3 < 2; ++i3) {
        args[i3] = arguments[i3];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL3.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i3 = 0; i3 < arguments.length && i3 < 0; ++i3) {
        args[i3] = arguments[i3];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL3.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].href = V2;
      },
      enumerable: true,
      configurable: true
    });
    URL3.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL3.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].protocol = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].username = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].password = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].host = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hostname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].port = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].pathname = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].search = V2;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V2) {
        V2 = conversions["USVString"](V2);
        this[impl].hash = V2;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL3.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL3,
      expose: {
        Window: { URL: URL3 },
        Worker: { URL: URL3 }
      }
    };
  }
});

// ../../node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// ../../node_modules/node-fetch/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  AbortError: () => AbortError,
  FetchError: () => FetchError,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  default: () => lib_default
});
function FetchError(message, type, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (isBlob(body))
    ;
  else if (Buffer.isBuffer(body))
    ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof import_stream.default)
    ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof import_stream.default) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body = this.body;
  if (body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return Body.Promise.resolve(body);
  }
  if (!(body instanceof import_stream.default)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve3, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve3(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function isBlob(obj) {
  return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
function clone(instance) {
  let p1, p2;
  let body = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body)) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof import_stream.default) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body = instance.body;
  if (body === null) {
    return 0;
  } else if (isBlob(body)) {
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body = instance.body;
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name) || name === "") {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map, name) {
  name = name.toLowerCase();
  for (const key in map) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k2) {
    return k2.toLowerCase();
  } : kind === "value" ? function(k2) {
    return headers[MAP][k2].join(", ");
  } : function(k2) {
    return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
  });
}
function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name of Object.keys(obj)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj[name])) {
      for (const val of obj[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [val];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name])) {
      headers[MAP][name] = [obj[name]];
    }
  }
  return headers;
}
function parseURL(urlStr) {
  if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
    urlStr = new URL2(urlStr).toString();
  }
  return parse_url(urlStr);
}
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent = request.agent;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
function fetch(url, opts) {
  if (!fetch.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch.Promise;
  return new fetch.Promise(function(resolve3, reject) {
    const request = new Request(url, opts);
    const options = getNodeRequestOptions(request);
    const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        destroyStream(request.body, error);
      }
      if (!response || !response.body)
        return;
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal)
        signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      if (response && response.body) {
        destroyStream(response.body, err);
      }
      finalize();
    });
    fixResponseChunkedTransferBadEnding(req, function(err) {
      if (signal && signal.aborted) {
        return;
      }
      if (response && response.body) {
        destroyStream(response.body, err);
      }
    });
    if (parseInt(process.version.substring(1)) < 14) {
      req.on("socket", function(s2) {
        s2.addListener("close", function(hadError) {
          const hasDataListener = s2.listenerCount("data") > 0;
          if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", err);
          }
        });
      });
    }
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
        const location2 = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location2 === null ? null : new URL$1(location2, request.url).toString();
        } catch (err) {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOpts.headers.delete(name);
              }
            }
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve3(fetch(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve3(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve3(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(import_zlib.default.createInflate());
          } else {
            body = body.pipe(import_zlib.default.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve3(response);
        });
        raw.on("end", function() {
          if (!response) {
            response = new Response(body, response_options);
            resolve3(response);
          }
        });
        return;
      }
      if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
        body = body.pipe(import_zlib.default.createBrotliDecompress());
        response = new Response(body, response_options);
        resolve3(response);
        return;
      }
      response = new Response(body, response_options);
      resolve3(response);
    });
    writeToStream(req, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  let socket;
  request.on("socket", function(s2) {
    socket = s2;
  });
  request.on("response", function(response) {
    const headers = response.headers;
    if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
      response.once("close", function(hadError) {
        const hasDataListener = socket && socket.listenerCount("data") > 0;
        if (hasDataListener && !hadError) {
          const err = new Error("Premature close");
          err.code = "ERR_STREAM_PREMATURE_CLOSE";
          errorCallback(err);
        }
      });
    }
  });
}
function destroyStream(stream, err) {
  if (stream.destroy) {
    stream.destroy(err);
  } else {
    stream.emit("error", err);
    stream.end();
  }
}
var import_stream, import_http, import_url, import_whatwg_url, import_https, import_zlib, Readable, BUFFER, TYPE, Blob, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response, INTERNALS$2, URL2, parse_url, format_url, streamDestructionSupported, Request, URL$1, PassThrough$1, isDomainOrSubdomain, isSameProtocol, lib_default;
var init_lib = __esm({
  "../../node_modules/node-fetch/lib/index.mjs"() {
    "use strict";
    import_stream = __toESM(require("stream"), 1);
    import_http = __toESM(require("http"), 1);
    import_url = __toESM(require("url"), 1);
    import_whatwg_url = __toESM(require_public_api(), 1);
    import_https = __toESM(require("https"), 1);
    import_zlib = __toESM(require("zlib"), 1);
    Readable = import_stream.default.Readable;
    BUFFER = Symbol("buffer");
    TYPE = Symbol("type");
    Blob = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a3 = blobParts;
          const length = Number(a3.length);
          for (let i3 = 0; i3 < length; i3++) {
            const element = a3[i3];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    try {
      convert = require("encoding").convert;
    } catch (e3) {
    }
    INTERNALS = Symbol("Body internals");
    PassThrough = import_stream.default.PassThrough;
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    Body.Promise = global.Promise;
    invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    MAP = Symbol("map");
    Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i3 = 0;
        while (i3 < pairs.length) {
          var _pairs$i = pairs[i3];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i3++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    INTERNAL = Symbol("internal");
    HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index3 = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index3 >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index3 + 1;
        return {
          value: values[index3],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$1 = Symbol("Response internals");
    STATUS_CODES = import_http.default.STATUS_CODES;
    Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$2 = Symbol("Request internals");
    URL2 = import_url.default.URL || import_whatwg_url.default.URL;
    parse_url = import_url.default.parse;
    format_url = import_url.default.format;
    streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
    Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    URL$1 = import_url.default.URL || import_whatwg_url.default.URL;
    PassThrough$1 = import_stream.default.PassThrough;
    isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    fetch.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch.Promise = global.Promise;
    lib_default = fetch;
  }
});

// ../../node_modules/@stoplight/json-ref-readers/http.js
var require_http = __commonJS({
  "../../node_modules/@stoplight/json-ref-readers/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var node_fetch_1 = (init_lib(), __toCommonJS(lib_exports));
    var OpenError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "OpenError";
      }
    };
    exports.OpenError = OpenError;
    var NetworkError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ReadError";
      }
    };
    exports.NetworkError = NetworkError;
    function resolveHttp(ref, opts = {}) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const uri = ref.href();
        const response = yield node_fetch_1.default(uri, opts);
        if (response.ok) {
          return response.text();
        }
        if (response.status === 404) {
          throw new OpenError(`Page not found: ${uri}`);
        }
        throw new NetworkError(`${response.status} ${response.statusText}`);
      });
    }
    exports.resolveHttp = resolveHttp;
    function createResolveHttp(defaultRequestOptions = {}) {
      return (ref) => resolveHttp(ref, defaultRequestOptions);
    }
    exports.createResolveHttp = createResolveHttp;
  }
});

// ../../node_modules/@stoplight/json-ref-readers/file.js
var require_file = __commonJS({
  "../../node_modules/@stoplight/json-ref-readers/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = require("fs");
    function resolveFile(ref) {
      return new Promise((resolve3, reject) => {
        const path2 = ref.href();
        fs_1.readFile(path2, "utf8", (err, data) => {
          if (err) {
            reject(err);
          } else {
            resolve3(data);
          }
        });
      });
    }
    exports.resolveFile = resolveFile;
  }
});

// ../../node_modules/@stoplight/json-ref-readers/index.js
var require_json_ref_readers = __commonJS({
  "../../node_modules/@stoplight/json-ref-readers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var http_1 = require_http();
    exports.createResolveHttp = http_1.createResolveHttp;
    exports.resolveHttp = http_1.resolveHttp;
    exports.NetworkError = http_1.NetworkError;
    exports.OpenError = http_1.OpenError;
    var file_1 = require_file();
    exports.resolveFile = file_1.resolveFile;
  }
});

// ../../node_modules/dependency-graph/lib/dep_graph.js
var require_dep_graph = __commonJS({
  "../../node_modules/dependency-graph/lib/dep_graph.js"(exports) {
    "use strict";
    function createDFS(edges, leavesOnly, result, circular) {
      var visited = {};
      return function(start) {
        if (visited[start]) {
          return;
        }
        var inCurrentPath = {};
        var currentPath = [];
        var todo = [];
        todo.push({ node: start, processed: false });
        while (todo.length > 0) {
          var current = todo[todo.length - 1];
          var processed = current.processed;
          var node = current.node;
          if (!processed) {
            if (visited[node]) {
              todo.pop();
              continue;
            } else if (inCurrentPath[node]) {
              if (circular) {
                todo.pop();
                continue;
              }
              currentPath.push(node);
              throw new DepGraphCycleError(currentPath);
            }
            inCurrentPath[node] = true;
            currentPath.push(node);
            var nodeEdges = edges[node];
            for (var i3 = nodeEdges.length - 1; i3 >= 0; i3--) {
              todo.push({ node: nodeEdges[i3], processed: false });
            }
            current.processed = true;
          } else {
            todo.pop();
            currentPath.pop();
            inCurrentPath[node] = false;
            visited[node] = true;
            if (!leavesOnly || edges[node].length === 0) {
              result.push(node);
            }
          }
        }
      };
    }
    var DepGraph = exports.DepGraph = function DepGraph2(opts) {
      this.nodes = {};
      this.outgoingEdges = {};
      this.incomingEdges = {};
      this.circular = opts && !!opts.circular;
    };
    DepGraph.prototype = {
      /**
       * The number of nodes in the graph.
       */
      size: function() {
        return Object.keys(this.nodes).length;
      },
      /**
       * Add a node to the dependency graph. If a node already exists, this method will do nothing.
       */
      addNode: function(node, data) {
        if (!this.hasNode(node)) {
          if (arguments.length === 2) {
            this.nodes[node] = data;
          } else {
            this.nodes[node] = node;
          }
          this.outgoingEdges[node] = [];
          this.incomingEdges[node] = [];
        }
      },
      /**
       * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
       */
      removeNode: function(node) {
        if (this.hasNode(node)) {
          delete this.nodes[node];
          delete this.outgoingEdges[node];
          delete this.incomingEdges[node];
          [this.incomingEdges, this.outgoingEdges].forEach(function(edgeList) {
            Object.keys(edgeList).forEach(function(key) {
              var idx = edgeList[key].indexOf(node);
              if (idx >= 0) {
                edgeList[key].splice(idx, 1);
              }
            }, this);
          });
        }
      },
      /**
       * Check if a node exists in the graph
       */
      hasNode: function(node) {
        return this.nodes.hasOwnProperty(node);
      },
      /**
       * Get the data associated with a node name
       */
      getNodeData: function(node) {
        if (this.hasNode(node)) {
          return this.nodes[node];
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Set the associated data for a given node name. If the node does not exist, this method will throw an error
       */
      setNodeData: function(node, data) {
        if (this.hasNode(node)) {
          this.nodes[node] = data;
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Add a dependency between two nodes. If either of the nodes does not exist,
       * an Error will be thrown.
       */
      addDependency: function(from, to) {
        if (!this.hasNode(from)) {
          throw new Error("Node does not exist: " + from);
        }
        if (!this.hasNode(to)) {
          throw new Error("Node does not exist: " + to);
        }
        if (this.outgoingEdges[from].indexOf(to) === -1) {
          this.outgoingEdges[from].push(to);
        }
        if (this.incomingEdges[to].indexOf(from) === -1) {
          this.incomingEdges[to].push(from);
        }
        return true;
      },
      /**
       * Remove a dependency between two nodes.
       */
      removeDependency: function(from, to) {
        var idx;
        if (this.hasNode(from)) {
          idx = this.outgoingEdges[from].indexOf(to);
          if (idx >= 0) {
            this.outgoingEdges[from].splice(idx, 1);
          }
        }
        if (this.hasNode(to)) {
          idx = this.incomingEdges[to].indexOf(from);
          if (idx >= 0) {
            this.incomingEdges[to].splice(idx, 1);
          }
        }
      },
      /**
       * Return a clone of the dependency graph. If any custom data is attached
       * to the nodes, it will only be shallow copied.
       */
      clone: function() {
        var source = this;
        var result = new DepGraph();
        var keys = Object.keys(source.nodes);
        keys.forEach(function(n3) {
          result.nodes[n3] = source.nodes[n3];
          result.outgoingEdges[n3] = source.outgoingEdges[n3].slice(0);
          result.incomingEdges[n3] = source.incomingEdges[n3].slice(0);
        });
        return result;
      },
      /**
       * Get an array containing the direct dependencies of the specified node.
       *
       * Throws an Error if the specified node does not exist.
       */
      directDependenciesOf: function(node) {
        if (this.hasNode(node)) {
          return this.outgoingEdges[node].slice(0);
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Get an array containing the nodes that directly depend on the specified node.
       *
       * Throws an Error if the specified node does not exist.
       */
      directDependantsOf: function(node) {
        if (this.hasNode(node)) {
          return this.incomingEdges[node].slice(0);
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Get an array containing the nodes that the specified node depends on (transitively).
       *
       * Throws an Error if the graph has a cycle, or the specified node does not exist.
       *
       * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
       * in the array.
       */
      dependenciesOf: function(node, leavesOnly) {
        if (this.hasNode(node)) {
          var result = [];
          var DFS = createDFS(
            this.outgoingEdges,
            leavesOnly,
            result,
            this.circular
          );
          DFS(node);
          var idx = result.indexOf(node);
          if (idx >= 0) {
            result.splice(idx, 1);
          }
          return result;
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * get an array containing the nodes that depend on the specified node (transitively).
       *
       * Throws an Error if the graph has a cycle, or the specified node does not exist.
       *
       * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
       */
      dependantsOf: function(node, leavesOnly) {
        if (this.hasNode(node)) {
          var result = [];
          var DFS = createDFS(
            this.incomingEdges,
            leavesOnly,
            result,
            this.circular
          );
          DFS(node);
          var idx = result.indexOf(node);
          if (idx >= 0) {
            result.splice(idx, 1);
          }
          return result;
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Construct the overall processing order for the dependency graph.
       *
       * Throws an Error if the graph has a cycle.
       *
       * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
       */
      overallOrder: function(leavesOnly) {
        var self2 = this;
        var result = [];
        var keys = Object.keys(this.nodes);
        if (keys.length === 0) {
          return result;
        } else {
          if (!this.circular) {
            var CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);
            keys.forEach(function(n3) {
              CycleDFS(n3);
            });
          }
          var DFS = createDFS(
            this.outgoingEdges,
            leavesOnly,
            result,
            this.circular
          );
          keys.filter(function(node) {
            return self2.incomingEdges[node].length === 0;
          }).forEach(function(n3) {
            DFS(n3);
          });
          if (this.circular) {
            keys.filter(function(node) {
              return result.indexOf(node) === -1;
            }).forEach(function(n3) {
              DFS(n3);
            });
          }
          return result;
        }
      },
      /**
       * Get an array of nodes that have no dependants (i.e. nothing depends on them).
       */
      entryNodes: function() {
        var self2 = this;
        return Object.keys(this.nodes).filter(function(node) {
          return self2.incomingEdges[node].length === 0;
        });
      }
    };
    DepGraph.prototype.directDependentsOf = DepGraph.prototype.directDependantsOf;
    DepGraph.prototype.dependentsOf = DepGraph.prototype.dependantsOf;
    var DepGraphCycleError = exports.DepGraphCycleError = function(cyclePath) {
      var message = "Dependency Cycle Found: " + cyclePath.join(" -> ");
      var instance = new Error(message);
      instance.cyclePath = cyclePath;
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      if (Error.captureStackTrace) {
        Error.captureStackTrace(instance, DepGraphCycleError);
      }
      return instance;
    };
    DepGraphCycleError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: Error,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    Object.setPrototypeOf(DepGraphCycleError, Error);
  }
});

// ../../node_modules/@stoplight/json-ref-resolver/cache.js
var require_cache = __commonJS({
  "../../node_modules/@stoplight/json-ref-resolver/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cache = void 0;
    var Cache = class {
      constructor(opts = {}) {
        this._stats = {
          hits: 0,
          misses: 0
        };
        this._data = {};
        this._stdTTL = opts.stdTTL;
      }
      get stats() {
        return this._stats;
      }
      get(key) {
        const d2 = this._data[key];
        if (d2 && (!this._stdTTL || (/* @__PURE__ */ new Date()).getTime() - d2.ts < this._stdTTL)) {
          this._stats.hits += 1;
          return d2.val;
        }
        this._stats.misses += 1;
      }
      set(key, val) {
        this._data[key] = {
          ts: (/* @__PURE__ */ new Date()).getTime(),
          val
        };
      }
      has(key) {
        return key in this._data;
      }
      purge() {
        Object.assign(this._stats, {
          hits: 0,
          misses: 0
        });
        this._data = {};
      }
    };
    exports.Cache = Cache;
  }
});

// ../../node_modules/immer/dist/immer.cjs.production.min.js
var require_immer_cjs_production_min = __commonJS({
  "../../node_modules/immer/dist/immer.cjs.production.min.js"(exports) {
    "use strict";
    function n3(n4) {
      for (var r4 = arguments.length, t4 = Array(r4 > 1 ? r4 - 1 : 0), e4 = 1; e4 < r4; e4++)
        t4[e4 - 1] = arguments[e4];
      throw Error("[Immer] minified error nr: " + n4 + (t4.length ? " " + t4.map(function(n5) {
        return "'" + n5 + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function r3(n4) {
      return !!n4 && !!n4[H2];
    }
    function t3(n4) {
      var r4;
      return !!n4 && (function(n5) {
        if (!n5 || "object" != typeof n5)
          return false;
        var r5 = Object.getPrototypeOf(n5);
        if (null === r5)
          return true;
        var t4 = Object.hasOwnProperty.call(r5, "constructor") && r5.constructor;
        return t4 === Object || "function" == typeof t4 && Function.toString.call(t4) === Q2;
      }(n4) || Array.isArray(n4) || !!n4[G2] || !!(null === (r4 = n4.constructor) || void 0 === r4 ? void 0 : r4[G2]) || c2(n4) || v2(n4));
    }
    function e3(n4, r4, t4) {
      void 0 === t4 && (t4 = false), 0 === i3(n4) ? (t4 ? Object.keys : T2)(n4).forEach(function(e4) {
        t4 && "symbol" == typeof e4 || r4(e4, n4[e4], n4);
      }) : n4.forEach(function(t5, e4) {
        return r4(e4, t5, n4);
      });
    }
    function i3(n4) {
      var r4 = n4[H2];
      return r4 ? r4.t > 3 ? r4.t - 4 : r4.t : Array.isArray(n4) ? 1 : c2(n4) ? 2 : v2(n4) ? 3 : 0;
    }
    function u2(n4, r4) {
      return 2 === i3(n4) ? n4.has(r4) : Object.prototype.hasOwnProperty.call(n4, r4);
    }
    function o3(n4, r4) {
      return 2 === i3(n4) ? n4.get(r4) : n4[r4];
    }
    function f2(n4, r4, t4) {
      var e4 = i3(n4);
      2 === e4 ? n4.set(r4, t4) : 3 === e4 ? n4.add(t4) : n4[r4] = t4;
    }
    function a3(n4, r4) {
      return n4 === r4 ? 0 !== n4 || 1 / n4 == 1 / r4 : n4 != n4 && r4 != r4;
    }
    function c2(n4) {
      return W2 && n4 instanceof Map;
    }
    function v2(n4) {
      return X2 && n4 instanceof Set;
    }
    function s2(n4) {
      return n4.i || n4.u;
    }
    function p2(n4) {
      if (Array.isArray(n4))
        return Array.prototype.slice.call(n4);
      var r4 = U2(n4);
      delete r4[H2];
      for (var t4 = T2(r4), e4 = 0; e4 < t4.length; e4++) {
        var i4 = t4[e4], u3 = r4[i4];
        false === u3.writable && (u3.writable = true, u3.configurable = true), (u3.get || u3.set) && (r4[i4] = { configurable: true, writable: true, enumerable: u3.enumerable, value: n4[i4] });
      }
      return Object.create(Object.getPrototypeOf(n4), r4);
    }
    function l2(n4, u3) {
      return void 0 === u3 && (u3 = false), h2(n4) || r3(n4) || !t3(n4) || (i3(n4) > 1 && (n4.set = n4.add = n4.clear = n4.delete = d2), Object.freeze(n4), u3 && e3(n4, function(n5, r4) {
        return l2(r4, true);
      }, true)), n4;
    }
    function d2() {
      n3(2);
    }
    function h2(n4) {
      return null == n4 || "object" != typeof n4 || Object.isFrozen(n4);
    }
    function y(r4) {
      var t4 = V2[r4];
      return t4 || n3(18, r4), t4;
    }
    function _2(n4, r4) {
      V2[n4] || (V2[n4] = r4);
    }
    function b3() {
      return I2;
    }
    function m2(n4, r4) {
      r4 && (y("Patches"), n4.o = [], n4.v = [], n4.s = r4);
    }
    function j2(n4) {
      O2(n4), n4.p.forEach(w2), n4.p = null;
    }
    function O2(n4) {
      n4 === I2 && (I2 = n4.l);
    }
    function x3(n4) {
      return I2 = { p: [], l: I2, h: n4, _: true, m: 0 };
    }
    function w2(n4) {
      var r4 = n4[H2];
      0 === r4.t || 1 === r4.t ? r4.j() : r4.O = true;
    }
    function S2(r4, e4) {
      e4.m = e4.p.length;
      var i4 = e4.p[0], u3 = void 0 !== r4 && r4 !== i4;
      return e4.h.S || y("ES5").P(e4, r4, u3), u3 ? (i4[H2].g && (j2(e4), n3(4)), t3(r4) && (r4 = P2(e4, r4), e4.l || M2(e4, r4)), e4.o && y("Patches").M(i4[H2].u, r4, e4.o, e4.v)) : r4 = P2(e4, i4, []), j2(e4), e4.o && e4.s(e4.o, e4.v), r4 !== B2 ? r4 : void 0;
    }
    function P2(n4, r4, t4) {
      if (h2(r4))
        return r4;
      var i4 = r4[H2];
      if (!i4)
        return e3(r4, function(e4, u4) {
          return g2(n4, i4, r4, e4, u4, t4);
        }, true), r4;
      if (i4.A !== n4)
        return r4;
      if (!i4.g)
        return M2(n4, i4.u, true), i4.u;
      if (!i4.R) {
        i4.R = true, i4.A.m--;
        var u3 = 4 === i4.t || 5 === i4.t ? i4.i = p2(i4.k) : i4.i, o4 = u3, f3 = false;
        3 === i4.t && (o4 = new Set(u3), u3.clear(), f3 = true), e3(o4, function(r5, e4) {
          return g2(n4, i4, u3, r5, e4, t4, f3);
        }), M2(n4, u3, false), t4 && n4.o && y("Patches").F(i4, t4, n4.o, n4.v);
      }
      return i4.i;
    }
    function g2(n4, e4, i4, o4, a4, c3, v3) {
      if (r3(a4)) {
        var s3 = P2(n4, a4, c3 && e4 && 3 !== e4.t && !u2(e4.N, o4) ? c3.concat(o4) : void 0);
        if (f2(i4, o4, s3), !r3(s3))
          return;
        n4._ = false;
      } else
        v3 && i4.add(a4);
      if (t3(a4) && !h2(a4)) {
        if (!n4.h.D && n4.m < 1)
          return;
        P2(n4, a4), e4 && e4.A.l || M2(n4, a4);
      }
    }
    function M2(n4, r4, t4) {
      void 0 === t4 && (t4 = false), !n4.l && n4.h.D && n4._ && l2(r4, t4);
    }
    function A2(n4, r4) {
      var t4 = n4[H2];
      return (t4 ? s2(t4) : n4)[r4];
    }
    function z2(n4, r4) {
      if (r4 in n4)
        for (var t4 = Object.getPrototypeOf(n4); t4; ) {
          var e4 = Object.getOwnPropertyDescriptor(t4, r4);
          if (e4)
            return e4;
          t4 = Object.getPrototypeOf(t4);
        }
    }
    function E2(n4) {
      n4.g || (n4.g = true, n4.l && E2(n4.l));
    }
    function R2(n4) {
      n4.i || (n4.i = p2(n4.u));
    }
    function k2(n4, r4, t4) {
      var e4 = c2(r4) ? y("MapSet").K(r4, t4) : v2(r4) ? y("MapSet").$(r4, t4) : n4.S ? function(n5, r5) {
        var t5 = Array.isArray(n5), e5 = { t: t5 ? 1 : 0, A: r5 ? r5.A : b3(), g: false, R: false, N: {}, l: r5, u: n5, k: null, i: null, j: null, C: false }, i4 = e5, u3 = Y2;
        t5 && (i4 = [e5], u3 = Z2);
        var o4 = Proxy.revocable(i4, u3), f3 = o4.revoke, a4 = o4.proxy;
        return e5.k = a4, e5.j = f3, a4;
      }(r4, t4) : y("ES5").I(r4, t4);
      return (t4 ? t4.A : b3()).p.push(e4), e4;
    }
    function F2(u3) {
      return r3(u3) || n3(22, u3), function n4(r4) {
        if (!t3(r4))
          return r4;
        var u4, a4 = r4[H2], c3 = i3(r4);
        if (a4) {
          if (!a4.g && (a4.t < 4 || !y("ES5").J(a4)))
            return a4.u;
          a4.R = true, u4 = N2(r4, c3), a4.R = false;
        } else
          u4 = N2(r4, c3);
        return e3(u4, function(r5, t4) {
          a4 && o3(a4.u, r5) === t4 || f2(u4, r5, n4(t4));
        }), 3 === c3 ? new Set(u4) : u4;
      }(u3);
    }
    function N2(n4, r4) {
      switch (r4) {
        case 2:
          return new Map(n4);
        case 3:
          return Array.from(n4);
      }
      return p2(n4);
    }
    function D2() {
      function n4(n5, r4) {
        var t5 = f3[n5];
        return t5 ? t5.enumerable = r4 : f3[n5] = t5 = { configurable: true, enumerable: r4, get: function() {
          return Y2.get(this[H2], n5);
        }, set: function(r5) {
          Y2.set(this[H2], n5, r5);
        } }, t5;
      }
      function t4(n5) {
        for (var r4 = n5.length - 1; r4 >= 0; r4--) {
          var t5 = n5[r4][H2];
          if (!t5.g)
            switch (t5.t) {
              case 5:
                o4(t5) && E2(t5);
                break;
              case 4:
                i4(t5) && E2(t5);
            }
        }
      }
      function i4(n5) {
        for (var r4 = n5.u, t5 = n5.k, e4 = T2(t5), i5 = e4.length - 1; i5 >= 0; i5--) {
          var o5 = e4[i5];
          if (o5 !== H2) {
            var f4 = r4[o5];
            if (void 0 === f4 && !u2(r4, o5))
              return true;
            var c3 = t5[o5], v3 = c3 && c3[H2];
            if (v3 ? v3.u !== f4 : !a3(c3, f4))
              return true;
          }
        }
        var s3 = !!r4[H2];
        return e4.length !== T2(r4).length + (s3 ? 0 : 1);
      }
      function o4(n5) {
        var r4 = n5.k;
        if (r4.length !== n5.u.length)
          return true;
        var t5 = Object.getOwnPropertyDescriptor(r4, r4.length - 1);
        if (t5 && !t5.get)
          return true;
        for (var e4 = 0; e4 < r4.length; e4++)
          if (!r4.hasOwnProperty(e4))
            return true;
        return false;
      }
      var f3 = {};
      _2("ES5", { I: function(r4, t5) {
        var e4 = Array.isArray(r4), i5 = function(r5, t6) {
          if (r5) {
            for (var e5 = Array(t6.length), i6 = 0; i6 < t6.length; i6++)
              Object.defineProperty(e5, "" + i6, n4(i6, true));
            return e5;
          }
          var u4 = U2(t6);
          delete u4[H2];
          for (var o5 = T2(u4), f4 = 0; f4 < o5.length; f4++) {
            var a4 = o5[f4];
            u4[a4] = n4(a4, r5 || !!u4[a4].enumerable);
          }
          return Object.create(Object.getPrototypeOf(t6), u4);
        }(e4, r4), u3 = { t: e4 ? 5 : 4, A: t5 ? t5.A : b3(), g: false, R: false, N: {}, l: t5, u: r4, k: i5, i: null, O: false, C: false };
        return Object.defineProperty(i5, H2, { value: u3, writable: true }), i5;
      }, P: function(n5, i5, f4) {
        f4 ? r3(i5) && i5[H2].A === n5 && t4(n5.p) : (n5.o && function n6(r4) {
          if (r4 && "object" == typeof r4) {
            var t5 = r4[H2];
            if (t5) {
              var i6 = t5.u, f5 = t5.k, a4 = t5.N, c3 = t5.t;
              if (4 === c3)
                e3(f5, function(r5) {
                  r5 !== H2 && (void 0 !== i6[r5] || u2(i6, r5) ? a4[r5] || n6(f5[r5]) : (a4[r5] = true, E2(t5)));
                }), e3(i6, function(n7) {
                  void 0 !== f5[n7] || u2(f5, n7) || (a4[n7] = false, E2(t5));
                });
              else if (5 === c3) {
                if (o4(t5) && (E2(t5), a4.length = true), f5.length < i6.length)
                  for (var v3 = f5.length; v3 < i6.length; v3++)
                    a4[v3] = false;
                else
                  for (var s3 = i6.length; s3 < f5.length; s3++)
                    a4[s3] = true;
                for (var p3 = Math.min(f5.length, i6.length), l3 = 0; l3 < p3; l3++)
                  f5.hasOwnProperty(l3) || (a4[l3] = true), void 0 === a4[l3] && n6(f5[l3]);
              }
            }
          }
        }(n5.p[0]), t4(n5.p));
      }, J: function(n5) {
        return 4 === n5.t ? i4(n5) : o4(n5);
      } });
    }
    function K2() {
      function f3(n4) {
        if (!t3(n4))
          return n4;
        if (Array.isArray(n4))
          return n4.map(f3);
        if (c2(n4))
          return new Map(Array.from(n4.entries()).map(function(n5) {
            return [n5[0], f3(n5[1])];
          }));
        if (v2(n4))
          return new Set(Array.from(n4).map(f3));
        var r4 = Object.create(Object.getPrototypeOf(n4));
        for (var e4 in n4)
          r4[e4] = f3(n4[e4]);
        return u2(n4, G2) && (r4[G2] = n4[G2]), r4;
      }
      function a4(n4) {
        return r3(n4) ? f3(n4) : n4;
      }
      var s3 = "add";
      _2("Patches", { W: function(r4, t4) {
        return t4.forEach(function(t5) {
          for (var e4 = t5.path, u3 = t5.op, a5 = r4, c3 = 0; c3 < e4.length - 1; c3++) {
            var v3 = i3(a5), p3 = e4[c3];
            "string" != typeof p3 && "number" != typeof p3 && (p3 = "" + p3), 0 !== v3 && 1 !== v3 || "__proto__" !== p3 && "constructor" !== p3 || n3(24), "function" == typeof a5 && "prototype" === p3 && n3(24), "object" != typeof (a5 = o3(a5, p3)) && n3(15, e4.join("/"));
          }
          var l3 = i3(a5), d3 = f3(t5.value), h3 = e4[e4.length - 1];
          switch (u3) {
            case "replace":
              switch (l3) {
                case 2:
                  return a5.set(h3, d3);
                case 3:
                  n3(16);
                default:
                  return a5[h3] = d3;
              }
            case s3:
              switch (l3) {
                case 1:
                  return "-" === h3 ? a5.push(d3) : a5.splice(h3, 0, d3);
                case 2:
                  return a5.set(h3, d3);
                case 3:
                  return a5.add(d3);
                default:
                  return a5[h3] = d3;
              }
            case "remove":
              switch (l3) {
                case 1:
                  return a5.splice(h3, 1);
                case 2:
                  return a5.delete(h3);
                case 3:
                  return a5.delete(t5.value);
                default:
                  return delete a5[h3];
              }
            default:
              n3(17, u3);
          }
        }), r4;
      }, F: function(n4, r4, t4, i4) {
        switch (n4.t) {
          case 0:
          case 4:
          case 2:
            return function(n5, r5, t5, i5) {
              var f4 = n5.u, c3 = n5.i;
              e3(n5.N, function(n6, e4) {
                var v3 = o3(f4, n6), p3 = o3(c3, n6), l3 = e4 ? u2(f4, n6) ? "replace" : s3 : "remove";
                if (v3 !== p3 || "replace" !== l3) {
                  var d3 = r5.concat(n6);
                  t5.push("remove" === l3 ? { op: l3, path: d3 } : { op: l3, path: d3, value: p3 }), i5.push(l3 === s3 ? { op: "remove", path: d3 } : "remove" === l3 ? { op: s3, path: d3, value: a4(v3) } : { op: "replace", path: d3, value: a4(v3) });
                }
              });
            }(n4, r4, t4, i4);
          case 5:
          case 1:
            return function(n5, r5, t5, e4) {
              var i5 = n5.u, u3 = n5.N, o4 = n5.i;
              if (o4.length < i5.length) {
                var f4 = [o4, i5];
                i5 = f4[0], o4 = f4[1];
                var c3 = [e4, t5];
                t5 = c3[0], e4 = c3[1];
              }
              for (var v3 = 0; v3 < i5.length; v3++)
                if (u3[v3] && o4[v3] !== i5[v3]) {
                  var p3 = r5.concat([v3]);
                  t5.push({ op: "replace", path: p3, value: a4(o4[v3]) }), e4.push({ op: "replace", path: p3, value: a4(i5[v3]) });
                }
              for (var l3 = i5.length; l3 < o4.length; l3++) {
                var d3 = r5.concat([l3]);
                t5.push({ op: s3, path: d3, value: a4(o4[l3]) });
              }
              i5.length < o4.length && e4.push({ op: "replace", path: r5.concat(["length"]), value: i5.length });
            }(n4, r4, t4, i4);
          case 3:
            return function(n5, r5, t5, e4) {
              var i5 = n5.u, u3 = n5.i, o4 = 0;
              i5.forEach(function(n6) {
                if (!u3.has(n6)) {
                  var i6 = r5.concat([o4]);
                  t5.push({ op: "remove", path: i6, value: n6 }), e4.unshift({ op: s3, path: i6, value: n6 });
                }
                o4++;
              }), o4 = 0, u3.forEach(function(n6) {
                if (!i5.has(n6)) {
                  var u4 = r5.concat([o4]);
                  t5.push({ op: s3, path: u4, value: n6 }), e4.unshift({ op: "remove", path: u4, value: n6 });
                }
                o4++;
              });
            }(n4, r4, t4, i4);
        }
      }, M: function(n4, r4, t4, e4) {
        t4.push({ op: "replace", path: [], value: r4 === B2 ? void 0 : r4 }), e4.push({ op: "replace", path: [], value: n4 });
      } });
    }
    function $2() {
      function r4(n4, r5) {
        function t4() {
          this.constructor = n4;
        }
        f3(n4, r5), n4.prototype = (t4.prototype = r5.prototype, new t4());
      }
      function i4(n4) {
        n4.i || (n4.N = /* @__PURE__ */ new Map(), n4.i = new Map(n4.u));
      }
      function u3(n4) {
        n4.i || (n4.i = /* @__PURE__ */ new Set(), n4.u.forEach(function(r5) {
          if (t3(r5)) {
            var e4 = k2(n4.A.h, r5, n4);
            n4.p.set(r5, e4), n4.i.add(e4);
          } else
            n4.i.add(r5);
        }));
      }
      function o4(r5) {
        r5.O && n3(3, JSON.stringify(s2(r5)));
      }
      var f3 = function(n4, r5) {
        return (f3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n5, r6) {
          n5.__proto__ = r6;
        } || function(n5, r6) {
          for (var t4 in r6)
            r6.hasOwnProperty(t4) && (n5[t4] = r6[t4]);
        })(n4, r5);
      }, a4 = function() {
        function n4(n5, r5) {
          return this[H2] = { t: 2, l: r5, A: r5 ? r5.A : b3(), g: false, R: false, i: void 0, N: void 0, u: n5, k: this, C: false, O: false }, this;
        }
        r4(n4, Map);
        var u4 = n4.prototype;
        return Object.defineProperty(u4, "size", { get: function() {
          return s2(this[H2]).size;
        } }), u4.has = function(n5) {
          return s2(this[H2]).has(n5);
        }, u4.set = function(n5, r5) {
          var t4 = this[H2];
          return o4(t4), s2(t4).has(n5) && s2(t4).get(n5) === r5 || (i4(t4), E2(t4), t4.N.set(n5, true), t4.i.set(n5, r5), t4.N.set(n5, true)), this;
        }, u4.delete = function(n5) {
          if (!this.has(n5))
            return false;
          var r5 = this[H2];
          return o4(r5), i4(r5), E2(r5), r5.u.has(n5) ? r5.N.set(n5, false) : r5.N.delete(n5), r5.i.delete(n5), true;
        }, u4.clear = function() {
          var n5 = this[H2];
          o4(n5), s2(n5).size && (i4(n5), E2(n5), n5.N = /* @__PURE__ */ new Map(), e3(n5.u, function(r5) {
            n5.N.set(r5, false);
          }), n5.i.clear());
        }, u4.forEach = function(n5, r5) {
          var t4 = this;
          s2(this[H2]).forEach(function(e4, i5) {
            n5.call(r5, t4.get(i5), i5, t4);
          });
        }, u4.get = function(n5) {
          var r5 = this[H2];
          o4(r5);
          var e4 = s2(r5).get(n5);
          if (r5.R || !t3(e4))
            return e4;
          if (e4 !== r5.u.get(n5))
            return e4;
          var u5 = k2(r5.A.h, e4, r5);
          return i4(r5), r5.i.set(n5, u5), u5;
        }, u4.keys = function() {
          return s2(this[H2]).keys();
        }, u4.values = function() {
          var n5, r5 = this, t4 = this.keys();
          return (n5 = {})[L2] = function() {
            return r5.values();
          }, n5.next = function() {
            var n6 = t4.next();
            return n6.done ? n6 : { done: false, value: r5.get(n6.value) };
          }, n5;
        }, u4.entries = function() {
          var n5, r5 = this, t4 = this.keys();
          return (n5 = {})[L2] = function() {
            return r5.entries();
          }, n5.next = function() {
            var n6 = t4.next();
            if (n6.done)
              return n6;
            var e4 = r5.get(n6.value);
            return { done: false, value: [n6.value, e4] };
          }, n5;
        }, u4[L2] = function() {
          return this.entries();
        }, n4;
      }(), c3 = function() {
        function n4(n5, r5) {
          return this[H2] = { t: 3, l: r5, A: r5 ? r5.A : b3(), g: false, R: false, i: void 0, u: n5, k: this, p: /* @__PURE__ */ new Map(), O: false, C: false }, this;
        }
        r4(n4, Set);
        var t4 = n4.prototype;
        return Object.defineProperty(t4, "size", { get: function() {
          return s2(this[H2]).size;
        } }), t4.has = function(n5) {
          var r5 = this[H2];
          return o4(r5), r5.i ? !!r5.i.has(n5) || !(!r5.p.has(n5) || !r5.i.has(r5.p.get(n5))) : r5.u.has(n5);
        }, t4.add = function(n5) {
          var r5 = this[H2];
          return o4(r5), this.has(n5) || (u3(r5), E2(r5), r5.i.add(n5)), this;
        }, t4.delete = function(n5) {
          if (!this.has(n5))
            return false;
          var r5 = this[H2];
          return o4(r5), u3(r5), E2(r5), r5.i.delete(n5) || !!r5.p.has(n5) && r5.i.delete(r5.p.get(n5));
        }, t4.clear = function() {
          var n5 = this[H2];
          o4(n5), s2(n5).size && (u3(n5), E2(n5), n5.i.clear());
        }, t4.values = function() {
          var n5 = this[H2];
          return o4(n5), u3(n5), n5.i.values();
        }, t4.entries = function() {
          var n5 = this[H2];
          return o4(n5), u3(n5), n5.i.entries();
        }, t4.keys = function() {
          return this.values();
        }, t4[L2] = function() {
          return this.values();
        }, t4.forEach = function(n5, r5) {
          for (var t5 = this.values(), e4 = t5.next(); !e4.done; )
            n5.call(r5, e4.value, e4.value, this), e4 = t5.next();
        }, n4;
      }();
      _2("MapSet", { K: function(n4, r5) {
        return new a4(n4, r5);
      }, $: function(n4, r5) {
        return new c3(n4, r5);
      } });
    }
    var C2;
    Object.defineProperty(exports, "__esModule", { value: true });
    var I2;
    var J2 = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
    var W2 = "undefined" != typeof Map;
    var X2 = "undefined" != typeof Set;
    var q2 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
    var B2 = J2 ? Symbol.for("immer-nothing") : ((C2 = {})["immer-nothing"] = true, C2);
    var G2 = J2 ? Symbol.for("immer-draftable") : "__$immer_draftable";
    var H2 = J2 ? Symbol.for("immer-state") : "__$immer_state";
    var L2 = "undefined" != typeof Symbol && Symbol.iterator || "@@iterator";
    var Q2 = "" + Object.prototype.constructor;
    var T2 = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n4) {
      return Object.getOwnPropertyNames(n4).concat(Object.getOwnPropertySymbols(n4));
    } : Object.getOwnPropertyNames;
    var U2 = Object.getOwnPropertyDescriptors || function(n4) {
      var r4 = {};
      return T2(n4).forEach(function(t4) {
        r4[t4] = Object.getOwnPropertyDescriptor(n4, t4);
      }), r4;
    };
    var V2 = {};
    var Y2 = { get: function(n4, r4) {
      if (r4 === H2)
        return n4;
      var e4 = s2(n4);
      if (!u2(e4, r4))
        return function(n5, r5, t4) {
          var e5, i5 = z2(r5, t4);
          return i5 ? "value" in i5 ? i5.value : null === (e5 = i5.get) || void 0 === e5 ? void 0 : e5.call(n5.k) : void 0;
        }(n4, e4, r4);
      var i4 = e4[r4];
      return n4.R || !t3(i4) ? i4 : i4 === A2(n4.u, r4) ? (R2(n4), n4.i[r4] = k2(n4.A.h, i4, n4)) : i4;
    }, has: function(n4, r4) {
      return r4 in s2(n4);
    }, ownKeys: function(n4) {
      return Reflect.ownKeys(s2(n4));
    }, set: function(n4, r4, t4) {
      var e4 = z2(s2(n4), r4);
      if (null == e4 ? void 0 : e4.set)
        return e4.set.call(n4.k, t4), true;
      if (!n4.g) {
        var i4 = A2(s2(n4), r4), o4 = null == i4 ? void 0 : i4[H2];
        if (o4 && o4.u === t4)
          return n4.i[r4] = t4, n4.N[r4] = false, true;
        if (a3(t4, i4) && (void 0 !== t4 || u2(n4.u, r4)))
          return true;
        R2(n4), E2(n4);
      }
      return n4.i[r4] === t4 && (void 0 !== t4 || r4 in n4.i) || Number.isNaN(t4) && Number.isNaN(n4.i[r4]) || (n4.i[r4] = t4, n4.N[r4] = true), true;
    }, deleteProperty: function(n4, r4) {
      return void 0 !== A2(n4.u, r4) || r4 in n4.u ? (n4.N[r4] = false, R2(n4), E2(n4)) : delete n4.N[r4], n4.i && delete n4.i[r4], true;
    }, getOwnPropertyDescriptor: function(n4, r4) {
      var t4 = s2(n4), e4 = Reflect.getOwnPropertyDescriptor(t4, r4);
      return e4 ? { writable: true, configurable: 1 !== n4.t || "length" !== r4, enumerable: e4.enumerable, value: t4[r4] } : e4;
    }, defineProperty: function() {
      n3(11);
    }, getPrototypeOf: function(n4) {
      return Object.getPrototypeOf(n4.u);
    }, setPrototypeOf: function() {
      n3(12);
    } };
    var Z2 = {};
    e3(Y2, function(n4, r4) {
      Z2[n4] = function() {
        return arguments[0] = arguments[0][0], r4.apply(this, arguments);
      };
    }), Z2.deleteProperty = function(n4, r4) {
      return Z2.set.call(this, n4, r4, void 0);
    }, Z2.set = function(n4, r4, t4) {
      return Y2.set.call(this, n4[0], r4, t4, n4[0]);
    };
    var nn = function() {
      function e4(r4) {
        var e5 = this;
        this.S = q2, this.D = true, this.produce = function(r5, i5, u3) {
          if ("function" == typeof r5 && "function" != typeof i5) {
            var o4 = i5;
            i5 = r5;
            var f3 = e5;
            return function(n4) {
              var r6 = this;
              void 0 === n4 && (n4 = o4);
              for (var t4 = arguments.length, e6 = Array(t4 > 1 ? t4 - 1 : 0), u4 = 1; u4 < t4; u4++)
                e6[u4 - 1] = arguments[u4];
              return f3.produce(n4, function(n5) {
                var t5;
                return (t5 = i5).call.apply(t5, [r6, n5].concat(e6));
              });
            };
          }
          var a4;
          if ("function" != typeof i5 && n3(6), void 0 !== u3 && "function" != typeof u3 && n3(7), t3(r5)) {
            var c3 = x3(e5), v3 = k2(e5, r5, void 0), s3 = true;
            try {
              a4 = i5(v3), s3 = false;
            } finally {
              s3 ? j2(c3) : O2(c3);
            }
            return "undefined" != typeof Promise && a4 instanceof Promise ? a4.then(function(n4) {
              return m2(c3, u3), S2(n4, c3);
            }, function(n4) {
              throw j2(c3), n4;
            }) : (m2(c3, u3), S2(a4, c3));
          }
          if (!r5 || "object" != typeof r5) {
            if (void 0 === (a4 = i5(r5)) && (a4 = r5), a4 === B2 && (a4 = void 0), e5.D && l2(a4, true), u3) {
              var p3 = [], d3 = [];
              y("Patches").M(r5, a4, p3, d3), u3(p3, d3);
            }
            return a4;
          }
          n3(21, r5);
        }, this.produceWithPatches = function(n4, r5) {
          if ("function" == typeof n4)
            return function(r6) {
              for (var t5 = arguments.length, i6 = Array(t5 > 1 ? t5 - 1 : 0), u4 = 1; u4 < t5; u4++)
                i6[u4 - 1] = arguments[u4];
              return e5.produceWithPatches(r6, function(r7) {
                return n4.apply(void 0, [r7].concat(i6));
              });
            };
          var t4, i5, u3 = e5.produce(n4, r5, function(n5, r6) {
            t4 = n5, i5 = r6;
          });
          return "undefined" != typeof Promise && u3 instanceof Promise ? u3.then(function(n5) {
            return [n5, t4, i5];
          }) : [u3, t4, i5];
        }, "boolean" == typeof (null == r4 ? void 0 : r4.useProxies) && this.setUseProxies(r4.useProxies), "boolean" == typeof (null == r4 ? void 0 : r4.autoFreeze) && this.setAutoFreeze(r4.autoFreeze);
      }
      var i4 = e4.prototype;
      return i4.createDraft = function(e5) {
        t3(e5) || n3(8), r3(e5) && (e5 = F2(e5));
        var i5 = x3(this), u3 = k2(this, e5, void 0);
        return u3[H2].C = true, O2(i5), u3;
      }, i4.finishDraft = function(n4, r4) {
        var t4 = (n4 && n4[H2]).A;
        return m2(t4, r4), S2(void 0, t4);
      }, i4.setAutoFreeze = function(n4) {
        this.D = n4;
      }, i4.setUseProxies = function(r4) {
        r4 && !q2 && n3(20), this.S = r4;
      }, i4.applyPatches = function(n4, t4) {
        var e5;
        for (e5 = t4.length - 1; e5 >= 0; e5--) {
          var i5 = t4[e5];
          if (0 === i5.path.length && "replace" === i5.op) {
            n4 = i5.value;
            break;
          }
        }
        e5 > -1 && (t4 = t4.slice(e5 + 1));
        var u3 = y("Patches").W;
        return r3(n4) ? u3(n4, t4) : this.produce(n4, function(n5) {
          return u3(n5, t4);
        });
      }, e4;
    }();
    var rn = new nn();
    var tn = rn.produce;
    var en = rn.produceWithPatches.bind(rn);
    var un = rn.setAutoFreeze.bind(rn);
    var on = rn.setUseProxies.bind(rn);
    var fn = rn.applyPatches.bind(rn);
    var an = rn.createDraft.bind(rn);
    var cn = rn.finishDraft.bind(rn);
    exports.Immer = nn, exports.applyPatches = fn, exports.castDraft = function(n4) {
      return n4;
    }, exports.castImmutable = function(n4) {
      return n4;
    }, exports.createDraft = an, exports.current = F2, exports.default = tn, exports.enableAllPlugins = function() {
      D2(), $2(), K2();
    }, exports.enableES5 = D2, exports.enableMapSet = $2, exports.enablePatches = K2, exports.finishDraft = cn, exports.freeze = l2, exports.immerable = G2, exports.isDraft = r3, exports.isDraftable = t3, exports.nothing = B2, exports.original = function(t4) {
      return r3(t4) || n3(23, t4), t4[H2].u;
    }, exports.produce = tn, exports.produceWithPatches = en, exports.setAutoFreeze = un, exports.setUseProxies = on;
  }
});

// ../../node_modules/immer/dist/immer.cjs.development.js
var require_immer_cjs_development = __commonJS({
  "../../node_modules/immer/dist/immer.cjs.development.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ref;
    var hasSymbol = typeof Symbol !== "undefined" && typeof /* @__PURE__ */ Symbol("x") === "symbol";
    var hasMap = typeof Map !== "undefined";
    var hasSet = typeof Set !== "undefined";
    var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
    var NOTHING = hasSymbol ? /* @__PURE__ */ Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
    var DRAFTABLE = hasSymbol ? /* @__PURE__ */ Symbol.for("immer-draftable") : "__$immer_draftable";
    var DRAFT_STATE = hasSymbol ? /* @__PURE__ */ Symbol.for("immer-state") : "__$immer_state";
    var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
    var errors = {
      0: "Illegal state",
      1: "Immer drafts cannot have computed properties",
      2: "This object has been frozen and should not be mutated",
      3: function _2(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      5: "Immer forbids circular references",
      6: "The first or second argument to `produce` must be a function",
      7: "The third argument to `produce` must be a function or undefined",
      8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
      10: "The given draft is already finalized",
      11: "Object.defineProperty() cannot be used on an Immer draft",
      12: "Object.setPrototypeOf() cannot be used on an Immer draft",
      13: "Immer only supports deleting array indices",
      14: "Immer only supports setting array indices and the 'length' property",
      15: function _2(path2) {
        return "Cannot apply patch, path doesn't resolve: " + path2;
      },
      16: 'Sets cannot have "replace" patches.',
      17: function _2(op) {
        return "Unsupported patch operation: " + op;
      },
      18: function _2(plugin) {
        return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
      },
      20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
      21: function _2(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
      },
      22: function _2(thing) {
        return "'current' expects a draft, got: " + thing;
      },
      23: function _2(thing) {
        return "'original' expects a draft, got: " + thing;
      },
      24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    };
    function die(error) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      {
        var e3 = errors[error];
        var msg = !e3 ? "unknown error nr: " + error : typeof e3 === "function" ? e3.apply(null, args) : e3;
        throw new Error("[Immer] " + msg);
      }
    }
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _value$constructor;
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = /* @__PURE__ */ Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function original(value) {
      if (!isDraft(value))
        die(23, value);
      return value[DRAFT_STATE].base_;
    }
    var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function(obj) {
      return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
    } : (
      /* istanbul ignore next */
      Object.getOwnPropertyNames
    );
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
      var res = {};
      ownKeys(target).forEach(function(key) {
        res[key] = Object.getOwnPropertyDescriptor(target, key);
      });
      return res;
    };
    function each(obj, iter, enumerableOnly) {
      if (enumerableOnly === void 0) {
        enumerableOnly = false;
      }
      if (getArchtype(obj) === 0) {
        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {
          if (!enumerableOnly || typeof key !== "symbol")
            iter(key, obj[key], obj);
        });
      } else {
        obj.forEach(function(entry, index3) {
          return iter(index3, entry, obj);
        });
      }
    }
    function getArchtype(thing) {
      var state = thing[DRAFT_STATE];
      return state ? state.type_ > 3 ? state.type_ - 4 : state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function get4(thing, prop) {
      return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
    }
    function set(thing, propOrOldValue, value) {
      var t3 = getArchtype(thing);
      if (t3 === 2)
        thing.set(propOrOldValue, value);
      else if (t3 === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x3, y) {
      if (x3 === y) {
        return x3 !== 0 || 1 / x3 === 1 / y;
      } else {
        return x3 !== x3 && y !== y;
      }
    }
    function isMap(target) {
      return hasMap && target instanceof Map;
    }
    function isSet(target) {
      return hasSet && target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base) {
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      var descriptors = getOwnPropertyDescriptors(base);
      delete descriptors[DRAFT_STATE];
      var keys = ownKeys(descriptors);
      for (var i3 = 0; i3 < keys.length; i3++) {
        var key = keys[i3];
        var desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(Object.getPrototypeOf(base), descriptors);
    }
    function freeze(obj, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        each(obj, function(key, value) {
          return freeze(value, true);
        }, true);
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      if (obj == null || typeof obj !== "object")
        return true;
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      var plugin = plugins[pluginKey];
      if (!plugin) {
        die(18, pluginKey);
      }
      return plugin;
    }
    function loadPlugin(pluginKey, implementation) {
      if (!plugins[pluginKey])
        plugins[pluginKey] = implementation;
    }
    var currentScope;
    function getCurrentScope() {
      if (!currentScope)
        die(0);
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      var state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      var baseDraft = scope.drafts_[0];
      var isReplaced = result !== void 0 && result !== baseDraft;
      if (!scope.immer_.useProxies_)
        getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path2) {
      if (isFrozen(value))
        return value;
      var state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          function(key, childValue) {
            return finalizeProperty(rootScope, state, value, key, childValue, path2);
          },
          true
          // See #590, don't recurse into non-enumerable of non drafted objects
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        var result = (
          // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
          state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_
        );
        var resultEach = result;
        var isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(resultEach, function(key, childValue) {
          return finalizeProperty(rootScope, state, result, key, childValue, path2, isSet2);
        });
        maybeFreeze(rootScope, result, false);
        if (path2 && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(state, path2, rootScope.patches_, rootScope.inversePatches_);
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
      if (childValue === targetObject)
        die(5);
      if (isDraft(childValue)) {
        var path2 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        var res = finalize(rootScope, childValue, path2);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if (!parentState || !parentState.scope_.parent_)
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      var isArray = Array.isArray(base);
      var state = {
        type_: isArray ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      var target = state;
      var traps2 = objectTraps;
      if (isArray) {
        target = [state];
        traps2 = arrayTraps;
      }
      var _Proxy$revocable = Proxy.revocable(target, traps2), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get: function get5(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        var source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        var value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
        }
        return value;
      },
      has: function has2(state, prop) {
        return prop in latest(state);
      },
      ownKeys: function ownKeys2(state) {
        return Reflect.ownKeys(latest(state));
      },
      set: function set2(state, prop, value) {
        var desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          var current2 = peek(latest(state), prop);
          var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty: function deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_)
          delete state.copy_[prop];
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
        var owner = latest(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty: function defineProperty() {
        die(11);
      },
      getPrototypeOf: function getPrototypeOf(state) {
        return Object.getPrototypeOf(state.base_);
      },
      setPrototypeOf: function setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, function(key, fn) {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      var state = draft[DRAFT_STATE];
      var source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      var _desc$get;
      var desc = getDescriptorFromProto(source, prop);
      return desc ? "value" in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      var proto = Object.getPrototypeOf(source);
      while (proto) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = Object.getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_);
      }
    }
    var Immer = /* @__PURE__ */ function() {
      function Immer2(config) {
        var _this = this;
        this.useProxies_ = hasProxies;
        this.autoFreeze_ = true;
        this.produce = function(base, recipe, patchListener) {
          if (typeof base === "function" && typeof recipe !== "function") {
            var defaultBase = recipe;
            recipe = base;
            var self2 = _this;
            return function curriedProduce(base2) {
              var _this2 = this;
              if (base2 === void 0) {
                base2 = defaultBase;
              }
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return self2.produce(base2, function(draft) {
                var _recipe;
                return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
              });
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          var result;
          if (isDraftable(base)) {
            var scope = enterScope(_this);
            var proxy = createProxy(_this, base, void 0);
            var hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then(function(result2) {
                usePatchesInScope(scope, patchListener);
                return processResult(result2, scope);
              }, function(error) {
                revokeScope(scope);
                throw error;
              });
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (_this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              var p2 = [];
              var ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
              patchListener(p2, ip);
            }
            return result;
          } else
            die(21, base);
        };
        this.produceWithPatches = function(base, recipe) {
          if (typeof base === "function") {
            return function(state) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              return _this.produceWithPatches(state, function(draft) {
                return base.apply(void 0, [draft].concat(args));
              });
            };
          }
          var patches, inversePatches;
          var result = _this.produce(base, recipe, function(p2, ip) {
            patches = p2;
            inversePatches = ip;
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then(function(nextState) {
              return [nextState, patches, inversePatches];
            });
          }
          return [result, patches, inversePatches];
        };
        if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean")
          this.setUseProxies(config.useProxies);
        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean")
          this.setAutoFreeze(config.autoFreeze);
      }
      var _proto = Immer2.prototype;
      _proto.createDraft = function createDraft2(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        var scope = enterScope(this);
        var proxy = createProxy(this, base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      };
      _proto.finishDraft = function finishDraft2(draft, patchListener) {
        var state = draft && draft[DRAFT_STATE];
        {
          if (!state || !state.isManual_)
            die(9);
          if (state.finalized_)
            die(10);
        }
        var scope = state.scope_;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      };
      _proto.setAutoFreeze = function setAutoFreeze2(value) {
        this.autoFreeze_ = value;
      };
      _proto.setUseProxies = function setUseProxies2(value) {
        if (value && !hasProxies) {
          die(20);
        }
        this.useProxies_ = value;
      };
      _proto.applyPatches = function applyPatches2(base, patches) {
        var i3;
        for (i3 = patches.length - 1; i3 >= 0; i3--) {
          var patch = patches[i3];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i3 > -1) {
          patches = patches.slice(i3 + 1);
        }
        var applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(base, function(draft) {
          return applyPatchesImpl(draft, patches);
        });
      };
      return Immer2;
    }();
    function createProxy(immer2, value, parent) {
      var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer2.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
      var scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(22, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value))
        return value;
      var state = value[DRAFT_STATE];
      var copy;
      var archType = getArchtype(value);
      if (state) {
        if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state)))
          return state.base_;
        state.finalized_ = true;
        copy = copyHelper(value, archType);
        state.finalized_ = false;
      } else {
        copy = copyHelper(value, archType);
      }
      each(copy, function(key, childValue) {
        if (state && get4(state.base_, key) === childValue)
          return;
        set(copy, key, currentImpl(childValue));
      });
      return archType === 3 ? new Set(copy) : copy;
    }
    function copyHelper(value, archType) {
      switch (archType) {
        case 2:
          return new Map(value);
        case 3:
          return Array.from(value);
      }
      return shallowCopy(value);
    }
    function enableES5() {
      function willFinalizeES5_(scope, result, isReplaced) {
        if (!isReplaced) {
          if (scope.patches_) {
            markChangesRecursively(scope.drafts_[0]);
          }
          markChangesSweep(scope.drafts_);
        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
          markChangesSweep(scope.drafts_);
        }
      }
      function createES5Draft(isArray, base) {
        if (isArray) {
          var draft = new Array(base.length);
          for (var i3 = 0; i3 < base.length; i3++) {
            Object.defineProperty(draft, "" + i3, proxyProperty(i3, true));
          }
          return draft;
        } else {
          var _descriptors = getOwnPropertyDescriptors(base);
          delete _descriptors[DRAFT_STATE];
          var keys = ownKeys(_descriptors);
          for (var _i = 0; _i < keys.length; _i++) {
            var key = keys[_i];
            _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
          }
          return Object.create(Object.getPrototypeOf(base), _descriptors);
        }
      }
      function createES5Proxy_(base, parent) {
        var isArray = Array.isArray(base);
        var draft = createES5Draft(isArray, base);
        var state = {
          type_: isArray ? 5 : 4,
          scope_: parent ? parent.scope_ : getCurrentScope(),
          modified_: false,
          finalized_: false,
          assigned_: {},
          parent_: parent,
          // base is the object we are drafting
          base_: base,
          // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
          draft_: draft,
          copy_: null,
          revoked_: false,
          isManual_: false
        };
        Object.defineProperty(draft, DRAFT_STATE, {
          value: state,
          // enumerable: false <- the default
          writable: true
        });
        return draft;
      }
      var descriptors = {};
      function proxyProperty(prop, enumerable) {
        var desc = descriptors[prop];
        if (desc) {
          desc.enumerable = enumerable;
        } else {
          descriptors[prop] = desc = {
            configurable: true,
            enumerable,
            get: function get5() {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              return objectTraps.get(state, prop);
            },
            set: function set2(value) {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              objectTraps.set(state, prop, value);
            }
          };
        }
        return desc;
      }
      function markChangesSweep(drafts) {
        for (var i3 = drafts.length - 1; i3 >= 0; i3--) {
          var state = drafts[i3][DRAFT_STATE];
          if (!state.modified_) {
            switch (state.type_) {
              case 5:
                if (hasArrayChanges(state))
                  markChanged(state);
                break;
              case 4:
                if (hasObjectChanges(state))
                  markChanged(state);
                break;
            }
          }
        }
      }
      function markChangesRecursively(object) {
        if (!object || typeof object !== "object")
          return;
        var state = object[DRAFT_STATE];
        if (!state)
          return;
        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;
        if (type_ === 4) {
          each(draft_, function(key) {
            if (key === DRAFT_STATE)
              return;
            if (base_[key] === void 0 && !has(base_, key)) {
              assigned_[key] = true;
              markChanged(state);
            } else if (!assigned_[key]) {
              markChangesRecursively(draft_[key]);
            }
          });
          each(base_, function(key) {
            if (draft_[key] === void 0 && !has(draft_, key)) {
              assigned_[key] = false;
              markChanged(state);
            }
          });
        } else if (type_ === 5) {
          if (hasArrayChanges(state)) {
            markChanged(state);
            assigned_.length = true;
          }
          if (draft_.length < base_.length) {
            for (var i3 = draft_.length; i3 < base_.length; i3++) {
              assigned_[i3] = false;
            }
          } else {
            for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
              assigned_[_i2] = true;
            }
          }
          var min = Math.min(draft_.length, base_.length);
          for (var _i3 = 0; _i3 < min; _i3++) {
            if (!draft_.hasOwnProperty(_i3)) {
              assigned_[_i3] = true;
            }
            if (assigned_[_i3] === void 0)
              markChangesRecursively(draft_[_i3]);
          }
        }
      }
      function hasObjectChanges(state) {
        var base_ = state.base_, draft_ = state.draft_;
        var keys = ownKeys(draft_);
        for (var i3 = keys.length - 1; i3 >= 0; i3--) {
          var key = keys[i3];
          if (key === DRAFT_STATE)
            continue;
          var baseValue = base_[key];
          if (baseValue === void 0 && !has(base_, key)) {
            return true;
          } else {
            var value = draft_[key];
            var _state = value && value[DRAFT_STATE];
            if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
              return true;
            }
          }
        }
        var baseIsDraft = !!base_[DRAFT_STATE];
        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1);
      }
      function hasArrayChanges(state) {
        var draft_ = state.draft_;
        if (draft_.length !== state.base_.length)
          return true;
        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);
        if (descriptor && !descriptor.get)
          return true;
        for (var i3 = 0; i3 < draft_.length; i3++) {
          if (!draft_.hasOwnProperty(i3))
            return true;
        }
        return false;
      }
      function hasChanges_(state) {
        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("ES5", {
        createES5Proxy_,
        willFinalizeES5_,
        hasChanges_
      });
    }
    function enablePatches() {
      var REPLACE = "replace";
      var ADD = "add";
      var REMOVE = "remove";
      function generatePatches_(state, basePath, patches, inversePatches) {
        switch (state.type_) {
          case 0:
          case 4:
          case 2:
            return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
          case 5:
          case 1:
            return generateArrayPatches(state, basePath, patches, inversePatches);
          case 3:
            return generateSetPatches(state, basePath, patches, inversePatches);
        }
      }
      function generateArrayPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, assigned_ = state.assigned_;
        var copy_ = state.copy_;
        if (copy_.length < base_.length) {
          var _ref2 = [copy_, base_];
          base_ = _ref2[0];
          copy_ = _ref2[1];
          var _ref22 = [inversePatches, patches];
          patches = _ref22[0];
          inversePatches = _ref22[1];
        }
        for (var i3 = 0; i3 < base_.length; i3++) {
          if (assigned_[i3] && copy_[i3] !== base_[i3]) {
            var path2 = basePath.concat([i3]);
            patches.push({
              op: REPLACE,
              path: path2,
              // Need to maybe clone it, as it can in fact be the original value
              // due to the base/copy inversion at the start of this function
              value: clonePatchValueIfNeeded(copy_[i3])
            });
            inversePatches.push({
              op: REPLACE,
              path: path2,
              value: clonePatchValueIfNeeded(base_[i3])
            });
          }
        }
        for (var _i = base_.length; _i < copy_.length; _i++) {
          var _path = basePath.concat([_i]);
          patches.push({
            op: ADD,
            path: _path,
            // Need to maybe clone it, as it can in fact be the original value
            // due to the base/copy inversion at the start of this function
            value: clonePatchValueIfNeeded(copy_[_i])
          });
        }
        if (base_.length < copy_.length) {
          inversePatches.push({
            op: REPLACE,
            path: basePath.concat(["length"]),
            value: base_.length
          });
        }
      }
      function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        each(state.assigned_, function(key, assignedValue) {
          var origValue = get4(base_, key);
          var value = get4(copy_, key);
          var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
          if (origValue === value && op === REPLACE)
            return;
          var path2 = basePath.concat(key);
          patches.push(op === REMOVE ? {
            op,
            path: path2
          } : {
            op,
            path: path2,
            value
          });
          inversePatches.push(op === ADD ? {
            op: REMOVE,
            path: path2
          } : op === REMOVE ? {
            op: ADD,
            path: path2,
            value: clonePatchValueIfNeeded(origValue)
          } : {
            op: REPLACE,
            path: path2,
            value: clonePatchValueIfNeeded(origValue)
          });
        });
      }
      function generateSetPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        var i3 = 0;
        base_.forEach(function(value) {
          if (!copy_.has(value)) {
            var path2 = basePath.concat([i3]);
            patches.push({
              op: REMOVE,
              path: path2,
              value
            });
            inversePatches.unshift({
              op: ADD,
              path: path2,
              value
            });
          }
          i3++;
        });
        i3 = 0;
        copy_.forEach(function(value) {
          if (!base_.has(value)) {
            var path2 = basePath.concat([i3]);
            patches.push({
              op: ADD,
              path: path2,
              value
            });
            inversePatches.unshift({
              op: REMOVE,
              path: path2,
              value
            });
          }
          i3++;
        });
      }
      function generateReplacementPatches_(baseValue, replacement2, patches, inversePatches) {
        patches.push({
          op: REPLACE,
          path: [],
          value: replacement2 === NOTHING ? void 0 : replacement2
        });
        inversePatches.push({
          op: REPLACE,
          path: [],
          value: baseValue
        });
      }
      function applyPatches_(draft, patches) {
        patches.forEach(function(patch) {
          var path2 = patch.path, op = patch.op;
          var base = draft;
          for (var i3 = 0; i3 < path2.length - 1; i3++) {
            var parentType = getArchtype(base);
            var p2 = path2[i3];
            if (typeof p2 !== "string" && typeof p2 !== "number") {
              p2 = "" + p2;
            }
            if ((parentType === 0 || parentType === 1) && (p2 === "__proto__" || p2 === "constructor"))
              die(24);
            if (typeof base === "function" && p2 === "prototype")
              die(24);
            base = get4(base, p2);
            if (typeof base !== "object")
              die(15, path2.join("/"));
          }
          var type = getArchtype(base);
          var value = deepClonePatchValue(patch.value);
          var key = path2[path2.length - 1];
          switch (op) {
            case REPLACE:
              switch (type) {
                case 2:
                  return base.set(key, value);
                case 3:
                  die(16);
                default:
                  return base[key] = value;
              }
            case ADD:
              switch (type) {
                case 1:
                  return key === "-" ? base.push(value) : base.splice(key, 0, value);
                case 2:
                  return base.set(key, value);
                case 3:
                  return base.add(value);
                default:
                  return base[key] = value;
              }
            case REMOVE:
              switch (type) {
                case 1:
                  return base.splice(key, 1);
                case 2:
                  return base.delete(key);
                case 3:
                  return base.delete(patch.value);
                default:
                  return delete base[key];
              }
            default:
              die(17, op);
          }
        });
        return draft;
      }
      function deepClonePatchValue(obj) {
        if (!isDraftable(obj))
          return obj;
        if (Array.isArray(obj))
          return obj.map(deepClonePatchValue);
        if (isMap(obj))
          return new Map(Array.from(obj.entries()).map(function(_ref3) {
            var k2 = _ref3[0], v2 = _ref3[1];
            return [k2, deepClonePatchValue(v2)];
          }));
        if (isSet(obj))
          return new Set(Array.from(obj).map(deepClonePatchValue));
        var cloned = Object.create(Object.getPrototypeOf(obj));
        for (var key in obj) {
          cloned[key] = deepClonePatchValue(obj[key]);
        }
        if (has(obj, DRAFTABLE))
          cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
      }
      function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
          return deepClonePatchValue(obj);
        } else
          return obj;
      }
      loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
      });
    }
    function enableMapSet() {
      var _extendStatics = function extendStatics3(d2, b3) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4) {
            if (b4.hasOwnProperty(p2))
              d3[p2] = b4[p2];
          }
        };
        return _extendStatics(d2, b3);
      };
      function __extends3(d2, b3) {
        _extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = // @ts-ignore
        (__.prototype = b3.prototype, new __());
      }
      var DraftMap = function(_super) {
        __extends3(DraftMap2, _super);
        function DraftMap2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 2,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            assigned_: void 0,
            base_: target,
            draft_: this,
            isManual_: false,
            revoked_: false
          };
          return this;
        }
        var p2 = DraftMap2.prototype;
        Object.defineProperty(p2, "size", {
          get: function get5() {
            return latest(this[DRAFT_STATE]).size;
          }
          // enumerable: false,
          // configurable: true
        });
        p2.has = function(key) {
          return latest(this[DRAFT_STATE]).has(key);
        };
        p2.set = function(key, value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!latest(state).has(key) || latest(state).get(key) !== value) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_.set(key, true);
            state.copy_.set(key, value);
            state.assigned_.set(key, true);
          }
          return this;
        };
        p2.delete = function(key) {
          if (!this.has(key)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareMapCopy(state);
          markChanged(state);
          if (state.base_.has(key)) {
            state.assigned_.set(key, false);
          } else {
            state.assigned_.delete(key);
          }
          state.copy_.delete(key);
          return true;
        };
        p2.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_ = /* @__PURE__ */ new Map();
            each(state.base_, function(key) {
              state.assigned_.set(key, false);
            });
            state.copy_.clear();
          }
        };
        p2.forEach = function(cb, thisArg) {
          var _this = this;
          var state = this[DRAFT_STATE];
          latest(state).forEach(function(_value, key, _map) {
            cb.call(thisArg, _this.get(key), key, _this);
          });
        };
        p2.get = function(key) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          var value = latest(state).get(key);
          if (state.finalized_ || !isDraftable(value)) {
            return value;
          }
          if (value !== state.base_.get(key)) {
            return value;
          }
          var draft = createProxy(state.scope_.immer_, value, state);
          prepareMapCopy(state);
          state.copy_.set(key, draft);
          return draft;
        };
        p2.keys = function() {
          return latest(this[DRAFT_STATE]).keys();
        };
        p2.values = function() {
          var _this2 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this2.values();
          }, _ref2.next = function next() {
            var r3 = iterator.next();
            if (r3.done)
              return r3;
            var value = _this2.get(r3.value);
            return {
              done: false,
              value
            };
          }, _ref2;
        };
        p2.entries = function() {
          var _this3 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this3.entries();
          }, _ref2.next = function next() {
            var r3 = iterator.next();
            if (r3.done)
              return r3;
            var value = _this3.get(r3.value);
            return {
              done: false,
              value: [r3.value, value]
            };
          }, _ref2;
        };
        p2[iteratorSymbol] = function() {
          return this.entries();
        };
        return DraftMap2;
      }(Map);
      function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
      }
      function prepareMapCopy(state) {
        if (!state.copy_) {
          state.assigned_ = /* @__PURE__ */ new Map();
          state.copy_ = new Map(state.base_);
        }
      }
      var DraftSet = function(_super) {
        __extends3(DraftSet2, _super);
        function DraftSet2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 3,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            base_: target,
            draft_: this,
            drafts_: /* @__PURE__ */ new Map(),
            revoked_: false,
            isManual_: false
          };
          return this;
        }
        var p2 = DraftSet2.prototype;
        Object.defineProperty(p2, "size", {
          get: function get5() {
            return latest(this[DRAFT_STATE]).size;
          }
          // enumerable: true,
        });
        p2.has = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!state.copy_) {
            return state.base_.has(value);
          }
          if (state.copy_.has(value))
            return true;
          if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
            return true;
          return false;
        };
        p2.add = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!this.has(value)) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.add(value);
          }
          return this;
        };
        p2.delete = function(value) {
          if (!this.has(value)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          markChanged(state);
          return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
            /* istanbul ignore next */
            false
          ));
        };
        p2.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.clear();
          }
        };
        p2.values = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.values();
        };
        p2.entries = function entries() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.entries();
        };
        p2.keys = function() {
          return this.values();
        };
        p2[iteratorSymbol] = function() {
          return this.values();
        };
        p2.forEach = function forEach(cb, thisArg) {
          var iterator = this.values();
          var result = iterator.next();
          while (!result.done) {
            cb.call(thisArg, result.value, result.value, this);
            result = iterator.next();
          }
        };
        return DraftSet2;
      }(Set);
      function proxySet_(target, parent) {
        return new DraftSet(target, parent);
      }
      function prepareSetCopy(state) {
        if (!state.copy_) {
          state.copy_ = /* @__PURE__ */ new Set();
          state.base_.forEach(function(value) {
            if (isDraftable(value)) {
              var draft = createProxy(state.scope_.immer_, value, state);
              state.drafts_.set(value, draft);
              state.copy_.add(draft);
            } else {
              state.copy_.add(value);
            }
          });
        }
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
      });
    }
    function enableAllPlugins() {
      enableES5();
      enableMapSet();
      enablePatches();
    }
    var immer = /* @__PURE__ */ new Immer();
    var produce = immer.produce;
    var produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);
    var setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);
    var setUseProxies = /* @__PURE__ */ immer.setUseProxies.bind(immer);
    var applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);
    var createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);
    var finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);
    function castDraft(value) {
      return value;
    }
    function castImmutable(value) {
      return value;
    }
    exports.Immer = Immer;
    exports.applyPatches = applyPatches;
    exports.castDraft = castDraft;
    exports.castImmutable = castImmutable;
    exports.createDraft = createDraft;
    exports.current = current;
    exports.default = produce;
    exports.enableAllPlugins = enableAllPlugins;
    exports.enableES5 = enableES5;
    exports.enableMapSet = enableMapSet;
    exports.enablePatches = enablePatches;
    exports.finishDraft = finishDraft;
    exports.freeze = freeze;
    exports.immerable = DRAFTABLE;
    exports.isDraft = isDraft;
    exports.isDraftable = isDraftable;
    exports.nothing = NOTHING;
    exports.original = original;
    exports.produce = produce;
    exports.produceWithPatches = produceWithPatches;
    exports.setAutoFreeze = setAutoFreeze;
    exports.setUseProxies = setUseProxies;
  }
});

// ../../node_modules/immer/dist/index.js
var require_dist4 = __commonJS({
  "../../node_modules/immer/dist/index.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_immer_cjs_production_min();
    } else {
      module2.exports = require_immer_cjs_development();
    }
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports, module2) {
    "use strict";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports, module2) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports, module2) {
    "use strict";
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e3) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports, module2) {
    "use strict";
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports, module2) {
    "use strict";
    function isObject4(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject4;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObject4 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction3(value) {
      if (!isObject4(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction3;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports, module2) {
    "use strict";
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports, module2) {
    "use strict";
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports, module2) {
    "use strict";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e3) {
        }
        try {
          return func + "";
        } catch (e3) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports, module2) {
    "use strict";
    var isFunction3 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject4 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject4(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports, module2) {
    "use strict";
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports, module2) {
    "use strict";
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e3) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/lodash/_baseAssignValue.js"(exports, module2) {
    "use strict";
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports, module2) {
    "use strict";
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "../../node_modules/lodash/_assignValue.js"(exports, module2) {
    "use strict";
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports, module2) {
    "use strict";
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports, module2) {
    "use strict";
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/lodash/isSymbol.js"(exports, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/lodash/_isKey.js"(exports, module2) {
    "use strict";
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports, module2) {
    "use strict";
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports, module2) {
    "use strict";
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index3 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports, module2) {
    "use strict";
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports, module2) {
    "use strict";
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index3 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index3, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      return index3 < 0 ? void 0 : data[index3][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index3][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports, module2) {
    "use strict";
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index3 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports, module2) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports, module2) {
    "use strict";
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports, module2) {
    "use strict";
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports, module2) {
    "use strict";
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports, module2) {
    "use strict";
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index3 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index3 < length) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/lodash/memoize.js"(exports, module2) {
    "use strict";
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// ../../node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/lodash/_memoizeCapped.js"(exports, module2) {
    "use strict";
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../../node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/lodash/_stringToPath.js"(exports, module2) {
    "use strict";
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports, module2) {
    "use strict";
    function arrayMap(array, iteratee) {
      var index3 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index3 < length) {
        result[index3] = iteratee(array[index3], index3, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/lodash/_baseToString.js"(exports, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/lodash/toString.js"(exports, module2) {
    "use strict";
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// ../../node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/lodash/_castPath.js"(exports, module2) {
    "use strict";
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports, module2) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/lodash/_toKey.js"(exports, module2) {
    "use strict";
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../../node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "../../node_modules/lodash/_baseSet.js"(exports, module2) {
    "use strict";
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject4 = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path2, value, customizer) {
      if (!isObject4(object)) {
        return object;
      }
      path2 = castPath(path2, object);
      var index3 = -1, length = path2.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index3 < length) {
        var key = toKey(path2[index3]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index3 != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject4(objValue) ? objValue : isIndex(path2[index3 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module2.exports = baseSet;
  }
});

// ../../node_modules/lodash/set.js
var require_set2 = __commonJS({
  "../../node_modules/lodash/set.js"(exports, module2) {
    "use strict";
    var baseSet = require_baseSet();
    function set(object, path2, value) {
      return object == null ? object : baseSet(object, path2, value);
    }
    module2.exports = set;
  }
});

// ../../node_modules/urijs/src/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/urijs/src/punycode.js"(exports, module2) {
    "use strict";
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k2 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i3 = 0, n3 = initialN, bias = initialBias, basic, j2, index3, oldi, w2, k2, digit, t3, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j2 = 0; j2 < basic; ++j2) {
          if (input.charCodeAt(j2) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j2));
        }
        for (index3 = basic > 0 ? basic + 1 : 0; index3 < inputLength; ) {
          for (oldi = i3, w2 = 1, k2 = base; ; k2 += base) {
            if (index3 >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index3++));
            if (digit >= base || digit > floor((maxInt - i3) / w2)) {
              error("overflow");
            }
            i3 += digit * w2;
            t3 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
            if (digit < t3) {
              break;
            }
            baseMinusT = base - t3;
            if (w2 > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w2 *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i3 - oldi, out, oldi == 0);
          if (floor(i3 / out) > maxInt - n3) {
            error("overflow");
          }
          n3 += floor(i3 / out);
          i3 %= out;
          output.splice(i3++, 0, n3);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n3, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t3, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n3 = initialN;
        delta = 0;
        bias = initialBias;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue >= n3 && currentValue < m2) {
              m2 = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m2 - n3 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m2 - n3) * handledCPCountPlusOne;
          n3 = m2;
          for (j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue < n3 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n3) {
              for (q2 = delta, k2 = base; ; k2 += base) {
                t3 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                if (q2 < t3) {
                  break;
                }
                qMinusT = q2 - t3;
                baseMinusT = base - t3;
                output.push(
                  stringFromCharCode(digitToBasic(t3 + qMinusT % baseMinusT, 0))
                );
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n3;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module2.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// ../../node_modules/urijs/src/IPv6.js
var require_IPv6 = __commonJS({
  "../../node_modules/urijs/src/IPv6.js"(exports, module2) {
    "use strict";
    (function(root, factory) {
      "use strict";
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.IPv6 = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _IPv6 = root && root.IPv6;
      function bestPresentation(address) {
        var _address = address.toLowerCase();
        var segments = _address.split(":");
        var length = segments.length;
        var total = 8;
        if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
          segments.shift();
          segments.shift();
        } else if (segments[0] === "" && segments[1] === "") {
          segments.shift();
        } else if (segments[length - 1] === "" && segments[length - 2] === "") {
          segments.pop();
        }
        length = segments.length;
        if (segments[length - 1].indexOf(".") !== -1) {
          total = 7;
        }
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (segments[pos] === "") {
            break;
          }
        }
        if (pos < total) {
          segments.splice(pos, 1, "0000");
          while (segments.length < total) {
            segments.splice(pos, 0, "0000");
          }
        }
        var _segments;
        for (var i3 = 0; i3 < total; i3++) {
          _segments = segments[i3].split("");
          for (var j2 = 0; j2 < 3; j2++) {
            if (_segments[0] === "0" && _segments.length > 1) {
              _segments.splice(0, 1);
            } else {
              break;
            }
          }
          segments[i3] = _segments.join("");
        }
        var best = -1;
        var _best = 0;
        var _current = 0;
        var current = -1;
        var inzeroes = false;
        for (i3 = 0; i3 < total; i3++) {
          if (inzeroes) {
            if (segments[i3] === "0") {
              _current += 1;
            } else {
              inzeroes = false;
              if (_current > _best) {
                best = current;
                _best = _current;
              }
            }
          } else {
            if (segments[i3] === "0") {
              inzeroes = true;
              current = i3;
              _current = 1;
            }
          }
        }
        if (_current > _best) {
          best = current;
          _best = _current;
        }
        if (_best > 1) {
          segments.splice(best, _best, "");
        }
        length = segments.length;
        var result = "";
        if (segments[0] === "") {
          result = ":";
        }
        for (i3 = 0; i3 < length; i3++) {
          result += segments[i3];
          if (i3 === length - 1) {
            break;
          }
          result += ":";
        }
        if (segments[length - 1] === "") {
          result += ":";
        }
        return result;
      }
      function noConflict() {
        if (root.IPv6 === this) {
          root.IPv6 = _IPv6;
        }
        return this;
      }
      return {
        best: bestPresentation,
        noConflict
      };
    });
  }
});

// ../../node_modules/urijs/src/SecondLevelDomains.js
var require_SecondLevelDomains = __commonJS({
  "../../node_modules/urijs/src/SecondLevelDomains.js"(exports, module2) {
    "use strict";
    (function(root, factory) {
      "use strict";
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.SecondLevelDomains = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _SecondLevelDomains = root && root.SecondLevelDomains;
      var SLD = {
        // list of known Second Level Domains
        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
        // ----
        // publicsuffix.org is more current and actually used by a couple of browsers internally.
        // downside is it also contains domains like "dyndns.org" - which is fine for the security
        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
        // ----
        list: {
          "ac": " com gov mil net org ",
          "ae": " ac co gov mil name net org pro sch ",
          "af": " com edu gov net org ",
          "al": " com edu gov mil net org ",
          "ao": " co ed gv it og pb ",
          "ar": " com edu gob gov int mil net org tur ",
          "at": " ac co gv or ",
          "au": " asn com csiro edu gov id net org ",
          "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          "bb": " biz co com edu gov info net org store tv ",
          "bh": " biz cc com edu gov info net org ",
          "bn": " com edu gov net org ",
          "bo": " com edu gob gov int mil net org tv ",
          "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          "bs": " com edu gov net org ",
          "bz": " du et om ov rg ",
          "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          "ck": " biz co edu gen gov info net org ",
          "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          "co": " com edu gov mil net nom org ",
          "cr": " ac c co ed fi go or sa ",
          "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          "do": " art com edu gob gov mil net org sld web ",
          "dz": " art asso com edu gov net org pol ",
          "ec": " com edu fin gov info med mil net org pro ",
          "eg": " com edu eun gov mil name net org sci ",
          "er": " com edu gov ind mil net org rochest w ",
          "es": " com edu gob nom org ",
          "et": " biz com edu gov info name net org ",
          "fj": " ac biz com info mil name net org pro ",
          "fk": " ac co gov net nom org ",
          "fr": " asso com f gouv nom prd presse tm ",
          "gg": " co net org ",
          "gh": " com edu gov mil org ",
          "gn": " ac com gov net org ",
          "gr": " com edu gov mil net org ",
          "gt": " com edu gob ind mil net org ",
          "gu": " com edu gov net org ",
          "hk": " com edu gov idv net org ",
          "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          "id": " ac co go mil net or sch web ",
          "il": " ac co gov idf k12 muni net org ",
          "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
          "iq": " com edu gov i mil net org ",
          "ir": " ac co dnssec gov i id net org sch ",
          "it": " edu gov ",
          "je": " co net org ",
          "jo": " com edu gov mil name net org sch ",
          "jp": " ac ad co ed go gr lg ne or ",
          "ke": " ac co go info me mobi ne or sc ",
          "kh": " com edu gov mil net org per ",
          "ki": " biz com de edu gov info mob net org tel ",
          "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          "kn": " edu gov net org ",
          "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          "kw": " com edu gov net org ",
          "ky": " com edu gov net org ",
          "kz": " com edu gov mil net org ",
          "lb": " com edu gov net org ",
          "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          "lr": " com edu gov net org ",
          "lv": " asn com conf edu gov id mil net org ",
          "ly": " com edu gov id med net org plc sch ",
          "ma": " ac co gov m net org press ",
          "mc": " asso tm ",
          "me": " ac co edu gov its net org priv ",
          "mg": " com edu gov mil nom org prd tm ",
          "mk": " com edu gov inf name net org pro ",
          "ml": " com edu gov net org presse ",
          "mn": " edu gov org ",
          "mo": " com edu gov net org ",
          "mt": " com edu gov net org ",
          "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
          "mw": " ac co com coop edu gov int museum net org ",
          "mx": " com edu gob net org ",
          "my": " com edu gov mil name net org sch ",
          "nf": " arts com firm info net other per rec store web ",
          "ng": " biz com edu gov mil mobi name net org sch ",
          "ni": " ac co com edu gob mil net nom org ",
          "np": " com edu gov mil net org ",
          "nr": " biz com edu gov info net org ",
          "om": " ac biz co com edu gov med mil museum net org pro sch ",
          "pe": " com edu gob mil net nom org sld ",
          "ph": " com edu gov i mil net ngo org ",
          "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
          "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          "pr": " ac biz com edu est gov info isla name net org pro prof ",
          "ps": " com edu gov net org plo sec ",
          "pw": " belau co ed go ne or ",
          "ro": " arts com firm info nom nt org rec store tm www ",
          "rs": " ac co edu gov in org ",
          "sb": " com edu gov net org ",
          "sc": " com edu gov net org ",
          "sh": " co com edu gov net nom org ",
          "sl": " com edu gov net org ",
          "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
          "sv": " com edu gob org red ",
          "sz": " ac co org ",
          "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          "tw": " club com ebiz edu game gov idv mil net org ",
          "mu": " ac co com gov net or org ",
          "mz": " ac co edu gov org ",
          "na": " co com ",
          "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          "pa": " abo ac com edu gob ing med net nom org sld ",
          "pt": " com edu gov int net nome org publ ",
          "py": " com edu gov mil net org ",
          "qa": " com edu gov mil net org ",
          "re": " asso com nom ",
          "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          "rw": " ac co com edu gouv gov int mil net ",
          "sa": " com edu gov med net org pub sch ",
          "sd": " com edu gov info med net org tv ",
          "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          "sg": " com edu gov idn net org per ",
          "sn": " art com edu gouv org perso univ ",
          "sy": " com edu gov mil net news org ",
          "th": " ac co go in mi net or ",
          "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
          "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          "tz": " ac co go ne or ",
          "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          "ug": " ac co go ne or org sc ",
          "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          "us": " dni fed isa kids nsn ",
          "uy": " com edu gub mil net org ",
          "ve": " co com edu gob info mil net org web ",
          "vi": " co com k12 net org ",
          "vn": " ac biz com edu gov health info int name net org pro ",
          "ye": " co com gov ltd me net org plc ",
          "yu": " ac co edu gov org ",
          "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          "zm": " ac co com edu gov net org sch ",
          // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
          "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          "net": "gb jp se uk ",
          "org": "ae",
          "de": "com "
        },
        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
        // in both performance and memory footprint. No initialization required.
        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
        // Following methods use lastIndexOf() rather than array.split() in order
        // to avoid any memory allocations.
        has: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
        },
        is: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset >= 0) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
        },
        get: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return null;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return null;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return null;
          }
          if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
            return null;
          }
          return domain.slice(sldOffset + 1);
        },
        noConflict: function() {
          if (root.SecondLevelDomains === this) {
            root.SecondLevelDomains = _SecondLevelDomains;
          }
          return this;
        }
      };
      return SLD;
    });
  }
});

// ../../node_modules/urijs/src/URI.js
var require_URI = __commonJS({
  "../../node_modules/urijs/src/URI.js"(exports, module2) {
    "use strict";
    (function(root, factory) {
      "use strict";
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory(require_punycode(), require_IPv6(), require_SecondLevelDomains());
      } else if (typeof define === "function" && define.amd) {
        define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory);
      } else {
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
      }
    })(exports, function(punycode, IPv6, SLD, root) {
      "use strict";
      var _URI = root && root.URI;
      function URI(url, base) {
        var _urlSupplied = arguments.length >= 1;
        var _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI)) {
          if (_urlSupplied) {
            if (_baseSupplied) {
              return new URI(url, base);
            }
            return new URI(url);
          }
          return new URI();
        }
        if (url === void 0) {
          if (_urlSupplied) {
            throw new TypeError("undefined is not a valid argument for URI");
          }
          if (typeof location !== "undefined") {
            url = location.href + "";
          } else {
            url = "";
          }
        }
        if (url === null) {
          if (_urlSupplied) {
            throw new TypeError("null is not a valid argument for URI");
          }
        }
        this.href(url);
        if (base !== void 0) {
          return this.absoluteTo(base);
        }
        return this;
      }
      function isInteger(value) {
        return /^[0-9]+$/.test(value);
      }
      URI.version = "1.19.11";
      var p2 = URI.prototype;
      var hasOwn = Object.prototype.hasOwnProperty;
      function escapeRegEx(string) {
        return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function getType(value) {
        if (value === void 0) {
          return "Undefined";
        }
        return String(Object.prototype.toString.call(value)).slice(8, -1);
      }
      function isArray(obj) {
        return getType(obj) === "Array";
      }
      function filterArrayValues(data, value) {
        var lookup = {};
        var i3, length;
        if (getType(value) === "RegExp") {
          lookup = null;
        } else if (isArray(value)) {
          for (i3 = 0, length = value.length; i3 < length; i3++) {
            lookup[value[i3]] = true;
          }
        } else {
          lookup[value] = true;
        }
        for (i3 = 0, length = data.length; i3 < length; i3++) {
          var _match = lookup && lookup[data[i3]] !== void 0 || !lookup && value.test(data[i3]);
          if (_match) {
            data.splice(i3, 1);
            length--;
            i3--;
          }
        }
        return data;
      }
      function arrayContains(list, value) {
        var i3, length;
        if (isArray(value)) {
          for (i3 = 0, length = value.length; i3 < length; i3++) {
            if (!arrayContains(list, value[i3])) {
              return false;
            }
          }
          return true;
        }
        var _type = getType(value);
        for (i3 = 0, length = list.length; i3 < length; i3++) {
          if (_type === "RegExp") {
            if (typeof list[i3] === "string" && list[i3].match(value)) {
              return true;
            }
          } else if (list[i3] === value) {
            return true;
          }
        }
        return false;
      }
      function arraysEqual(one, two) {
        if (!isArray(one) || !isArray(two)) {
          return false;
        }
        if (one.length !== two.length) {
          return false;
        }
        one.sort();
        two.sort();
        for (var i3 = 0, l2 = one.length; i3 < l2; i3++) {
          if (one[i3] !== two[i3]) {
            return false;
          }
        }
        return true;
      }
      function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
      }
      URI._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          // state
          preventInvalidHostname: URI.preventInvalidHostname,
          duplicateQueryParameters: URI.duplicateQueryParameters,
          escapeQuerySpace: URI.escapeQuerySpace
        };
      };
      URI.preventInvalidHostname = false;
      URI.duplicateQueryParameters = false;
      URI.escapeQuerySpace = true;
      URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
      URI.idn_expression = /[^a-z0-9\._-]/i;
      URI.punycode_expression = /(xn--)/i;
      URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
      URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
      URI.findUri = {
        // valid "scheme://" or "www."
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        // everything up to the next whitespace
        end: /[\s\r\n]|$/,
        // trim trailing punctuation captured by end RegExp
        trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
        // balanced parens inclusion (), [], {}, <>
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      };
      URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
      URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      };
      URI.hostProtocols = [
        "http",
        "https"
      ];
      URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
      URI.domAttributes = {
        "a": "href",
        "blockquote": "cite",
        "link": "href",
        "base": "href",
        "script": "src",
        "form": "action",
        "img": "src",
        "area": "href",
        "iframe": "src",
        "embed": "src",
        "source": "src",
        "track": "src",
        "input": "src",
        // but only if type="image"
        "audio": "src",
        "video": "src"
      };
      URI.getDomAttribute = function(node) {
        if (!node || !node.nodeName) {
          return void 0;
        }
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "input" && node.type !== "image") {
          return void 0;
        }
        return URI.domAttributes[nodeName];
      };
      function escapeForDumbFirefox36(value) {
        return escape(value);
      }
      function strictEncodeURIComponent(string) {
        return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
      }
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
      URI.iso8859 = function() {
        URI.encode = escape;
        URI.decode = unescape;
      };
      URI.unicode = function() {
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
      };
      URI.characters = {
        pathname: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              // -._~!'()*
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              // gen-delims
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              // sub-delims
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
          // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
          // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
          // note that the colon character is not featured in the encoding map; this is because URI.js
          // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
          // should not appear unencoded in a segment itself.
          // See also the note above about RFC3986 and capitalalized hex digits.
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          // These characters are the characters called out by RFC2141 as "reserved" characters that
          // should never appear in a URN, plus the colon character (see note above).
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      };
      URI.encodeQuery = function(string, escapeQuerySpace) {
        var escaped = URI.encode(string + "");
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
      };
      URI.decodeQuery = function(string, escapeQuerySpace) {
        string += "";
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        try {
          return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
        } catch (e3) {
          return string;
        }
      };
      var _parts = { "encode": "encode", "decode": "decode" };
      var _part;
      var generateAccessor = function(_group, _part2) {
        return function(string) {
          try {
            return URI[_part2](string + "").replace(URI.characters[_group][_part2].expression, function(c2) {
              return URI.characters[_group][_part2].map[c2];
            });
          } catch (e3) {
            return string;
          }
        };
      };
      for (_part in _parts) {
        URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
        URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
      }
      var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string) {
          var actualCodingFunc;
          if (!_innerCodingFuncName) {
            actualCodingFunc = URI[_codingFuncName];
          } else {
            actualCodingFunc = function(string2) {
              return URI[_codingFuncName](URI[_innerCodingFuncName](string2));
            };
          }
          var segments = (string + "").split(_sep);
          for (var i3 = 0, length = segments.length; i3 < length; i3++) {
            segments[i3] = actualCodingFunc(segments[i3]);
          }
          return segments.join(_sep);
        };
      };
      URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
      URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
      URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
      URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
      URI.encodeReserved = generateAccessor("reserved", "encode");
      URI.parse = function(string, parts) {
        var pos;
        if (!parts) {
          parts = {
            preventInvalidHostname: URI.preventInvalidHostname
          };
        }
        string = string.replace(URI.leading_whitespace_expression, "");
        string = string.replace(URI.ascii_tab_whitespace, "");
        pos = string.indexOf("#");
        if (pos > -1) {
          parts.fragment = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        pos = string.indexOf("?");
        if (pos > -1) {
          parts.query = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
        string = string.replace(/^[/\\]{2,}/i, "//");
        if (string.substring(0, 2) === "//") {
          parts.protocol = null;
          string = string.substring(2);
          string = URI.parseAuthority(string, parts);
        } else {
          pos = string.indexOf(":");
          if (pos > -1) {
            parts.protocol = string.substring(0, pos) || null;
            if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
              parts.protocol = void 0;
            } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
              string = string.substring(pos + 3);
              string = URI.parseAuthority(string, parts);
            } else {
              string = string.substring(pos + 1);
              parts.urn = true;
            }
          }
        }
        parts.path = string;
        return parts;
      };
      URI.parseHost = function(string, parts) {
        if (!string) {
          string = "";
        }
        string = string.replace(/\\/g, "/");
        var pos = string.indexOf("/");
        var bracketPos;
        var t3;
        if (pos === -1) {
          pos = string.length;
        }
        if (string.charAt(0) === "[") {
          bracketPos = string.indexOf("]");
          parts.hostname = string.substring(1, bracketPos) || null;
          parts.port = string.substring(bracketPos + 2, pos) || null;
          if (parts.port === "/") {
            parts.port = null;
          }
        } else {
          var firstColon = string.indexOf(":");
          var firstSlash = string.indexOf("/");
          var nextColon = string.indexOf(":", firstColon + 1);
          if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
            parts.hostname = string.substring(0, pos) || null;
            parts.port = null;
          } else {
            t3 = string.substring(0, pos).split(":");
            parts.hostname = t3[0] || null;
            parts.port = t3[1] || null;
          }
        }
        if (parts.hostname && string.substring(pos).charAt(0) !== "/") {
          pos++;
          string = "/" + string;
        }
        if (parts.preventInvalidHostname) {
          URI.ensureValidHostname(parts.hostname, parts.protocol);
        }
        if (parts.port) {
          URI.ensureValidPort(parts.port);
        }
        return string.substring(pos) || "/";
      };
      URI.parseAuthority = function(string, parts) {
        string = URI.parseUserinfo(string, parts);
        return URI.parseHost(string, parts);
      };
      URI.parseUserinfo = function(string, parts) {
        var _string = string;
        var firstBackSlash = string.indexOf("\\");
        if (firstBackSlash !== -1) {
          string = string.replace(/\\/g, "/");
        }
        var firstSlash = string.indexOf("/");
        var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
        var t3;
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
          t3 = string.substring(0, pos).split(":");
          parts.username = t3[0] ? URI.decode(t3[0]) : null;
          t3.shift();
          parts.password = t3[0] ? URI.decode(t3.join(":")) : null;
          string = _string.substring(pos + 1);
        } else {
          parts.username = null;
          parts.password = null;
        }
        return string;
      };
      URI.parseQuery = function(string, escapeQuerySpace) {
        if (!string) {
          return {};
        }
        string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
        if (!string) {
          return {};
        }
        var items = {};
        var splits = string.split("&");
        var length = splits.length;
        var v2, name, value;
        for (var i3 = 0; i3 < length; i3++) {
          v2 = splits[i3].split("=");
          name = URI.decodeQuery(v2.shift(), escapeQuerySpace);
          value = v2.length ? URI.decodeQuery(v2.join("="), escapeQuerySpace) : null;
          if (name === "__proto__") {
            continue;
          } else if (hasOwn.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
              items[name] = [items[name]];
            }
            items[name].push(value);
          } else {
            items[name] = value;
          }
        }
        return items;
      };
      URI.build = function(parts) {
        var t3 = "";
        var requireAbsolutePath = false;
        if (parts.protocol) {
          t3 += parts.protocol + ":";
        }
        if (!parts.urn && (t3 || parts.hostname)) {
          t3 += "//";
          requireAbsolutePath = true;
        }
        t3 += URI.buildAuthority(parts) || "";
        if (typeof parts.path === "string") {
          if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
            t3 += "/";
          }
          t3 += parts.path;
        }
        if (typeof parts.query === "string" && parts.query) {
          t3 += "?" + parts.query;
        }
        if (typeof parts.fragment === "string" && parts.fragment) {
          t3 += "#" + parts.fragment;
        }
        return t3;
      };
      URI.buildHost = function(parts) {
        var t3 = "";
        if (!parts.hostname) {
          return "";
        } else if (URI.ip6_expression.test(parts.hostname)) {
          t3 += "[" + parts.hostname + "]";
        } else {
          t3 += parts.hostname;
        }
        if (parts.port) {
          t3 += ":" + parts.port;
        }
        return t3;
      };
      URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
      };
      URI.buildUserinfo = function(parts) {
        var t3 = "";
        if (parts.username) {
          t3 += URI.encode(parts.username);
        }
        if (parts.password) {
          t3 += ":" + URI.encode(parts.password);
        }
        if (t3) {
          t3 += "@";
        }
        return t3;
      };
      URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var t3 = "";
        var unique, key, i3, length;
        for (key in data) {
          if (key === "__proto__") {
            continue;
          } else if (hasOwn.call(data, key)) {
            if (isArray(data[key])) {
              unique = {};
              for (i3 = 0, length = data[key].length; i3 < length; i3++) {
                if (data[key][i3] !== void 0 && unique[data[key][i3] + ""] === void 0) {
                  t3 += "&" + URI.buildQueryParameter(key, data[key][i3], escapeQuerySpace);
                  if (duplicateQueryParameters !== true) {
                    unique[data[key][i3] + ""] = true;
                  }
                }
              }
            } else if (data[key] !== void 0) {
              t3 += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
            }
          }
        }
        return t3.substring(1);
      };
      URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
      };
      URI.addQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.addQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (data[name] === void 0) {
            data[name] = value;
            return;
          } else if (typeof data[name] === "string") {
            data[name] = [data[name]];
          }
          if (!isArray(value)) {
            value = [value];
          }
          data[name] = (data[name] || []).concat(value);
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
      };
      URI.setQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.setQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          data[name] = value === void 0 ? null : value;
        } else {
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
        }
      };
      URI.removeQuery = function(data, name, value) {
        var i3, length, key;
        if (isArray(name)) {
          for (i3 = 0, length = name.length; i3 < length; i3++) {
            data[name[i3]] = void 0;
          }
        } else if (getType(name) === "RegExp") {
          for (key in data) {
            if (name.test(key)) {
              data[key] = void 0;
            }
          }
        } else if (typeof name === "object") {
          for (key in name) {
            if (hasOwn.call(name, key)) {
              URI.removeQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (value !== void 0) {
            if (getType(value) === "RegExp") {
              if (!isArray(data[name]) && value.test(data[name])) {
                data[name] = void 0;
              } else {
                data[name] = filterArrayValues(data[name], value);
              }
            } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
              data[name] = void 0;
            } else if (isArray(data[name])) {
              data[name] = filterArrayValues(data[name], value);
            }
          } else {
            data[name] = void 0;
          }
        } else {
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        }
      };
      URI.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;
          case "RegExp":
            for (var key in data) {
              if (hasOwn.call(data, key)) {
                if (name.test(key) && (value === void 0 || URI.hasQuery(data, key, value))) {
                  return true;
                }
              }
            }
            return false;
          case "Object":
            for (var _key in name) {
              if (hasOwn.call(name, _key)) {
                if (!URI.hasQuery(data, _key, name[_key])) {
                  return false;
                }
              }
            }
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;
          case "Boolean":
            var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
            return value === _booly;
          case "Function":
            return !!value(data[name], name, data);
          case "Array":
            if (!isArray(data[name])) {
              return false;
            }
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);
          case "RegExp":
            if (!isArray(data[name])) {
              return Boolean(data[name] && data[name].match(value));
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          case "Number":
            value = String(value);
          case "String":
            if (!isArray(data[name])) {
              return data[name] === value;
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      };
      URI.joinPaths = function() {
        var input = [];
        var segments = [];
        var nonEmptySegments = 0;
        for (var i3 = 0; i3 < arguments.length; i3++) {
          var url = new URI(arguments[i3]);
          input.push(url);
          var _segments = url.segment();
          for (var s2 = 0; s2 < _segments.length; s2++) {
            if (typeof _segments[s2] === "string") {
              segments.push(_segments[s2]);
            }
            if (_segments[s2]) {
              nonEmptySegments++;
            }
          }
        }
        if (!segments.length || !nonEmptySegments) {
          return new URI("");
        }
        var uri = new URI("").segment(segments);
        if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
          uri.path("/" + uri.path());
        }
        return uri.normalize();
      };
      URI.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length);
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
          }
        }
        if (pos < 1) {
          return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
        }
        if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
          pos = one.substring(0, pos).lastIndexOf("/");
        }
        return one.substring(0, pos + 1);
      };
      URI.withinString = function(string, callback, options) {
        options || (options = {});
        var _start = options.start || URI.findUri.start;
        var _end = options.end || URI.findUri.end;
        var _trim = options.trim || URI.findUri.trim;
        var _parens = options.parens || URI.findUri.parens;
        var _attributeOpen = /[a-z0-9-]=["']?$/i;
        _start.lastIndex = 0;
        while (true) {
          var match = _start.exec(string);
          if (!match) {
            break;
          }
          var start = match.index;
          if (options.ignoreHtml) {
            var attributeOpen = string.slice(Math.max(start - 3, 0), start);
            if (attributeOpen && _attributeOpen.test(attributeOpen)) {
              continue;
            }
          }
          var end = start + string.slice(start).search(_end);
          var slice = string.slice(start, end);
          var parensEnd = -1;
          while (true) {
            var parensMatch = _parens.exec(slice);
            if (!parensMatch) {
              break;
            }
            var parensMatchEnd = parensMatch.index + parensMatch[0].length;
            parensEnd = Math.max(parensEnd, parensMatchEnd);
          }
          if (parensEnd > -1) {
            slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
          } else {
            slice = slice.replace(_trim, "");
          }
          if (slice.length <= match[0].length) {
            continue;
          }
          if (options.ignore && options.ignore.test(slice)) {
            continue;
          }
          end = start + slice.length;
          var result = callback(slice, start, end, string);
          if (result === void 0) {
            _start.lastIndex = end;
            continue;
          }
          result = String(result);
          string = string.slice(0, start) + result + string.slice(end);
          _start.lastIndex = start + result.length;
        }
        _start.lastIndex = 0;
        return string;
      };
      URI.ensureValidHostname = function(v2, protocol) {
        var hasHostname = !!v2;
        var hasProtocol = !!protocol;
        var rejectEmptyHostname = false;
        if (hasProtocol) {
          rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
        }
        if (rejectEmptyHostname && !hasHostname) {
          throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
        } else if (v2 && v2.match(URI.invalid_hostname_characters)) {
          if (!punycode) {
            throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          }
          if (punycode.toASCII(v2).match(URI.invalid_hostname_characters)) {
            throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-:_]');
          }
        }
      };
      URI.ensureValidPort = function(v2) {
        if (!v2) {
          return;
        }
        var port = Number(v2);
        if (isInteger(port) && port > 0 && port < 65536) {
          return;
        }
        throw new TypeError('Port "' + v2 + '" is not a valid port');
      };
      URI.noConflict = function(removeAll) {
        if (removeAll) {
          var unconflicted = {
            URI: this.noConflict()
          };
          if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
            unconflicted.URITemplate = root.URITemplate.noConflict();
          }
          if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
            unconflicted.IPv6 = root.IPv6.noConflict();
          }
          if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
            unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
          }
          return unconflicted;
        } else if (root.URI === this) {
          root.URI = _URI;
        }
        return this;
      };
      p2.build = function(deferBuild) {
        if (deferBuild === true) {
          this._deferred_build = true;
        } else if (deferBuild === void 0 || this._deferred_build) {
          this._string = URI.build(this._parts);
          this._deferred_build = false;
        }
        return this;
      };
      p2.clone = function() {
        return new URI(this);
      };
      p2.valueOf = p2.toString = function() {
        return this.build(false)._string;
      };
      function generateSimpleAccessor(_part2) {
        return function(v2, build2) {
          if (v2 === void 0) {
            return this._parts[_part2] || "";
          } else {
            this._parts[_part2] = v2 || null;
            this.build(!build2);
            return this;
          }
        };
      }
      function generatePrefixAccessor(_part2, _key) {
        return function(v2, build2) {
          if (v2 === void 0) {
            return this._parts[_part2] || "";
          } else {
            if (v2 !== null) {
              v2 = v2 + "";
              if (v2.charAt(0) === _key) {
                v2 = v2.substring(1);
              }
            }
            this._parts[_part2] = v2;
            this.build(!build2);
            return this;
          }
        };
      }
      p2.protocol = generateSimpleAccessor("protocol");
      p2.username = generateSimpleAccessor("username");
      p2.password = generateSimpleAccessor("password");
      p2.hostname = generateSimpleAccessor("hostname");
      p2.port = generateSimpleAccessor("port");
      p2.query = generatePrefixAccessor("query", "?");
      p2.fragment = generatePrefixAccessor("fragment", "#");
      p2.search = function(v2, build2) {
        var t3 = this.query(v2, build2);
        return typeof t3 === "string" && t3.length ? "?" + t3 : t3;
      };
      p2.hash = function(v2, build2) {
        var t3 = this.fragment(v2, build2);
        return typeof t3 === "string" && t3.length ? "#" + t3 : t3;
      };
      p2.pathname = function(v2, build2) {
        if (v2 === void 0 || v2 === true) {
          var res = this._parts.path || (this._parts.hostname ? "/" : "");
          return v2 ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
        } else {
          if (this._parts.urn) {
            this._parts.path = v2 ? URI.recodeUrnPath(v2) : "";
          } else {
            this._parts.path = v2 ? URI.recodePath(v2) : "/";
          }
          this.build(!build2);
          return this;
        }
      };
      p2.path = p2.pathname;
      p2.href = function(href, build2) {
        var key;
        if (href === void 0) {
          return this.toString();
        }
        this._string = "";
        this._parts = URI._parts();
        var _URI2 = href instanceof URI;
        var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
          var attribute = URI.getDomAttribute(href);
          href = href[attribute] || "";
          _object = false;
        }
        if (!_URI2 && _object && href.pathname !== void 0) {
          href = href.toString();
        }
        if (typeof href === "string" || href instanceof String) {
          this._parts = URI.parse(String(href), this._parts);
        } else if (_URI2 || _object) {
          var src = _URI2 ? href._parts : href;
          for (key in src) {
            if (key === "query") {
              continue;
            }
            if (hasOwn.call(this._parts, key)) {
              this._parts[key] = src[key];
            }
          }
          if (src.query) {
            this.query(src.query, false);
          }
        } else {
          throw new TypeError("invalid input");
        }
        this.build(!build2);
        return this;
      };
      p2.is = function(what) {
        var ip = false;
        var ip4 = false;
        var ip6 = false;
        var name = false;
        var sld = false;
        var idn = false;
        var punycode2 = false;
        var relative = !this._parts.urn;
        if (this._parts.hostname) {
          relative = false;
          ip4 = URI.ip4_expression.test(this._parts.hostname);
          ip6 = URI.ip6_expression.test(this._parts.hostname);
          ip = ip4 || ip6;
          name = !ip;
          sld = name && SLD && SLD.has(this._parts.hostname);
          idn = name && URI.idn_expression.test(this._parts.hostname);
          punycode2 = name && URI.punycode_expression.test(this._parts.hostname);
        }
        switch (what.toLowerCase()) {
          case "relative":
            return relative;
          case "absolute":
            return !relative;
          case "domain":
          case "name":
            return name;
          case "sld":
            return sld;
          case "ip":
            return ip;
          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;
          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;
          case "idn":
            return idn;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return punycode2;
        }
        return null;
      };
      var _protocol = p2.protocol;
      var _port = p2.port;
      var _hostname = p2.hostname;
      p2.protocol = function(v2, build2) {
        if (v2) {
          v2 = v2.replace(/:(\/\/)?$/, "");
          if (!v2.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v2 + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
          }
        }
        return _protocol.call(this, v2, build2);
      };
      p2.scheme = p2.protocol;
      p2.port = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 !== void 0) {
          if (v2 === 0) {
            v2 = null;
          }
          if (v2) {
            v2 += "";
            if (v2.charAt(0) === ":") {
              v2 = v2.substring(1);
            }
            URI.ensureValidPort(v2);
          }
        }
        return _port.call(this, v2, build2);
      };
      p2.hostname = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 !== void 0) {
          var x3 = { preventInvalidHostname: this._parts.preventInvalidHostname };
          var res = URI.parseHost(v2, x3);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-]');
          }
          v2 = x3.hostname;
          if (this._parts.preventInvalidHostname) {
            URI.ensureValidHostname(v2, this._parts.protocol);
          }
        }
        return _hostname.call(this, v2, build2);
      };
      p2.origin = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 === void 0) {
          var protocol = this.protocol();
          var authority = this.authority();
          if (!authority) {
            return "";
          }
          return (protocol ? protocol + "://" : "") + this.authority();
        } else {
          var origin = URI(v2);
          this.protocol(origin.protocol()).authority(origin.authority()).build(!build2);
          return this;
        }
      };
      p2.host = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 === void 0) {
          return this._parts.hostname ? URI.buildHost(this._parts) : "";
        } else {
          var res = URI.parseHost(v2, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build2);
          return this;
        }
      };
      p2.authority = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 === void 0) {
          return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        } else {
          var res = URI.parseAuthority(v2, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build2);
          return this;
        }
      };
      p2.userinfo = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 === void 0) {
          var t3 = URI.buildUserinfo(this._parts);
          return t3 ? t3.substring(0, t3.length - 1) : t3;
        } else {
          if (v2[v2.length - 1] !== "@") {
            v2 += "@";
          }
          URI.parseUserinfo(v2, this._parts);
          this.build(!build2);
          return this;
        }
      };
      p2.resource = function(v2, build2) {
        var parts;
        if (v2 === void 0) {
          return this.path() + this.search() + this.hash();
        }
        parts = URI.parse(v2);
        this._parts.path = parts.path;
        this._parts.query = parts.query;
        this._parts.fragment = parts.fragment;
        this.build(!build2);
        return this;
      };
      p2.subdomain = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var end = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, end) || "";
        } else {
          var e3 = this._parts.hostname.length - this.domain().length;
          var sub = this._parts.hostname.substring(0, e3);
          var replace = new RegExp("^" + escapeRegEx(sub));
          if (v2 && v2.charAt(v2.length - 1) !== ".") {
            v2 += ".";
          }
          if (v2.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          if (v2) {
            URI.ensureValidHostname(v2, this._parts.protocol);
          }
          this._parts.hostname = this._parts.hostname.replace(replace, v2);
          this.build(!build2);
          return this;
        }
      };
      p2.domain = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (typeof v2 === "boolean") {
          build2 = v2;
          v2 = void 0;
        }
        if (v2 === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var t3 = this._parts.hostname.match(/\./g);
          if (t3 && t3.length < 2) {
            return this._parts.hostname;
          }
          var end = this._parts.hostname.length - this.tld(build2).length - 1;
          end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
          return this._parts.hostname.substring(end) || "";
        } else {
          if (!v2) {
            throw new TypeError("cannot set domain empty");
          }
          if (v2.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          URI.ensureValidHostname(v2, this._parts.protocol);
          if (!this._parts.hostname || this.is("IP")) {
            this._parts.hostname = v2;
          } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v2);
          }
          this.build(!build2);
          return this;
        }
      };
      p2.tld = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (typeof v2 === "boolean") {
          build2 = v2;
          v2 = void 0;
        }
        if (v2 === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var pos = this._parts.hostname.lastIndexOf(".");
          var tld = this._parts.hostname.substring(pos + 1);
          if (build2 !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
          }
          return tld;
        } else {
          var replace;
          if (!v2) {
            throw new TypeError("cannot set TLD empty");
          } else if (v2.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v2)) {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v2);
            } else {
              throw new TypeError('TLD "' + v2 + '" contains characters other than [A-Z0-9]');
            }
          } else if (!this._parts.hostname || this.is("IP")) {
            throw new ReferenceError("cannot set TLD on non-domain host");
          } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v2);
          }
          this.build(!build2);
          return this;
        }
      };
      p2.directory = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 === void 0 || v2 === true) {
          if (!this._parts.path && !this._parts.hostname) {
            return "";
          }
          if (this._parts.path === "/") {
            return "/";
          }
          var end = this._parts.path.length - this.filename().length - 1;
          var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
          return v2 ? URI.decodePath(res) : res;
        } else {
          var e3 = this._parts.path.length - this.filename().length;
          var directory = this._parts.path.substring(0, e3);
          var replace = new RegExp("^" + escapeRegEx(directory));
          if (!this.is("relative")) {
            if (!v2) {
              v2 = "/";
            }
            if (v2.charAt(0) !== "/") {
              v2 = "/" + v2;
            }
          }
          if (v2 && v2.charAt(v2.length - 1) !== "/") {
            v2 += "/";
          }
          v2 = URI.recodePath(v2);
          this._parts.path = this._parts.path.replace(replace, v2);
          this.build(!build2);
          return this;
        }
      };
      p2.filename = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (typeof v2 !== "string") {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var pos = this._parts.path.lastIndexOf("/");
          var res = this._parts.path.substring(pos + 1);
          return v2 ? URI.decodePathSegment(res) : res;
        } else {
          var mutatedDirectory = false;
          if (v2.charAt(0) === "/") {
            v2 = v2.substring(1);
          }
          if (v2.match(/\.?\//)) {
            mutatedDirectory = true;
          }
          var replace = new RegExp(escapeRegEx(this.filename()) + "$");
          v2 = URI.recodePath(v2);
          this._parts.path = this._parts.path.replace(replace, v2);
          if (mutatedDirectory) {
            this.normalizePath(build2);
          } else {
            this.build(!build2);
          }
          return this;
        }
      };
      p2.suffix = function(v2, build2) {
        if (this._parts.urn) {
          return v2 === void 0 ? "" : this;
        }
        if (v2 === void 0 || v2 === true) {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var filename = this.filename();
          var pos = filename.lastIndexOf(".");
          var s2, res;
          if (pos === -1) {
            return "";
          }
          s2 = filename.substring(pos + 1);
          res = /^[a-z0-9%]+$/i.test(s2) ? s2 : "";
          return v2 ? URI.decodePathSegment(res) : res;
        } else {
          if (v2.charAt(0) === ".") {
            v2 = v2.substring(1);
          }
          var suffix = this.suffix();
          var replace;
          if (!suffix) {
            if (!v2) {
              return this;
            }
            this._parts.path += "." + URI.recodePath(v2);
          } else if (!v2) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
          } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
          }
          if (replace) {
            v2 = URI.recodePath(v2);
            this._parts.path = this._parts.path.replace(replace, v2);
          }
          this.build(!build2);
          return this;
        }
      };
      p2.segment = function(segment, v2, build2) {
        var separator2 = this._parts.urn ? ":" : "/";
        var path2 = this.path();
        var absolute = path2.substring(0, 1) === "/";
        var segments = path2.split(separator2);
        if (segment !== void 0 && typeof segment !== "number") {
          build2 = v2;
          v2 = segment;
          segment = void 0;
        }
        if (segment !== void 0 && typeof segment !== "number") {
          throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        }
        if (absolute) {
          segments.shift();
        }
        if (segment < 0) {
          segment = Math.max(segments.length + segment, 0);
        }
        if (v2 === void 0) {
          return segment === void 0 ? segments : segments[segment];
        } else if (segment === null || segments[segment] === void 0) {
          if (isArray(v2)) {
            segments = [];
            for (var i3 = 0, l2 = v2.length; i3 < l2; i3++) {
              if (!v2[i3].length && (!segments.length || !segments[segments.length - 1].length)) {
                continue;
              }
              if (segments.length && !segments[segments.length - 1].length) {
                segments.pop();
              }
              segments.push(trimSlashes(v2[i3]));
            }
          } else if (v2 || typeof v2 === "string") {
            v2 = trimSlashes(v2);
            if (segments[segments.length - 1] === "") {
              segments[segments.length - 1] = v2;
            } else {
              segments.push(v2);
            }
          }
        } else {
          if (v2) {
            segments[segment] = trimSlashes(v2);
          } else {
            segments.splice(segment, 1);
          }
        }
        if (absolute) {
          segments.unshift("");
        }
        return this.path(segments.join(separator2), build2);
      };
      p2.segmentCoded = function(segment, v2, build2) {
        var segments, i3, l2;
        if (typeof segment !== "number") {
          build2 = v2;
          v2 = segment;
          segment = void 0;
        }
        if (v2 === void 0) {
          segments = this.segment(segment, v2, build2);
          if (!isArray(segments)) {
            segments = segments !== void 0 ? URI.decode(segments) : void 0;
          } else {
            for (i3 = 0, l2 = segments.length; i3 < l2; i3++) {
              segments[i3] = URI.decode(segments[i3]);
            }
          }
          return segments;
        }
        if (!isArray(v2)) {
          v2 = typeof v2 === "string" || v2 instanceof String ? URI.encode(v2) : v2;
        } else {
          for (i3 = 0, l2 = v2.length; i3 < l2; i3++) {
            v2[i3] = URI.encode(v2[i3]);
          }
        }
        return this.segment(segment, v2, build2);
      };
      var q2 = p2.query;
      p2.query = function(v2, build2) {
        if (v2 === true) {
          return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        } else if (typeof v2 === "function") {
          var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          var result = v2.call(this, data);
          this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build2);
          return this;
        } else if (v2 !== void 0 && typeof v2 !== "string") {
          this._parts.query = URI.buildQuery(v2, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build2);
          return this;
        } else {
          return q2.call(this, v2, build2);
        }
      };
      p2.setQuery = function(name, value, build2) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof name === "string" || name instanceof String) {
          data[name] = value !== void 0 ? value : null;
        } else if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              data[key] = name[key];
            }
          }
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build2 = value;
        }
        this.build(!build2);
        return this;
      };
      p2.addQuery = function(name, value, build2) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.addQuery(data, name, value === void 0 ? null : value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build2 = value;
        }
        this.build(!build2);
        return this;
      };
      p2.removeQuery = function(name, value, build2) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.removeQuery(data, name, value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build2 = value;
        }
        this.build(!build2);
        return this;
      };
      p2.hasQuery = function(name, value, withinArray) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.hasQuery(data, name, value, withinArray);
      };
      p2.setSearch = p2.setQuery;
      p2.addSearch = p2.addQuery;
      p2.removeSearch = p2.removeQuery;
      p2.hasSearch = p2.hasQuery;
      p2.normalize = function() {
        if (this._parts.urn) {
          return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        }
        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      };
      p2.normalizeProtocol = function(build2) {
        if (typeof this._parts.protocol === "string") {
          this._parts.protocol = this._parts.protocol.toLowerCase();
          this.build(!build2);
        }
        return this;
      };
      p2.normalizeHostname = function(build2) {
        if (this._parts.hostname) {
          if (this.is("IDN") && punycode) {
            this._parts.hostname = punycode.toASCII(this._parts.hostname);
          } else if (this.is("IPv6") && IPv6) {
            this._parts.hostname = IPv6.best(this._parts.hostname);
          }
          this._parts.hostname = this._parts.hostname.toLowerCase();
          this.build(!build2);
        }
        return this;
      };
      p2.normalizePort = function(build2) {
        if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
          this._parts.port = null;
          this.build(!build2);
        }
        return this;
      };
      p2.normalizePath = function(build2) {
        var _path = this._parts.path;
        if (!_path) {
          return this;
        }
        if (this._parts.urn) {
          this._parts.path = URI.recodeUrnPath(this._parts.path);
          this.build(!build2);
          return this;
        }
        if (this._parts.path === "/") {
          return this;
        }
        _path = URI.recodePath(_path);
        var _was_relative;
        var _leadingParents = "";
        var _parent, _pos;
        if (_path.charAt(0) !== "/") {
          _was_relative = true;
          _path = "/" + _path;
        }
        if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
          _path += "/";
        }
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
        if (_was_relative) {
          _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
          if (_leadingParents) {
            _leadingParents = _leadingParents[0];
          }
        }
        while (true) {
          _parent = _path.search(/\/\.\.(\/|$)/);
          if (_parent === -1) {
            break;
          } else if (_parent === 0) {
            _path = _path.substring(3);
            continue;
          }
          _pos = _path.substring(0, _parent).lastIndexOf("/");
          if (_pos === -1) {
            _pos = _parent;
          }
          _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        if (_was_relative && this.is("relative")) {
          _path = _leadingParents + _path.substring(1);
        }
        this._parts.path = _path;
        this.build(!build2);
        return this;
      };
      p2.normalizePathname = p2.normalizePath;
      p2.normalizeQuery = function(build2) {
        if (typeof this._parts.query === "string") {
          if (!this._parts.query.length) {
            this._parts.query = null;
          } else {
            this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
          }
          this.build(!build2);
        }
        return this;
      };
      p2.normalizeFragment = function(build2) {
        if (!this._parts.fragment) {
          this._parts.fragment = null;
          this.build(!build2);
        }
        return this;
      };
      p2.normalizeSearch = p2.normalizeQuery;
      p2.normalizeHash = p2.normalizeFragment;
      p2.iso8859 = function() {
        var e3 = URI.encode;
        var d2 = URI.decode;
        URI.encode = escape;
        URI.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          URI.encode = e3;
          URI.decode = d2;
        }
        return this;
      };
      p2.unicode = function() {
        var e3 = URI.encode;
        var d2 = URI.decode;
        URI.encode = strictEncodeURIComponent;
        URI.decode = unescape;
        try {
          this.normalize();
        } finally {
          URI.encode = e3;
          URI.decode = d2;
        }
        return this;
      };
      p2.readable = function() {
        var uri = this.clone();
        uri.username("").password("").normalize();
        var t3 = "";
        if (uri._parts.protocol) {
          t3 += uri._parts.protocol + "://";
        }
        if (uri._parts.hostname) {
          if (uri.is("punycode") && punycode) {
            t3 += punycode.toUnicode(uri._parts.hostname);
            if (uri._parts.port) {
              t3 += ":" + uri._parts.port;
            }
          } else {
            t3 += uri.host();
          }
        }
        if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
          t3 += "/";
        }
        t3 += uri.path(true);
        if (uri._parts.query) {
          var q3 = "";
          for (var i3 = 0, qp = uri._parts.query.split("&"), l2 = qp.length; i3 < l2; i3++) {
            var kv = (qp[i3] || "").split("=");
            q3 += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            if (kv[1] !== void 0) {
              q3 += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            }
          }
          t3 += "?" + q3.substring(1);
        }
        t3 += URI.decodeQuery(uri.hash(), true);
        return t3;
      };
      p2.absoluteTo = function(base) {
        var resolved = this.clone();
        var properties = ["protocol", "username", "password", "hostname", "port"];
        var basedir, i3, p3;
        if (this._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        if (!(base instanceof URI)) {
          base = new URI(base);
        }
        if (resolved._parts.protocol) {
          return resolved;
        } else {
          resolved._parts.protocol = base._parts.protocol;
        }
        if (this._parts.hostname) {
          return resolved;
        }
        for (i3 = 0; p3 = properties[i3]; i3++) {
          resolved._parts[p3] = base._parts[p3];
        }
        if (!resolved._parts.path) {
          resolved._parts.path = base._parts.path;
          if (!resolved._parts.query) {
            resolved._parts.query = base._parts.query;
          }
        } else {
          if (resolved._parts.path.substring(-2) === "..") {
            resolved._parts.path += "/";
          }
          if (resolved.path().charAt(0) !== "/") {
            basedir = base.directory();
            basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
            resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
            resolved.normalizePath();
          }
        }
        resolved.build();
        return resolved;
      };
      p2.relativeTo = function(base) {
        var relative = this.clone().normalize();
        var relativeParts, baseParts, common, relativePath, basePath;
        if (relative._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        base = new URI(base).normalize();
        relativeParts = relative._parts;
        baseParts = base._parts;
        relativePath = relative.path();
        basePath = base.path();
        if (relativePath.charAt(0) !== "/") {
          throw new Error("URI is already relative");
        }
        if (basePath.charAt(0) !== "/") {
          throw new Error("Cannot calculate a URI relative to another relative URI");
        }
        if (relativeParts.protocol === baseParts.protocol) {
          relativeParts.protocol = null;
        }
        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
          return relative.build();
        }
        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
          return relative.build();
        }
        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
          relativeParts.hostname = null;
          relativeParts.port = null;
        } else {
          return relative.build();
        }
        if (relativePath === basePath) {
          relativeParts.path = "";
          return relative.build();
        }
        common = URI.commonPath(relativePath, basePath);
        if (!common) {
          return relative.build();
        }
        var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
        return relative.build();
      };
      p2.equals = function(uri) {
        var one = this.clone();
        var two = new URI(uri);
        var one_map = {};
        var two_map = {};
        var checked = {};
        var one_query, two_query, key;
        one.normalize();
        two.normalize();
        if (one.toString() === two.toString()) {
          return true;
        }
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");
        if (one.toString() !== two.toString()) {
          return false;
        }
        if (one_query.length !== two_query.length) {
          return false;
        }
        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
        two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key in one_map) {
          if (hasOwn.call(one_map, key)) {
            if (!isArray(one_map[key])) {
              if (one_map[key] !== two_map[key]) {
                return false;
              }
            } else if (!arraysEqual(one_map[key], two_map[key])) {
              return false;
            }
            checked[key] = true;
          }
        }
        for (key in two_map) {
          if (hasOwn.call(two_map, key)) {
            if (!checked[key]) {
              return false;
            }
          }
        }
        return true;
      };
      p2.preventInvalidHostname = function(v2) {
        this._parts.preventInvalidHostname = !!v2;
        return this;
      };
      p2.duplicateQueryParameters = function(v2) {
        this._parts.duplicateQueryParameters = !!v2;
        return this;
      };
      p2.escapeQuerySpace = function(v2) {
        this._parts.escapeQuerySpace = !!v2;
        return this;
      };
      return URI;
    });
  }
});

// ../../node_modules/@stoplight/json-ref-resolver/uri.js
var require_uri = __commonJS({
  "../../node_modules/@stoplight/json-ref-resolver/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendedURI = void 0;
    var BaseURI = require_URI();
    var ExtendedURI = class extends BaseURI {
      constructor(_value) {
        super(_value);
        this._value = _value.trim();
      }
      get length() {
        return this._value.length;
      }
    };
    exports.ExtendedURI = ExtendedURI;
  }
});

// ../../node_modules/@stoplight/json-ref-resolver/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/@stoplight/json-ref-resolver/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uriIsJSONPointer = exports.uriToJSONPointer = exports.addToJSONPointer = void 0;
    var replace = (str, find2, repl) => {
      const orig = str.toString();
      let res = "";
      let rem = orig;
      let beg = 0;
      let end = rem.indexOf(find2);
      while (end > -1) {
        res += orig.substring(beg, beg + end) + repl;
        rem = rem.substring(end + find2.length, rem.length);
        beg += end + find2.length;
        end = rem.indexOf(find2);
      }
      if (rem.length > 0) {
        res += orig.substring(orig.length - rem.length, orig.length);
      }
      return res;
    };
    var encodeFragmentSegment = (segment) => {
      return replace(replace(segment, "~", "~0"), "/", "~1");
    };
    var addToJSONPointer = (pointer, part) => {
      return `${pointer}/${encodeFragmentSegment(part)}`;
    };
    exports.addToJSONPointer = addToJSONPointer;
    var uriToJSONPointer = (uri) => {
      if ("length" in uri && uri.length === 0) {
        return "";
      }
      return uri.fragment() !== "" ? `#${uri.fragment()}` : uri.href() === "" ? "#" : "";
    };
    exports.uriToJSONPointer = uriToJSONPointer;
    var uriIsJSONPointer = (ref) => {
      return (!("length" in ref) || ref.length > 0) && ref.path() === "";
    };
    exports.uriIsJSONPointer = uriIsJSONPointer;
  }
});

// ../../node_modules/@stoplight/json-ref-resolver/crawler.js
var require_crawler = __commonJS({
  "../../node_modules/@stoplight/json-ref-resolver/crawler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResolveCrawler = void 0;
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var dependency_graph_1 = require_dep_graph();
    var get4 = require("lodash/get");
    var Utils = require_utils3();
    var ResolveCrawler = class {
      constructor(runner, jsonPointer, _resolved) {
        this._resolved = _resolved;
        this.resolvers = [];
        this.pointerGraph = new dependency_graph_1.DepGraph({ circular: true });
        this.pointerStemGraph = new dependency_graph_1.DepGraph({ circular: true });
        this.computeGraph = (target, parentPath = [], parentPointer = "#", pointerStack = []) => {
          if (!parentPointer)
            parentPointer = "#";
          let ref = this._runner.computeRef({
            val: target,
            jsonPointer: parentPointer,
            pointerStack
          });
          if (ref !== void 0) {
            this._resolveRef({
              ref,
              val: target,
              parentPath,
              pointerStack,
              parentPointer,
              cacheKey: parentPointer,
              resolvingPointer: this.jsonPointer
            });
          } else if (typeof target === "object") {
            for (const key in target) {
              if (!target.hasOwnProperty(key))
                continue;
              const val = target[key];
              const currentPointer = Utils.addToJSONPointer(parentPointer, key);
              ref = this._runner.computeRef({
                key,
                val,
                jsonPointer: currentPointer,
                pointerStack
              });
              parentPath.push(key);
              if (ref !== void 0) {
                this._resolveRef({
                  ref,
                  val,
                  parentPath,
                  parentPointer: currentPointer,
                  pointerStack,
                  cacheKey: Utils.uriToJSONPointer(ref),
                  resolvingPointer: this.jsonPointer
                });
              } else if (typeof val === "object") {
                this.computeGraph(val, parentPath, currentPointer, pointerStack);
              }
              parentPath.pop();
            }
          }
        };
        this._resolveRef = (opts) => {
          const { pointerStack, parentPath, parentPointer, ref } = opts;
          if (Utils.uriIsJSONPointer(ref)) {
            if (this._runner.dereferenceInline) {
              const targetPointer = Utils.uriToJSONPointer(ref);
              let targetPath;
              try {
                targetPath = (0, json_1.pointerToPath)(targetPointer);
              } catch (_a) {
                this._resolved.errors.push({
                  code: "PARSE_POINTER",
                  message: `'${ref}' JSON pointer is invalid`,
                  uri: this._runner.baseUri,
                  uriStack: this._runner.uriStack,
                  pointerStack: [],
                  path: []
                });
                return;
              }
              let referencesParent = targetPath.length > 0;
              for (const i3 in targetPath) {
                if (parentPath[i3] !== targetPath[i3]) {
                  referencesParent = false;
                  break;
                }
              }
              if (referencesParent)
                return;
              if (!this.pointerStemGraph.hasNode(targetPointer)) {
                this.pointerStemGraph.addNode(targetPointer);
              }
              let stem = "#";
              let tail = "";
              for (let i3 = 0; i3 < parentPath.length; i3++) {
                const part = parentPath[i3];
                if (part === targetPath[i3]) {
                  stem += `/${part}`;
                } else {
                  tail += `/${part}`;
                  const dep = `${stem}${tail}`;
                  if (dep !== parentPointer && dep !== targetPointer) {
                    if (!this.pointerStemGraph.hasNode(dep)) {
                      this.pointerStemGraph.addNode(dep);
                    }
                    this.pointerStemGraph.addDependency(dep, targetPointer);
                  }
                }
              }
              if (!this.pointerGraph.hasNode(parentPointer)) {
                this.pointerGraph.addNode(parentPointer);
              }
              if (!this.pointerGraph.hasNode(targetPointer)) {
                this.pointerGraph.addNode(targetPointer);
              }
              const targetRef = `${this._runner.baseUri.toString()}${targetPointer}`;
              if (!this._runner.graph.hasNode(targetRef))
                this._runner.graph.addNode(targetRef, { refMap: {} });
              if (this._runner.root !== targetRef)
                this._runner.graph.addDependency(this._runner.root, targetRef);
              this.pointerGraph.addDependency(parentPointer, targetPointer);
              if (this.jsonPointer && (pointerStack.length < 2 || !pointerStack.includes(targetPointer))) {
                pointerStack.push(targetPointer);
                this.computeGraph(get4(this._runner.source, targetPath), targetPath, targetPointer, pointerStack);
                pointerStack.pop();
              }
            }
          } else {
            const remoteRef = ref.toString();
            if (!this._runner.graph.hasNode(remoteRef))
              this._runner.graph.addNode(remoteRef, { refMap: {} });
            if (this._runner.root !== remoteRef)
              this._runner.graph.addDependency(this._runner.root, remoteRef);
            if (this._runner.dereferenceRemote && !this._runner.atMaxUriDepth()) {
              this.resolvers.push(this._runner.lookupAndResolveUri(opts));
            }
          }
        };
        this.jsonPointer = jsonPointer;
        this._runner = runner;
      }
    };
    exports.ResolveCrawler = ResolveCrawler;
  }
});

// ../../node_modules/fast-memoize/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/fast-memoize/src/index.js"(exports, module2) {
    "use strict";
    function memoize(fn, options) {
      var cache2 = options && options.cache ? options.cache : cacheDefault;
      var serializer = options && options.serializer ? options.serializer : serializerDefault;
      var strategy = options && options.strategy ? options.strategy : strategyDefault;
      return strategy(fn, {
        cache: cache2,
        serializer
      });
    }
    function isPrimitive(value) {
      return value == null || typeof value === "number" || typeof value === "boolean";
    }
    function monadic(fn, cache2, serializer, arg) {
      var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
      var computedValue = cache2.get(cacheKey);
      if (typeof computedValue === "undefined") {
        computedValue = fn.call(this, arg);
        cache2.set(cacheKey, computedValue);
      }
      return computedValue;
    }
    function variadic(fn, cache2, serializer) {
      var args = Array.prototype.slice.call(arguments, 3);
      var cacheKey = serializer(args);
      var computedValue = cache2.get(cacheKey);
      if (typeof computedValue === "undefined") {
        computedValue = fn.apply(this, args);
        cache2.set(cacheKey, computedValue);
      }
      return computedValue;
    }
    function assemble(fn, context, strategy, cache2, serialize) {
      return strategy.bind(
        context,
        fn,
        cache2,
        serialize
      );
    }
    function strategyDefault(fn, options) {
      var strategy = fn.length === 1 ? monadic : variadic;
      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      );
    }
    function strategyVariadic(fn, options) {
      var strategy = variadic;
      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      );
    }
    function strategyMonadic(fn, options) {
      var strategy = monadic;
      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      );
    }
    function serializerDefault() {
      return JSON.stringify(arguments);
    }
    function ObjectWithoutPrototypeCache() {
      this.cache = /* @__PURE__ */ Object.create(null);
    }
    ObjectWithoutPrototypeCache.prototype.has = function(key) {
      return key in this.cache;
    };
    ObjectWithoutPrototypeCache.prototype.get = function(key) {
      return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
      this.cache[key] = value;
    };
    var cacheDefault = {
      create: function create() {
        return new ObjectWithoutPrototypeCache();
      }
    };
    module2.exports = memoize;
    module2.exports.strategies = {
      variadic: strategyVariadic,
      monadic: strategyMonadic
    };
  }
});

// ../../node_modules/@stoplight/json-ref-resolver/runner.js
var require_runner = __commonJS({
  "../../node_modules/@stoplight/json-ref-resolver/runner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResolveRunner = exports.defaultGetRef = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var path_1 = (init_index_es(), __toCommonJS(index_es_exports));
    var dependency_graph_1 = require_dep_graph();
    var immer_1 = require_dist4();
    var get4 = require("lodash/get");
    var set = require_set2();
    var URI = require_URI();
    var uri_1 = require_uri();
    var cache_1 = require_cache();
    var crawler_1 = require_crawler();
    var Utils = require_utils3();
    var memoize = require_src3();
    var resolveRunnerCount = 0;
    var defaultGetRef = (key, val) => {
      if (val && typeof val === "object" && typeof val.$ref === "string")
        return val.$ref;
      return;
    };
    exports.defaultGetRef = defaultGetRef;
    var ResolveRunner = class _ResolveRunner {
      constructor(source, graph = new dependency_graph_1.DepGraph({ circular: true }), opts = {}) {
        this.ctx = {};
        this.computeRef = (opts2) => {
          const refStr = this.getRef(opts2.key, opts2.val);
          if (refStr === void 0)
            return;
          let ref = new uri_1.ExtendedURI(refStr);
          if (refStr[0] !== "#") {
            const isFile = this.isFile(ref);
            if (isFile) {
              let absRef = ref.toString();
              if (!ref.is("absolute")) {
                if (this.baseUri.toString()) {
                  absRef = (0, path_1.join)((0, path_1.dirname)(this.baseUri.toString()), (0, path_1.stripRoot)(absRef));
                } else {
                  absRef = "";
                }
              }
              if (absRef) {
                ref = new URI((0, path_1.toFSPath)(absRef)).fragment(ref.fragment());
              }
            } else if (ref.scheme().includes("http") || ref.scheme() === "" && this.baseUri.scheme().includes("http")) {
              if (this.baseUri.authority() !== "" && ref.authority() === "") {
                ref = ref.absoluteTo(this.baseUri);
              }
            }
          }
          if (String(ref).length > 0 && this.isFile(this.baseUri) && this.isFile(ref) && this.baseUri.path() === ref.path()) {
            ref = new uri_1.ExtendedURI(`#${ref.fragment()}`);
          }
          if (this.transformRef) {
            return this.transformRef(Object.assign(Object.assign({}, opts2), { ref, uri: this.baseUri }), this.ctx);
          }
          return ref;
        };
        this.atMaxUriDepth = () => {
          return this.uriStack.length >= 100;
        };
        this.lookupUri = (opts2) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { ref } = opts2;
          let scheme = ref.scheme();
          if (!this.resolvers[scheme] && this.isFile(ref)) {
            scheme = "file";
          }
          const resolver = this.resolvers[scheme];
          if (!resolver) {
            throw new Error(`No resolver defined for scheme '${ref.scheme() || "file"}' in ref ${ref.toString()}`);
          }
          let result = yield resolver.resolve(ref, this.ctx);
          if (this.parseResolveResult) {
            try {
              const parsed = yield this.parseResolveResult({
                uriResult: result,
                result,
                targetAuthority: ref,
                parentAuthority: this.baseUri,
                parentPath: opts2.parentPath,
                fragment: opts2.fragment
              });
              result = parsed.result;
            } catch (e3) {
              throw new Error(`Could not parse remote reference response for '${ref.toString()}' - ${String(e3)}`);
            }
          }
          return new _ResolveRunner(result, this.graph, {
            depth: this.depth + 1,
            baseUri: ref.toString(),
            root: ref,
            uriStack: this.uriStack,
            uriCache: this.uriCache,
            resolvers: this.resolvers,
            transformRef: this.transformRef,
            parseResolveResult: this.parseResolveResult,
            transformDereferenceResult: this.transformDereferenceResult,
            dereferenceRemote: this.dereferenceRemote,
            dereferenceInline: this.dereferenceInline,
            ctx: this.ctx
          });
        });
        this.lookupAndResolveUri = (opts2) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { val, ref, resolvingPointer, parentPointer, pointerStack } = opts2;
          const parentPath = opts2.parentPath ? opts2.parentPath.slice() : [];
          const uriCacheKey = this.computeUriCacheKey(ref);
          const lookupResult = {
            uri: ref,
            pointerStack,
            targetPath: resolvingPointer === parentPointer ? [] : parentPath
          };
          if (this.uriStack.includes(uriCacheKey)) {
            lookupResult.resolved = {
              result: val,
              graph: this.graph,
              refMap: {},
              errors: [],
              runner: this
            };
            return lookupResult;
          } else {
            let uriResolver;
            const currentAuthority = this.baseUri.toString();
            const newUriStack = currentAuthority && this.depth !== 0 ? currentAuthority : null;
            try {
              if (this.atMaxUriDepth()) {
                throw new Error(`Max uri depth (${this.uriStack.length}) reached. Halting, this is probably a circular loop.`);
              }
              uriResolver = yield this.lookupUri({
                ref: ref.clone().fragment(""),
                fragment: ref.fragment(),
                cacheKey: uriCacheKey,
                parentPath
              });
              if (newUriStack) {
                uriResolver.uriStack = uriResolver.uriStack.concat(newUriStack);
              }
            } catch (e3) {
              lookupResult.error = {
                code: "RESOLVE_URI",
                message: String(e3),
                uri: ref,
                uriStack: newUriStack ? this.uriStack.concat(newUriStack) : this.uriStack,
                pointerStack,
                path: parentPath
              };
            }
            if (uriResolver) {
              lookupResult.resolved = yield uriResolver.resolve({
                jsonPointer: Utils.uriToJSONPointer(ref),
                parentPath
              });
              if (lookupResult.resolved.errors.length) {
                for (const error of lookupResult.resolved.errors) {
                  if (error.code === "POINTER_MISSING" && error.path.join("/") === ref.fragment().slice(1)) {
                    const errorPathInResult = ref.fragment ? (0, json_1.trimStart)(error.path, (0, json_1.trimStart)(ref.fragment(), "/").split("/")) : error.path;
                    if (errorPathInResult && errorPathInResult.length) {
                      set(lookupResult.resolved.result, errorPathInResult, val);
                    } else if (lookupResult.resolved.result) {
                      lookupResult.resolved.result = val;
                    }
                  }
                }
              }
            }
          }
          return lookupResult;
        });
        this.id = resolveRunnerCount += 1;
        this.depth = opts.depth || 0;
        this._source = source;
        this.resolvers = opts.resolvers || {};
        const baseUri = opts.baseUri || "";
        let uri = new URI(baseUri || "");
        if (this.isFile(uri)) {
          uri = new URI((0, path_1.toFSPath)(baseUri));
        }
        this.baseUri = uri;
        this.uriStack = opts.uriStack || [];
        this.uriCache = opts.uriCache || new cache_1.Cache();
        this.root = opts.root && opts.root.toString() || this.baseUri.toString() || "root";
        this.graph = graph;
        if (!this.graph.hasNode(this.root)) {
          this.graph.addNode(this.root, { refMap: {}, data: this._source });
        }
        if (this.baseUri && this.depth === 0) {
          this.uriCache.set(this.computeUriCacheKey(this.baseUri), this);
        }
        this.getRef = opts.getRef || exports.defaultGetRef;
        this.transformRef = opts.transformRef;
        if (this.depth) {
          this.dereferenceInline = true;
        } else {
          this.dereferenceInline = typeof opts.dereferenceInline !== "undefined" ? opts.dereferenceInline : true;
        }
        this.dereferenceRemote = typeof opts.dereferenceRemote !== "undefined" ? opts.dereferenceRemote : true;
        this.parseResolveResult = opts.parseResolveResult;
        this.transformDereferenceResult = opts.transformDereferenceResult;
        this.ctx = opts.ctx;
        this.lookupUri = memoize(this.lookupUri, {
          serializer: this._cacheKeySerializer,
          cache: {
            create: () => {
              return this.uriCache;
            }
          }
        });
      }
      get source() {
        return this._source;
      }
      resolve(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const resolved = {
            result: this.source,
            graph: this.graph,
            refMap: {},
            errors: [],
            runner: this
          };
          let targetPath;
          const jsonPointer = opts && opts.jsonPointer && opts.jsonPointer.trim();
          if (jsonPointer && jsonPointer !== "#" && jsonPointer !== "#/") {
            try {
              targetPath = (0, json_1.pointerToPath)(jsonPointer);
            } catch (_a) {
              resolved.errors.push({
                code: "PARSE_POINTER",
                message: `'${jsonPointer}' JSON pointer is invalid`,
                uri: this.baseUri,
                uriStack: this.uriStack,
                pointerStack: [],
                path: []
              });
              return resolved;
            }
            resolved.result = get4(resolved.result, targetPath);
          }
          if (resolved.result === void 0) {
            resolved.errors.push({
              code: "POINTER_MISSING",
              message: `'${jsonPointer}' does not exist @ '${this.baseUri.toString()}'`,
              uri: this.baseUri,
              uriStack: this.uriStack,
              pointerStack: [],
              path: targetPath || []
            });
            return resolved;
          }
          const crawler = new crawler_1.ResolveCrawler(this, jsonPointer, resolved);
          crawler.computeGraph(resolved.result, targetPath, jsonPointer || "");
          let uriResults = [];
          if (crawler.resolvers.length) {
            uriResults = yield Promise.all(crawler.resolvers);
          }
          if (uriResults.length) {
            for (const r3 of uriResults) {
              let resolvedTargetPath = r3.targetPath;
              if (!resolvedTargetPath.length)
                resolvedTargetPath = targetPath || [];
              resolved.refMap[String(this.baseUri.clone().fragment((0, json_1.pathToPointer)(resolvedTargetPath)))] = String(r3.uri);
              this._setGraphNodeEdge(String(this.root), (0, json_1.pathToPointer)(resolvedTargetPath), String(r3.uri));
              if (r3.error) {
                resolved.errors.push(r3.error);
              }
              if (!r3.resolved)
                continue;
              if (r3.resolved.errors) {
                resolved.errors = resolved.errors.concat(r3.resolved.errors);
              }
              if (r3.resolved.result === void 0)
                continue;
              this._source = (0, immer_1.default)(this._source, (draft) => {
                if (r3.resolved) {
                  if (!resolvedTargetPath.length) {
                    return r3.resolved.result;
                  } else {
                    set(draft, resolvedTargetPath, r3.resolved.result);
                    this._setGraphNodeData(String(r3.uri), r3.resolved.result);
                  }
                }
              });
            }
          }
          if (typeof this._source === "object") {
            if (this.dereferenceInline) {
              this._source = (0, immer_1.default)(this._source, (draft) => {
                let processOrder = [];
                try {
                  processOrder = crawler.pointerGraph.overallOrder();
                  for (const pointer of processOrder) {
                    const dependants = crawler.pointerGraph.dependantsOf(pointer);
                    if (!dependants.length)
                      continue;
                    const pointerPath = (0, json_1.pointerToPath)(pointer);
                    const val = pointerPath.length === 0 ? (0, immer_1.original)(draft) : get4(draft, pointerPath);
                    for (const dependant of dependants) {
                      let isCircular;
                      const dependantPath = (0, json_1.pointerToPath)(dependant);
                      const dependantStems = crawler.pointerStemGraph.dependenciesOf(pointer);
                      for (const stem of dependantStems) {
                        if ((0, json_1.startsWith)(dependantPath, (0, json_1.pointerToPath)(stem))) {
                          isCircular = true;
                          break;
                        }
                      }
                      if (isCircular)
                        continue;
                      resolved.refMap[(0, json_1.pathToPointer)(dependantPath)] = (0, json_1.pathToPointer)(pointerPath);
                      this._setGraphNodeEdge(this.root, (0, json_1.pathToPointer)(dependantPath), (0, json_1.pathToPointer)(pointerPath));
                      if (val !== void 0) {
                        set(draft, dependantPath, val);
                        this._setGraphNodeData((0, json_1.pathToPointer)(pointerPath), val);
                      } else {
                        resolved.errors.push({
                          code: "POINTER_MISSING",
                          message: `'${pointer}' does not exist`,
                          path: dependantPath,
                          uri: this.baseUri,
                          uriStack: this.uriStack,
                          pointerStack: []
                        });
                      }
                    }
                  }
                } catch (e3) {
                }
              });
            }
            if (targetPath) {
              resolved.result = get4(this._source, targetPath);
            } else {
              resolved.result = this._source;
            }
          } else {
            resolved.result = this._source;
          }
          if (this.transformDereferenceResult) {
            const ref = new URI(jsonPointer || "");
            try {
              const { result, error } = yield this.transformDereferenceResult({
                source: this.source,
                result: resolved.result,
                targetAuthority: ref,
                parentAuthority: this.baseUri,
                parentPath: opts ? opts.parentPath || [] : [],
                fragment: ref.fragment()
              });
              resolved.result = result;
              if (error) {
                throw new Error(`Could not transform dereferenced result for '${ref.toString()}' - ${String(error)}`);
              }
            } catch (e3) {
              resolved.errors.push({
                code: "TRANSFORM_DEREFERENCED",
                message: `Error: Could not transform dereferenced result for '${this.baseUri.toString()}${ref.fragment() !== "" ? `#${ref.fragment()}` : ``}' - ${String(e3)}`,
                uri: ref,
                uriStack: this.uriStack,
                pointerStack: [],
                path: targetPath
              });
            }
          }
          this._setGraphNodeData(this.root, this._source);
          return resolved;
        });
      }
      _cacheKeySerializer(sOpts) {
        return sOpts && typeof sOpts === "object" && sOpts.cacheKey ? sOpts.cacheKey : JSON.stringify(arguments);
      }
      computeUriCacheKey(ref) {
        return ref.clone().fragment("").toString();
      }
      isFile(ref) {
        const scheme = ref.scheme();
        if (scheme === "file")
          return true;
        if (!scheme) {
          if (ref.toString().charAt(0) === "/")
            return true;
          if (this.baseUri) {
            const uriScheme = this.baseUri.scheme();
            return Boolean(!uriScheme || uriScheme === "file" || !this.resolvers[uriScheme]);
          }
        } else if (!this.resolvers[scheme]) {
          return true;
        }
        return false;
      }
      _setGraphNodeData(nodeId, data) {
        if (!this.graph.hasNode(nodeId))
          return;
        const graphNodeData = this.graph.getNodeData(nodeId) || {};
        graphNodeData.data = data;
        this.graph.setNodeData(nodeId, graphNodeData);
      }
      _setGraphNodeEdge(nodeId, fromPointer, toNodeId) {
        if (!this.graph.hasNode(nodeId))
          return;
        const graphNodeData = this.graph.getNodeData(nodeId) || {};
        graphNodeData.refMap = graphNodeData.refMap || {};
        graphNodeData.refMap[fromPointer] = toNodeId;
        this.graph.setNodeData(nodeId, graphNodeData);
      }
    };
    exports.ResolveRunner = ResolveRunner;
  }
});

// ../../node_modules/@stoplight/json-ref-resolver/resolver.js
var require_resolver = __commonJS({
  "../../node_modules/@stoplight/json-ref-resolver/resolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Resolver = void 0;
    var dependency_graph_1 = require_dep_graph();
    var cache_1 = require_cache();
    var runner_1 = require_runner();
    var Resolver = class {
      constructor(opts = {}) {
        this.ctx = {};
        this.uriCache = opts.uriCache || new cache_1.Cache();
        this.resolvers = opts.resolvers || {};
        this.getRef = opts.getRef;
        this.transformRef = opts.transformRef;
        this.dereferenceInline = typeof opts.dereferenceInline !== "undefined" ? opts.dereferenceInline : true;
        this.dereferenceRemote = typeof opts.dereferenceRemote !== "undefined" ? opts.dereferenceRemote : true;
        this.parseResolveResult = opts.parseResolveResult;
        this.transformDereferenceResult = opts.transformDereferenceResult;
        this.ctx = opts.ctx;
      }
      resolve(source, opts = {}) {
        const graph = new dependency_graph_1.DepGraph({ circular: true });
        const runner = new runner_1.ResolveRunner(source, graph, Object.assign(Object.assign({ uriCache: this.uriCache, resolvers: this.resolvers, getRef: this.getRef, transformRef: this.transformRef, dereferenceInline: this.dereferenceInline, dereferenceRemote: this.dereferenceRemote, parseResolveResult: this.parseResolveResult, transformDereferenceResult: this.transformDereferenceResult }, opts), { ctx: Object.assign({}, this.ctx || {}, opts.ctx || {}) }));
        return runner.resolve(opts);
      }
    };
    exports.Resolver = Resolver;
  }
});

// ../../node_modules/@stoplight/json-ref-resolver/index.js
var require_json_ref_resolver = __commonJS({
  "../../node_modules/@stoplight/json-ref-resolver/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultGetRef = exports.Cache = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_resolver(), exports);
    var cache_1 = require_cache();
    Object.defineProperty(exports, "Cache", { enumerable: true, get: function() {
      return cache_1.Cache;
    } });
    var runner_1 = require_runner();
    Object.defineProperty(exports, "defaultGetRef", { enumerable: true, get: function() {
      return runner_1.defaultGetRef;
    } });
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/utils/decodeSegmentFragment.js
var require_decodeSegmentFragment = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/utils/decodeSegmentFragment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSegmentFragment = void 0;
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    function decodeSegmentFragment(segment) {
      return typeof segment !== "string" ? String(segment) : (0, json_1.decodePointerFragment)(segment);
    }
    exports.decodeSegmentFragment = decodeSegmentFragment;
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/utils/printError.js
var require_printError = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/utils/printError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printError = void 0;
    var lodash_1 = require_lodash();
    function printError(maybeError) {
      if ((0, lodash_1.isError)(maybeError)) {
        return maybeError.message;
      }
      return "unknown error";
    }
    exports.printError = printError;
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/utils/printPath.js
var require_printPath = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/utils/printPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printPath = exports.PrintStyle = void 0;
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var PrintStyle;
    (function(PrintStyle2) {
      PrintStyle2["Dot"] = "dot";
      PrintStyle2["Pointer"] = "pointer";
      PrintStyle2["EscapedPointer"] = "escapedPointer";
    })(PrintStyle = exports.PrintStyle || (exports.PrintStyle = {}));
    var isNumeric2 = (input) => typeof input === "number" || !Number.isNaN(Number(input));
    var hasWhitespace = (input) => /\s/.test(input);
    var safeDecodePointerFragment = (segment) => typeof segment === "number" ? segment : (0, json_1.decodePointerFragment)(segment);
    var printDotBracketsSegment = (segment) => {
      if (typeof segment === "number") {
        return `[${segment}]`;
      }
      if (segment.length === 0) {
        return `['']`;
      }
      if (hasWhitespace(segment)) {
        return `['${segment}']`;
      }
      if (isNumeric2(segment)) {
        return `[${segment}]`;
      }
      return null;
    };
    var pathToDotString = (path2) => path2.reduce((output, segment, index3) => {
      var _a;
      return `${output}${(_a = printDotBracketsSegment(segment)) !== null && _a !== void 0 ? _a : `${index3 === 0 ? "" : "."}${segment}`}`;
    }, "");
    var printPath = (path2, style) => {
      switch (style) {
        case PrintStyle.Dot:
          return (0, json_1.decodePointerFragment)(pathToDotString(path2));
        case PrintStyle.Pointer:
          if (path2.length === 0) {
            return "#";
          }
          return `#/${(0, json_1.decodePointerFragment)(path2.join("/"))}`;
        case PrintStyle.EscapedPointer:
          return (0, json_1.pathToPointer)(path2.map(safeDecodePointerFragment));
        default:
          return String(path2);
      }
    };
    exports.printPath = printPath;
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/utils/printValue.js
var require_printValue = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/utils/printValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printValue = void 0;
    var lodash_1 = require_lodash();
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    function printValue(value) {
      if (value === void 0) {
        return "undefined";
      }
      if ((0, lodash_1.isObject)(value)) {
        if (Array.isArray(value)) {
          return "Array[]";
        }
        if (value instanceof RegExp) {
          return String(value.source);
        }
        if (!(0, json_1.isPlainObject)(value) && "constructor" in value && typeof value.constructor.name === "string") {
          return value.constructor.name;
        }
        return "Object{}";
      }
      return JSON.stringify(value);
    }
    exports.printValue = printValue;
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/utils/refs.js
var require_refs = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/utils/refs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getClosestJsonPath = exports.safePointerToPath = exports.getEndRef = exports.traverseObjUntilRef = exports.isAbsoluteRef = exports.startsWithProtocol = void 0;
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var path_1 = (init_index_es(), __toCommonJS(index_es_exports));
    var lodash_1 = require_lodash();
    var PROTOCOL_REGEX = /^[a-z]+:\/\//i;
    var startsWithProtocol = (input) => PROTOCOL_REGEX.test(input);
    exports.startsWithProtocol = startsWithProtocol;
    var isAbsoluteRef = (ref) => (0, path_1.isAbsolute)(ref) || (0, exports.startsWithProtocol)(ref);
    exports.isAbsoluteRef = isAbsoluteRef;
    var traverseObjUntilRef = (obj, path2) => {
      let piece = obj;
      for (const segment of path2.slice()) {
        if (!(0, lodash_1.isObject)(piece)) {
          throw new TypeError("Segment is not a part of the object");
        }
        if (segment in piece) {
          piece = piece[segment];
        } else if ((0, json_1.hasRef)(piece)) {
          return piece.$ref;
        } else {
          throw new Error("Segment is not a part of the object");
        }
        path2.shift();
      }
      if ((0, json_1.isPlainObject)(piece) && (0, json_1.hasRef)(piece) && Object.keys(piece).length === 1) {
        return piece.$ref;
      }
      return null;
    };
    exports.traverseObjUntilRef = traverseObjUntilRef;
    var getEndRef = (refMap, $ref) => {
      while ($ref in refMap) {
        $ref = refMap[$ref];
      }
      return $ref;
    };
    exports.getEndRef = getEndRef;
    var safePointerToPath = (pointer) => {
      const rawPointer = (0, json_1.extractPointerFromRef)(pointer);
      return rawPointer !== null ? (0, json_1.pointerToPath)(rawPointer) : [];
    };
    exports.safePointerToPath = safePointerToPath;
    var getClosestJsonPath = (data, path2) => {
      const closestPath = [];
      if (!(0, lodash_1.isObject)(data))
        return closestPath;
      let piece = data;
      for (const segment of path2) {
        if (!(0, lodash_1.isObject)(piece) || !(segment in piece))
          break;
        closestPath.push(segment);
        piece = piece[segment];
      }
      return closestPath;
    };
    exports.getClosestJsonPath = getClosestJsonPath;
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/utils/index.js
var require_utils4 = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    (0, tslib_1.__exportStar)(require_decodeSegmentFragment(), exports);
    (0, tslib_1.__exportStar)(require_printError(), exports);
    (0, tslib_1.__exportStar)(require_printPath(), exports);
    (0, tslib_1.__exportStar)(require_printValue(), exports);
    (0, tslib_1.__exportStar)(require_refs(), exports);
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/fetch.js
var require_fetch = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/fetch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_REQUEST_OPTIONS = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_fetch_1 = (0, tslib_1.__importDefault)((init_lib(), __toCommonJS(lib_exports)));
    exports.DEFAULT_REQUEST_OPTIONS = {};
    exports.default = async (uri, opts = {}) => {
      return (0, node_fetch_1.default)(uri, { ...opts, ...exports.DEFAULT_REQUEST_OPTIONS });
    };
  }
});

// ../../node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../../node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i3 = 0; i3 < keys.length; ++i3) {
        const key = keys[i3];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i3 = 0; i3 < keys.length; ++i3) {
        const key = keys[i3];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject4(x3) {
      return x3 !== null && typeof x3 === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject4(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i3 = 0; i3 < eventNames.length; ++i3) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i3]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i3 = 0; i3 < arguments.length; ++i3) {
          types[i3] = arguments[i3];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject4(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject4(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject4(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../../node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../../node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports.AbortController = AbortController;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController;
    module2.exports = AbortController;
    module2.exports.AbortController = module2.exports["default"] = AbortController;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/reader.js
var require_reader = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readParsable = exports.readFile = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var path_1 = (init_index_es(), __toCommonJS(index_es_exports));
    var abort_controller_1 = (0, tslib_1.__importDefault)(require_abort_controller());
    var fs8 = (0, tslib_1.__importStar)(require("fs"));
    var lodash_1 = require_lodash();
    var fetch_1 = (0, tslib_1.__importDefault)(require_fetch());
    var printError_1 = require_printError();
    async function readFile(name, opts) {
      if ((0, path_1.isURL)(name)) {
        let response;
        let timeout = null;
        try {
          const requestOpts = {};
          requestOpts.agent = opts.agent;
          if (opts.timeout !== void 0) {
            const controller = new abort_controller_1.default();
            timeout = setTimeout(() => {
              controller.abort();
            }, opts.timeout);
            requestOpts.signal = controller.signal;
          }
          response = await (0, fetch_1.default)(name, requestOpts);
          if (!response.ok)
            throw new Error(response.statusText);
          return await response.text();
        } catch (ex) {
          if ((0, lodash_1.isError)(ex) && ex.name === "AbortError") {
            throw new Error("Timeout");
          } else {
            throw ex;
          }
        } finally {
          if (timeout !== null) {
            clearTimeout(timeout);
          }
        }
      } else {
        try {
          return await new Promise((resolve3, reject) => {
            fs8.readFile(name, opts.encoding, (err, data) => {
              if (err !== null) {
                reject(err);
              } else {
                resolve3(data);
              }
            });
          });
        } catch (ex) {
          throw new Error(`Could not read ${name}: ${(0, printError_1.printError)(ex)}`);
        }
      }
    }
    exports.readFile = readFile;
    async function readParsable(name, opts) {
      try {
        return await readFile(name, opts);
      } catch (ex) {
        throw new Error(`Could not parse ${name}: ${(0, printError_1.printError)(ex)}`);
      }
    }
    exports.readParsable = readParsable;
  }
});

// ../../node_modules/@stoplight/spectral-runtime/dist/index.js
var require_dist5 = __commonJS({
  "../../node_modules/@stoplight/spectral-runtime/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_REQUEST_OPTIONS = exports.fetch = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    (0, tslib_1.__exportStar)(require_utils4(), exports);
    var fetch_1 = require_fetch();
    Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
      return (0, tslib_1.__importDefault)(fetch_1).default;
    } });
    Object.defineProperty(exports, "DEFAULT_REQUEST_OPTIONS", { enumerable: true, get: function() {
      return fetch_1.DEFAULT_REQUEST_OPTIONS;
    } });
    (0, tslib_1.__exportStar)(require_reader(), exports);
  }
});

// ../../node_modules/@stoplight/spectral-ref-resolver/dist/types.js
var require_types3 = __commonJS({
  "../../node_modules/@stoplight/spectral-ref-resolver/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@stoplight/spectral-ref-resolver/dist/index.js
var require_dist6 = __commonJS({
  "../../node_modules/@stoplight/spectral-ref-resolver/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHttpAndFileResolver = exports.ResolverDepGraph = exports.Resolver = exports.httpAndFileResolver = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var json_ref_readers_1 = require_json_ref_readers();
    var json_ref_resolver_1 = require_json_ref_resolver();
    Object.defineProperty(exports, "Resolver", { enumerable: true, get: function() {
      return json_ref_resolver_1.Resolver;
    } });
    var spectral_runtime_1 = require_dist5();
    var dependency_graph_1 = require_dep_graph();
    (0, tslib_1.__exportStar)(require_types3(), exports);
    exports.httpAndFileResolver = createHttpAndFileResolver();
    exports.ResolverDepGraph = dependency_graph_1.DepGraph;
    function createHttpAndFileResolver(opts) {
      const resolveHttp = (0, json_ref_readers_1.createResolveHttp)({ ...spectral_runtime_1.DEFAULT_REQUEST_OPTIONS, ...opts });
      return new json_ref_resolver_1.Resolver({
        resolvers: {
          https: { resolve: resolveHttp },
          http: { resolve: resolveHttp },
          file: { resolve: json_ref_readers_1.resolveFile }
        }
      });
    }
    exports.createHttpAndFileResolver = createHttpAndFileResolver;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/errorMessages.js
var require_errorMessages = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/errorMessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatResolverErrors = exports.formatParserDiagnostics = exports.prettyPrintResolverErrorMessage = exports.getDiagnosticErrorMessage = void 0;
    var types_1 = require_dist();
    var lodash_1 = require_lodash();
    var document_1 = require_document();
    var toUpperCase = (word) => word.toUpperCase();
    var splitWord = (word, end, start) => `${end} ${start.toLowerCase()}`;
    function getDiagnosticErrorMessage(diagnostic) {
      const key = getPropertyKey(diagnostic.path);
      let prettifiedMessage = diagnostic.message.replace(/^[a-z]/, toUpperCase);
      if (diagnostic.code !== "YAMLException") {
        prettifiedMessage = prettifiedMessage.replace(/([a-z])([A-Z])/g, splitWord);
      }
      if (key !== void 0) {
        prettifiedMessage = prettifiedMessage.replace(/(Duplicate key)/, `$1: ${key}`);
      }
      return prettifiedMessage;
    }
    exports.getDiagnosticErrorMessage = getDiagnosticErrorMessage;
    var prettyPrintResolverErrorMessage = (message) => message.replace(/^Error\s*:\s*/, "");
    exports.prettyPrintResolverErrorMessage = prettyPrintResolverErrorMessage;
    var getPropertyKey = (path2) => {
      if (path2 !== void 0 && path2.length > 0) {
        return path2[path2.length - 1];
      }
    };
    function formatParserDiagnostics(diagnostics, source) {
      return diagnostics.map((diagnostic) => {
        var _a;
        return {
          ...diagnostic,
          code: "parser",
          message: getDiagnosticErrorMessage(diagnostic),
          path: (_a = diagnostic.path) !== null && _a !== void 0 ? _a : [],
          ...source !== null ? { source } : null
        };
      });
    }
    exports.formatParserDiagnostics = formatParserDiagnostics;
    var formatResolverErrors = (document2, diagnostics) => {
      return (0, lodash_1.uniqBy)(diagnostics, "message").map((error) => {
        var _a;
        const path2 = [...error.path, "$ref"];
        const range = (_a = document2.getRangeForJsonPath(path2, true)) !== null && _a !== void 0 ? _a : document_1.Document.DEFAULT_RANGE;
        const source = error.uriStack.length > 0 ? error.uriStack[error.uriStack.length - 1] : document2.source;
        return {
          code: "invalid-ref",
          path: path2,
          message: (0, exports.prettyPrintResolverErrorMessage)(error.message),
          severity: types_1.DiagnosticSeverity.Error,
          range,
          ...source !== null ? { source } : null
        };
      });
    };
    exports.formatResolverErrors = formatResolverErrors;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/document.js
var require_document = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/document.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isParsedResult = exports.ParsedDocument = exports.Document = exports.normalizeSource = void 0;
    var path_1 = (init_index_es(), __toCommonJS(index_es_exports));
    var errorMessages_1 = require_errorMessages();
    var spectral_runtime_1 = require_dist5();
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    function normalizeSource(source) {
      if (source === void 0)
        return null;
      return source.length > 0 && !(0, spectral_runtime_1.startsWithProtocol)(source) ? (0, path_1.normalize)(source) : source;
    }
    exports.normalizeSource = normalizeSource;
    var Document = class {
      constructor(input, parser, source) {
        this.input = input;
        this.parser = parser;
        this.parserResult = parser.parse(input);
        this.source = normalizeSource(source);
        this.diagnostics = (0, errorMessages_1.formatParserDiagnostics)(this.parserResult.diagnostics, this.source);
      }
      getRangeForJsonPath(path2, closest) {
        var _a;
        return (_a = this.parser.getLocationForJsonPath(this.parserResult, path2, closest)) === null || _a === void 0 ? void 0 : _a.range;
      }
      trapAccess(obj) {
        return this.parser.trapAccess(obj);
      }
      static get DEFAULT_RANGE() {
        return {
          start: {
            character: 0,
            line: 0
          },
          end: {
            character: 0,
            line: 0
          }
        };
      }
      get data() {
        return this.parserResult.data;
      }
    };
    exports.Document = Document;
    var ParsedDocument = class {
      constructor(parserResult) {
        this.parserResult = parserResult;
        this.source = normalizeSource(parserResult.source);
        this.diagnostics = (0, errorMessages_1.formatParserDiagnostics)(this.parserResult.parsed.diagnostics, this.source);
      }
      trapAccess(obj) {
        return obj;
      }
      getRangeForJsonPath(path2, closest) {
        var _a;
        return (_a = this.parserResult.getLocationForJsonPath(this.parserResult.parsed, path2, closest)) === null || _a === void 0 ? void 0 : _a.range;
      }
      get data() {
        return this.parserResult.parsed.data;
      }
    };
    exports.ParsedDocument = ParsedDocument;
    var isParsedResult = (obj) => (0, json_1.isPlainObject)(obj) && (0, json_1.isPlainObject)(obj.parsed) && typeof obj.getLocationForJsonPath === "function";
    exports.isParsedResult = isParsedResult;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/documentInventory.js
var require_documentInventory = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/documentInventory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentInventory = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var path_1 = (init_index_es(), __toCommonJS(index_es_exports));
    var lodash_1 = require_lodash();
    var document_1 = require_document();
    var errorMessages_1 = require_errorMessages();
    var Parsers = (0, tslib_1.__importStar)(require_dist3());
    var spectral_runtime_1 = require_dist5();
    var DocumentInventory = class _DocumentInventory {
      constructor(document2, resolver) {
        this.document = document2;
        this.resolver = resolver;
        this.diagnostics = [];
        this.parseResolveResult = (resolveOpts) => {
          const source = resolveOpts.targetAuthority.href().replace(/\/$/, "");
          const ext = (0, path_1.extname)(source);
          const content = String(resolveOpts.result);
          const parser = ext === ".json" ? Parsers.Json : Parsers.Yaml;
          const document3 = new document_1.Document(content, parser, source);
          resolveOpts.result = document3.data;
          if (document3.diagnostics.length > 0) {
            this.diagnostics.push(...(0, errorMessages_1.formatParserDiagnostics)(document3.diagnostics, document3.source));
          }
          this.referencedDocuments[source] = document3;
          return Promise.resolve(resolveOpts);
        };
        this.graph = null;
        this.errors = null;
        const cacheKey = resolver.uriCache;
        const cachedDocuments = _DocumentInventory._cachedRemoteDocuments.get(cacheKey);
        if (cachedDocuments !== void 0) {
          this.referencedDocuments = cachedDocuments;
        } else {
          this.referencedDocuments = {};
          _DocumentInventory._cachedRemoteDocuments.set(cacheKey, this.referencedDocuments);
        }
      }
      get source() {
        return this.document.source;
      }
      get unresolved() {
        return this.document.data;
      }
      get formats() {
        var _a;
        return (_a = this.document.formats) !== null && _a !== void 0 ? _a : null;
      }
      async resolve() {
        if (!(0, lodash_1.isObjectLike)(this.document.data)) {
          this.graph = null;
          this.resolved = this.document.data;
          this.errors = null;
          return;
        }
        const resolveResult = await this.resolver.resolve(this.document.data, {
          ...this.document.source !== null ? { baseUri: this.document.source } : null,
          parseResolveResult: this.parseResolveResult
        });
        this.graph = resolveResult.graph;
        this.resolved = resolveResult.result;
        this.errors = (0, errorMessages_1.formatResolverErrors)(this.document, resolveResult.errors);
      }
      findAssociatedItemForPath(path2, resolved) {
        if (!resolved) {
          const newPath = (0, spectral_runtime_1.getClosestJsonPath)(this.unresolved, path2);
          const item = {
            document: this.document,
            path: newPath,
            missingPropertyPath: path2
          };
          return item;
        }
        try {
          const newPath = (0, spectral_runtime_1.getClosestJsonPath)(this.resolved, path2);
          const $ref = (0, spectral_runtime_1.traverseObjUntilRef)(this.unresolved, newPath);
          if ($ref === null) {
            const item2 = {
              document: this.document,
              path: (0, spectral_runtime_1.getClosestJsonPath)(this.unresolved, path2),
              missingPropertyPath: path2
            };
            return item2;
          }
          const missingPropertyPath = newPath.length === 0 ? [] : path2.slice(path2.lastIndexOf(newPath[newPath.length - 1]) + 1);
          let { source } = this;
          if (source === null || this.graph === null) {
            return null;
          }
          let refMap = this.graph.getNodeData(source).refMap;
          let resolvedDoc = this.document;
          const adjustedPath = ["#", ...path2.map(json_1.encodePointerUriFragment).map(String)];
          let refMapKey = "";
          for (const segment of adjustedPath) {
            if (refMapKey.length > 0) {
              refMapKey += "/";
            }
            refMapKey += segment;
            while (refMapKey in refMap) {
              const newRef = refMap[refMapKey];
              if ((0, json_1.isLocalRef)(newRef)) {
                refMapKey = newRef;
              } else {
                const extractedSource = (0, json_1.extractSourceFromRef)(newRef);
                if (extractedSource === null) {
                  const item2 = {
                    document: resolvedDoc,
                    path: (0, spectral_runtime_1.getClosestJsonPath)(resolvedDoc.data, path2),
                    missingPropertyPath: path2
                  };
                  return item2;
                }
                source = (0, spectral_runtime_1.isAbsoluteRef)(extractedSource) ? extractedSource : (0, path_1.resolve)(source, "..", extractedSource);
                const newResolvedDoc = source === this.document.source ? this.document : this.referencedDocuments[source];
                if (newResolvedDoc === null || newResolvedDoc === void 0) {
                  const item2 = {
                    document: resolvedDoc,
                    path: (0, spectral_runtime_1.getClosestJsonPath)(resolvedDoc.data, path2),
                    missingPropertyPath: path2
                  };
                  return item2;
                }
                resolvedDoc = newResolvedDoc;
                refMap = this.graph.getNodeData(source).refMap;
                refMapKey = newRef.indexOf("#") >= 0 ? newRef.slice(newRef.indexOf("#")) : "#";
              }
            }
          }
          const closestPath = (0, spectral_runtime_1.getClosestJsonPath)(resolvedDoc.data, this.convertRefMapKeyToPath(refMapKey));
          const item = {
            document: resolvedDoc,
            path: closestPath,
            missingPropertyPath: [...closestPath, ...missingPropertyPath]
          };
          return item;
        } catch {
          return null;
        }
      }
      convertRefMapKeyToPath(refPath) {
        if (refPath.startsWith("#/")) {
          refPath = refPath.slice(2);
        }
        return refPath.split("/").map(json_1.decodePointerFragment);
      }
    };
    exports.DocumentInventory = DocumentInventory;
    DocumentInventory._cachedRemoteDocuments = /* @__PURE__ */ new WeakMap();
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/runner/utils/results.js
var require_results = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/runner/utils/results.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortResults = exports.compareResults = exports.comparePosition = exports.prepareResults = void 0;
    var computeResultFingerprint = (rule) => {
      let id = String(rule.code);
      if (rule.path.length > 0) {
        id += JSON.stringify(rule.path);
      } else {
        id += JSON.stringify(rule.range);
      }
      if (rule.source !== void 0) {
        id += rule.source;
      }
      if (rule.message !== void 0) {
        id += rule.message;
      }
      return id;
    };
    var prepareResults = (results) => {
      return (0, exports.sortResults)(deduplicateResults(results));
    };
    exports.prepareResults = prepareResults;
    var deduplicateResults = (results) => {
      const fingerprints = /* @__PURE__ */ new Set();
      return results.filter((result) => {
        const fingerprint = computeResultFingerprint(result);
        if (fingerprints.has(fingerprint)) {
          return false;
        }
        fingerprints.add(fingerprint);
        return true;
      });
    };
    var compareCode = (left, right) => {
      if (left === void 0 && right === void 0) {
        return 0;
      }
      if (left === void 0) {
        return -1;
      }
      if (right === void 0) {
        return 1;
      }
      return String(left).localeCompare(String(right), void 0, { numeric: true });
    };
    var compareSource = (left, right) => {
      if (left === void 0 && right === void 0) {
        return 0;
      }
      if (left === void 0) {
        return -1;
      }
      if (right === void 0) {
        return 1;
      }
      return left.localeCompare(right);
    };
    var normalize = (value) => {
      if (value < 0) {
        return -1;
      }
      if (value > 0) {
        return 1;
      }
      return 0;
    };
    var comparePosition = (left, right) => {
      const diffLine = left.line - right.line;
      if (diffLine !== 0) {
        return normalize(diffLine);
      }
      const diffChar = left.character - right.character;
      return normalize(diffChar);
    };
    exports.comparePosition = comparePosition;
    var compareResults = (left, right) => {
      const diffSource = compareSource(left.source, right.source);
      if (diffSource !== 0) {
        return normalize(diffSource);
      }
      const diffStart = (0, exports.comparePosition)(left.range.start, right.range.start);
      if (diffStart !== 0) {
        return diffStart;
      }
      const diffCode = compareCode(left.code, right.code);
      if (diffCode !== 0) {
        return normalize(diffCode);
      }
      const diffPath = left.path.join().localeCompare(right.path.join());
      return normalize(diffPath);
    };
    exports.compareResults = compareResults;
    var sortResults = (results) => {
      return [...results].sort(exports.compareResults);
    };
    exports.sortResults = sortResults;
  }
});

// ../../node_modules/pony-cause/index.js
var require_pony_cause = __commonJS({
  "../../node_modules/pony-cause/index.js"(exports, module2) {
    "use strict";
    var ErrorWithCause = class _ErrorWithCause extends Error {
      /**
       * @param {string} message
       * @param {{ cause?: T }} [options]
       */
      constructor(message, { cause } = {}) {
        super(message);
        this.name = _ErrorWithCause.name;
        if (cause) {
          this.cause = cause;
        }
        this.message = message;
      }
    };
    var findCauseByReference = (err, reference) => {
      if (!err || !reference)
        return;
      if (!(err instanceof Error))
        return;
      if (!(reference.prototype instanceof Error) && // @ts-ignore
      reference !== Error)
        return;
      const seen = /* @__PURE__ */ new Set();
      let currentErr = err;
      while (currentErr && !seen.has(currentErr)) {
        seen.add(currentErr);
        if (currentErr instanceof reference) {
          return currentErr;
        }
        currentErr = getErrorCause(currentErr);
      }
    };
    var getErrorCause = (err) => {
      if (!err)
        return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return causeResult instanceof Error ? causeResult : void 0;
      } else {
        return cause instanceof Error ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!(err instanceof Error))
        return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!(err instanceof Error))
        return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      ErrorWithCause,
      findCauseByReference,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// ../../node_modules/jsonpath-plus/dist/index-node-cjs.cjs
var require_index_node_cjs = __commonJS({
  "../../node_modules/jsonpath-plus/dist/index-node-cjs.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vm = require("vm");
    function _interopDefaultLegacy(e3) {
      return e3 && typeof e3 === "object" && "default" in e3 ? e3 : { "default": e3 };
    }
    var vm__default = /* @__PURE__ */ _interopDefaultLegacy(vm);
    var {
      hasOwnProperty: hasOwnProp
    } = Object.prototype;
    function push(arr, item) {
      arr = arr.slice();
      arr.push(item);
      return arr;
    }
    function unshift(item, arr) {
      arr = arr.slice();
      arr.unshift(item);
      return arr;
    }
    var NewError = class extends Error {
      /**
       * @param {AnyResult} value The evaluated scalar value
       */
      constructor(value) {
        super('JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)');
        this.avoidNew = true;
        this.value = value;
        this.name = "NewError";
      }
    };
    function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
      if (!(this instanceof JSONPath)) {
        try {
          return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        } catch (e3) {
          if (!e3.avoidNew) {
            throw e3;
          }
          return e3.value;
        }
      }
      if (typeof opts === "string") {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = null;
      }
      const optObj = opts && typeof opts === "object";
      opts = opts || {};
      this.json = opts.json || obj;
      this.path = opts.path || expr;
      this.resultType = opts.resultType || "value";
      this.flatten = opts.flatten || false;
      this.wrap = hasOwnProp.call(opts, "wrap") ? opts.wrap : true;
      this.sandbox = opts.sandbox || {};
      this.preventEval = opts.preventEval || false;
      this.parent = opts.parent || null;
      this.parentProperty = opts.parentProperty || null;
      this.callback = opts.callback || callback || null;
      this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function() {
        throw new TypeError("You must supply an otherTypeCallback callback option with the @other() operator.");
      };
      if (opts.autostart !== false) {
        const args = {
          path: optObj ? opts.path : expr
        };
        if (!optObj) {
          args.json = obj;
        } else if ("json" in opts) {
          args.json = opts.json;
        }
        const ret = this.evaluate(args);
        if (!ret || typeof ret !== "object") {
          throw new NewError(ret);
        }
        return ret;
      }
    }
    JSONPath.prototype.evaluate = function(expr, json, callback, otherTypeCallback) {
      let currParent = this.parent, currParentProperty = this.parentProperty;
      let {
        flatten,
        wrap
      } = this;
      this.currResultType = this.resultType;
      this.currPreventEval = this.preventEval;
      this.currSandbox = this.sandbox;
      callback = callback || this.callback;
      this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
      json = json || this.json;
      expr = expr || this.path;
      if (expr && typeof expr === "object" && !Array.isArray(expr)) {
        if (!expr.path && expr.path !== "") {
          throw new TypeError('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
        }
        if (!hasOwnProp.call(expr, "json")) {
          throw new TypeError('You must supply a "json" property when providing an object argument to JSONPath.evaluate().');
        }
        ({
          json
        } = expr);
        flatten = hasOwnProp.call(expr, "flatten") ? expr.flatten : flatten;
        this.currResultType = hasOwnProp.call(expr, "resultType") ? expr.resultType : this.currResultType;
        this.currSandbox = hasOwnProp.call(expr, "sandbox") ? expr.sandbox : this.currSandbox;
        wrap = hasOwnProp.call(expr, "wrap") ? expr.wrap : wrap;
        this.currPreventEval = hasOwnProp.call(expr, "preventEval") ? expr.preventEval : this.currPreventEval;
        callback = hasOwnProp.call(expr, "callback") ? expr.callback : callback;
        this.currOtherTypeCallback = hasOwnProp.call(expr, "otherTypeCallback") ? expr.otherTypeCallback : this.currOtherTypeCallback;
        currParent = hasOwnProp.call(expr, "parent") ? expr.parent : currParent;
        currParentProperty = hasOwnProp.call(expr, "parentProperty") ? expr.parentProperty : currParentProperty;
        expr = expr.path;
      }
      currParent = currParent || null;
      currParentProperty = currParentProperty || null;
      if (Array.isArray(expr)) {
        expr = JSONPath.toPathString(expr);
      }
      if (!expr && expr !== "" || !json) {
        return void 0;
      }
      const exprList = JSONPath.toPathArray(expr);
      if (exprList[0] === "$" && exprList.length > 1) {
        exprList.shift();
      }
      this._hasParentSelector = null;
      const result = this._trace(exprList, json, ["$"], currParent, currParentProperty, callback).filter(function(ea) {
        return ea && !ea.isParentSelector;
      });
      if (!result.length) {
        return wrap ? [] : void 0;
      }
      if (!wrap && result.length === 1 && !result[0].hasArrExpr) {
        return this._getPreferredOutput(result[0]);
      }
      return result.reduce((rslt, ea) => {
        const valOrPath = this._getPreferredOutput(ea);
        if (flatten && Array.isArray(valOrPath)) {
          rslt = rslt.concat(valOrPath);
        } else {
          rslt.push(valOrPath);
        }
        return rslt;
      }, []);
    };
    JSONPath.prototype._getPreferredOutput = function(ea) {
      const resultType = this.currResultType;
      switch (resultType) {
        case "all": {
          const path2 = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);
          ea.pointer = JSONPath.toPointer(path2);
          ea.path = typeof ea.path === "string" ? ea.path : JSONPath.toPathString(ea.path);
          return ea;
        }
        case "value":
        case "parent":
        case "parentProperty":
          return ea[resultType];
        case "path":
          return JSONPath.toPathString(ea[resultType]);
        case "pointer":
          return JSONPath.toPointer(ea.path);
        default:
          throw new TypeError("Unknown result type");
      }
    };
    JSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {
      if (callback) {
        const preferredOutput = this._getPreferredOutput(fullRetObj);
        fullRetObj.path = typeof fullRetObj.path === "string" ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
        callback(preferredOutput, type, fullRetObj);
      }
    };
    JSONPath.prototype._trace = function(expr, val, path2, parent, parentPropName, callback, hasArrExpr, literalPriority) {
      let retObj;
      if (!expr.length) {
        retObj = {
          path: path2,
          value: val,
          parent,
          parentProperty: parentPropName,
          hasArrExpr
        };
        this._handleCallback(retObj, callback, "value");
        return retObj;
      }
      const loc = expr[0], x3 = expr.slice(1);
      const ret = [];
      function addRet(elems) {
        if (Array.isArray(elems)) {
          elems.forEach((t3) => {
            ret.push(t3);
          });
        } else {
          ret.push(elems);
        }
      }
      if ((typeof loc !== "string" || literalPriority) && val && hasOwnProp.call(val, loc)) {
        addRet(this._trace(x3, val[loc], push(path2, loc), val, loc, callback, hasArrExpr));
      } else if (loc === "*") {
        this._walk(loc, x3, val, path2, parent, parentPropName, callback, (m2, l2, _x, v2, p2, par, pr, cb) => {
          addRet(this._trace(unshift(m2, _x), v2, p2, par, pr, cb, true, true));
        });
      } else if (loc === "..") {
        addRet(this._trace(x3, val, path2, parent, parentPropName, callback, hasArrExpr));
        this._walk(loc, x3, val, path2, parent, parentPropName, callback, (m2, l2, _x, v2, p2, par, pr, cb) => {
          if (typeof v2[m2] === "object") {
            addRet(this._trace(unshift(l2, _x), v2[m2], push(p2, m2), v2, m2, cb, true));
          }
        });
      } else if (loc === "^") {
        this._hasParentSelector = true;
        return {
          path: path2.slice(0, -1),
          expr: x3,
          isParentSelector: true
        };
      } else if (loc === "~") {
        retObj = {
          path: push(path2, loc),
          value: parentPropName,
          parent,
          parentProperty: null
        };
        this._handleCallback(retObj, callback, "property");
        return retObj;
      } else if (loc === "$") {
        addRet(this._trace(x3, val, path2, null, null, callback, hasArrExpr));
      } else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(loc)) {
        addRet(this._slice(loc, x3, val, path2, parent, parentPropName, callback));
      } else if (loc.indexOf("?(") === 0) {
        if (this.currPreventEval) {
          throw new Error("Eval [?(expr)] prevented in JSONPath expression.");
        }
        this._walk(loc, x3, val, path2, parent, parentPropName, callback, (m2, l2, _x, v2, p2, par, pr, cb) => {
          if (this._eval(l2.replace(/^\?\((.*?)\)$/u, "$1"), v2[m2], m2, p2, par, pr)) {
            addRet(this._trace(unshift(m2, _x), v2, p2, par, pr, cb, true));
          }
        });
      } else if (loc[0] === "(") {
        if (this.currPreventEval) {
          throw new Error("Eval [(expr)] prevented in JSONPath expression.");
        }
        addRet(this._trace(unshift(this._eval(loc, val, path2[path2.length - 1], path2.slice(0, -1), parent, parentPropName), x3), val, path2, parent, parentPropName, callback, hasArrExpr));
      } else if (loc[0] === "@") {
        let addType = false;
        const valueType = loc.slice(1, -2);
        switch (valueType) {
          case "scalar":
            if (!val || !["object", "function"].includes(typeof val)) {
              addType = true;
            }
            break;
          case "boolean":
          case "string":
          case "undefined":
          case "function":
            if (typeof val === valueType) {
              addType = true;
            }
            break;
          case "integer":
            if (Number.isFinite(val) && !(val % 1)) {
              addType = true;
            }
            break;
          case "number":
            if (Number.isFinite(val)) {
              addType = true;
            }
            break;
          case "nonFinite":
            if (typeof val === "number" && !Number.isFinite(val)) {
              addType = true;
            }
            break;
          case "object":
            if (val && typeof val === valueType) {
              addType = true;
            }
            break;
          case "array":
            if (Array.isArray(val)) {
              addType = true;
            }
            break;
          case "other":
            addType = this.currOtherTypeCallback(val, path2, parent, parentPropName);
            break;
          case "null":
            if (val === null) {
              addType = true;
            }
            break;
          default:
            throw new TypeError("Unknown value type " + valueType);
        }
        if (addType) {
          retObj = {
            path: path2,
            value: val,
            parent,
            parentProperty: parentPropName
          };
          this._handleCallback(retObj, callback, "value");
          return retObj;
        }
      } else if (loc[0] === "`" && val && hasOwnProp.call(val, loc.slice(1))) {
        const locProp = loc.slice(1);
        addRet(this._trace(x3, val[locProp], push(path2, locProp), val, locProp, callback, hasArrExpr, true));
      } else if (loc.includes(",")) {
        const parts = loc.split(",");
        for (const part of parts) {
          addRet(this._trace(unshift(part, x3), val, path2, parent, parentPropName, callback, true));
        }
      } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {
        addRet(this._trace(x3, val[loc], push(path2, loc), val, loc, callback, hasArrExpr, true));
      }
      if (this._hasParentSelector) {
        for (let t3 = 0; t3 < ret.length; t3++) {
          const rett = ret[t3];
          if (rett && rett.isParentSelector) {
            const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);
            if (Array.isArray(tmp)) {
              ret[t3] = tmp[0];
              const tl = tmp.length;
              for (let tt = 1; tt < tl; tt++) {
                t3++;
                ret.splice(t3, 0, tmp[tt]);
              }
            } else {
              ret[t3] = tmp;
            }
          }
        }
      }
      return ret;
    };
    JSONPath.prototype._walk = function(loc, expr, val, path2, parent, parentPropName, callback, f2) {
      if (Array.isArray(val)) {
        const n3 = val.length;
        for (let i3 = 0; i3 < n3; i3++) {
          f2(i3, loc, expr, val, path2, parent, parentPropName, callback);
        }
      } else if (val && typeof val === "object") {
        Object.keys(val).forEach((m2) => {
          f2(m2, loc, expr, val, path2, parent, parentPropName, callback);
        });
      }
    };
    JSONPath.prototype._slice = function(loc, expr, val, path2, parent, parentPropName, callback) {
      if (!Array.isArray(val)) {
        return void 0;
      }
      const len = val.length, parts = loc.split(":"), step = parts[2] && Number.parseInt(parts[2]) || 1;
      let start = parts[0] && Number.parseInt(parts[0]) || 0, end = parts[1] && Number.parseInt(parts[1]) || len;
      start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
      end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
      const ret = [];
      for (let i3 = start; i3 < end; i3 += step) {
        const tmp = this._trace(unshift(i3, expr), val, path2, parent, parentPropName, callback, true);
        tmp.forEach((t3) => {
          ret.push(t3);
        });
      }
      return ret;
    };
    JSONPath.prototype._eval = function(code, _v, _vname, path2, parent, parentPropName) {
      this.currSandbox._$_parentProperty = parentPropName;
      this.currSandbox._$_parent = parent;
      this.currSandbox._$_property = _vname;
      this.currSandbox._$_root = this.json;
      this.currSandbox._$_v = _v;
      const containsPath = code.includes("@path");
      if (containsPath) {
        this.currSandbox._$_path = JSONPath.toPathString(path2.concat([_vname]));
      }
      const scriptCacheKey = "script:" + code;
      if (!JSONPath.cache[scriptCacheKey]) {
        let script = code.replace(/@parentProperty/gu, "_$_parentProperty").replace(/@parent/gu, "_$_parent").replace(/@property/gu, "_$_property").replace(/@root/gu, "_$_root").replace(/@([.\s)[])/gu, "_$_v$1");
        if (containsPath) {
          script = script.replace(/@path/gu, "_$_path");
        }
        JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);
      }
      try {
        return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);
      } catch (e3) {
        throw new Error("jsonPath: " + e3.message + ": " + code);
      }
    };
    JSONPath.cache = {};
    JSONPath.toPathString = function(pathArr) {
      const x3 = pathArr, n3 = x3.length;
      let p2 = "$";
      for (let i3 = 1; i3 < n3; i3++) {
        if (!/^(~|\^|@.*?\(\))$/u.test(x3[i3])) {
          p2 += /^[0-9*]+$/u.test(x3[i3]) ? "[" + x3[i3] + "]" : "['" + x3[i3] + "']";
        }
      }
      return p2;
    };
    JSONPath.toPointer = function(pointer) {
      const x3 = pointer, n3 = x3.length;
      let p2 = "";
      for (let i3 = 1; i3 < n3; i3++) {
        if (!/^(~|\^|@.*?\(\))$/u.test(x3[i3])) {
          p2 += "/" + x3[i3].toString().replace(/~/gu, "~0").replace(/\//gu, "~1");
        }
      }
      return p2;
    };
    JSONPath.toPathArray = function(expr) {
      const {
        cache: cache2
      } = JSONPath;
      if (cache2[expr]) {
        return cache2[expr].concat();
      }
      const subx = [];
      const normalized = expr.replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu, ";$&;").replace(/[['](\??\(.*?\))[\]']/gu, function($0, $1) {
        return "[#" + (subx.push($1) - 1) + "]";
      }).replace(/\[['"]([^'\]]*)['"]\]/gu, function($0, prop) {
        return "['" + prop.replace(/\./gu, "%@%").replace(/~/gu, "%%@@%%") + "']";
      }).replace(/~/gu, ";~;").replace(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ";").replace(/%@%/gu, ".").replace(/%%@@%%/gu, "~").replace(/(?:;)?(\^+)(?:;)?/gu, function($0, ups) {
        return ";" + ups.split("").join(";") + ";";
      }).replace(/;;;|;;/gu, ";..;").replace(/;$|'?\]|'$/gu, "");
      const exprList = normalized.split(";").map(function(exp) {
        const match = exp.match(/#(\d+)/u);
        return !match || !match[1] ? exp : subx[match[1]];
      });
      cache2[expr] = exprList;
      return cache2[expr].concat();
    };
    JSONPath.prototype.vm = vm__default["default"];
    exports.JSONPath = JSONPath;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/runner/utils/getLintTargets.js
var require_getLintTargets = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/runner/utils/getLintTargets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLintTargets = void 0;
    var jsonpath_plus_1 = require_index_node_cjs();
    var lodash_1 = require_lodash();
    var getLintTargets = (targetValue, field) => {
      const targets = [];
      if ((0, lodash_1.isObject)(targetValue) && typeof field === "string") {
        if (field === "@key") {
          for (const key of Object.keys(targetValue)) {
            targets.push({
              path: [key],
              value: key
            });
          }
        } else if (field.startsWith("$")) {
          (0, jsonpath_plus_1.JSONPath)({
            path: field,
            json: targetValue,
            resultType: "all",
            callback(result) {
              targets.push({
                path: (0, lodash_1.toPath)(result.path.slice(1)),
                value: result.value
              });
            }
          });
        } else {
          targets.push({
            path: (0, lodash_1.toPath)(field),
            value: (0, lodash_1.get)(targetValue, field)
          });
        }
      } else {
        targets.push({
          path: [],
          value: targetValue
        });
      }
      if (targets.length === 0) {
        targets.push({
          path: [],
          value: void 0
        });
      }
      return targets;
    };
    exports.getLintTargets = getLintTargets;
  }
});

// ../../node_modules/jsep/dist/cjs/jsep.cjs.js
var require_jsep_cjs = __commonJS({
  "../../node_modules/jsep/dist/cjs/jsep.cjs.js"(exports, module2) {
    "use strict";
    var Hooks = class {
      /**
       * @callback HookCallback
       * @this {*|Jsep} this
       * @param {Jsep} env
       * @returns: void
       */
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
       * @param {HookCallback|boolean} callback The callback function which is given environment variables.
       * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
       * @public
       */
      add(name, callback, first) {
        if (typeof arguments[0] != "string") {
          for (let name2 in arguments[0]) {
            this.add(name2, arguments[0][name2], arguments[1]);
          }
        } else {
          (Array.isArray(name) ? name : [name]).forEach(function(name2) {
            this[name2] = this[name2] || [];
            if (callback) {
              this[name2][first ? "unshift" : "push"](callback);
            }
          }, this);
        }
      }
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run(name, env) {
        this[name] = this[name] || [];
        this[name].forEach(function(callback) {
          callback.call(env && env.context ? env.context : env, env);
        });
      }
    };
    var Plugins = class {
      constructor(jsep2) {
        this.jsep = jsep2;
        this.registered = {};
      }
      /**
       * @callback PluginSetup
       * @this {Jsep} jsep
       * @returns: void
       */
      /**
       * Adds the given plugin(s) to the registry
       *
       * @param {object} plugins
       * @param {string} plugins.name The name of the plugin
       * @param {PluginSetup} plugins.init The init function
       * @public
       */
      register(...plugins) {
        plugins.forEach((plugin) => {
          if (typeof plugin !== "object" || !plugin.name || !plugin.init) {
            throw new Error("Invalid JSEP plugin format");
          }
          if (this.registered[plugin.name]) {
            return;
          }
          plugin.init(this.jsep);
          this.registered[plugin.name] = plugin;
        });
      }
    };
    var Jsep = class _Jsep {
      /**
       * @returns {string}
       */
      static get version() {
        return "1.3.8";
      }
      /**
       * @returns {string}
       */
      static toString() {
        return "JavaScript Expression Parser (JSEP) v" + _Jsep.version;
      }
      // ==================== CONFIG ================================
      /**
       * @method addUnaryOp
       * @param {string} op_name The name of the unary op to add
       * @returns {Jsep}
       */
      static addUnaryOp(op_name) {
        _Jsep.max_unop_len = Math.max(op_name.length, _Jsep.max_unop_len);
        _Jsep.unary_ops[op_name] = 1;
        return _Jsep;
      }
      /**
       * @method jsep.addBinaryOp
       * @param {string} op_name The name of the binary op to add
       * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
       * @param {boolean} [isRightAssociative=false] whether operator is right-associative
       * @returns {Jsep}
       */
      static addBinaryOp(op_name, precedence, isRightAssociative) {
        _Jsep.max_binop_len = Math.max(op_name.length, _Jsep.max_binop_len);
        _Jsep.binary_ops[op_name] = precedence;
        if (isRightAssociative) {
          _Jsep.right_associative.add(op_name);
        } else {
          _Jsep.right_associative.delete(op_name);
        }
        return _Jsep;
      }
      /**
       * @method addIdentifierChar
       * @param {string} char The additional character to treat as a valid part of an identifier
       * @returns {Jsep}
       */
      static addIdentifierChar(char) {
        _Jsep.additional_identifier_chars.add(char);
        return _Jsep;
      }
      /**
       * @method addLiteral
       * @param {string} literal_name The name of the literal to add
       * @param {*} literal_value The value of the literal
       * @returns {Jsep}
       */
      static addLiteral(literal_name, literal_value) {
        _Jsep.literals[literal_name] = literal_value;
        return _Jsep;
      }
      /**
       * @method removeUnaryOp
       * @param {string} op_name The name of the unary op to remove
       * @returns {Jsep}
       */
      static removeUnaryOp(op_name) {
        delete _Jsep.unary_ops[op_name];
        if (op_name.length === _Jsep.max_unop_len) {
          _Jsep.max_unop_len = _Jsep.getMaxKeyLen(_Jsep.unary_ops);
        }
        return _Jsep;
      }
      /**
       * @method removeAllUnaryOps
       * @returns {Jsep}
       */
      static removeAllUnaryOps() {
        _Jsep.unary_ops = {};
        _Jsep.max_unop_len = 0;
        return _Jsep;
      }
      /**
       * @method removeIdentifierChar
       * @param {string} char The additional character to stop treating as a valid part of an identifier
       * @returns {Jsep}
       */
      static removeIdentifierChar(char) {
        _Jsep.additional_identifier_chars.delete(char);
        return _Jsep;
      }
      /**
       * @method removeBinaryOp
       * @param {string} op_name The name of the binary op to remove
       * @returns {Jsep}
       */
      static removeBinaryOp(op_name) {
        delete _Jsep.binary_ops[op_name];
        if (op_name.length === _Jsep.max_binop_len) {
          _Jsep.max_binop_len = _Jsep.getMaxKeyLen(_Jsep.binary_ops);
        }
        _Jsep.right_associative.delete(op_name);
        return _Jsep;
      }
      /**
       * @method removeAllBinaryOps
       * @returns {Jsep}
       */
      static removeAllBinaryOps() {
        _Jsep.binary_ops = {};
        _Jsep.max_binop_len = 0;
        return _Jsep;
      }
      /**
       * @method removeLiteral
       * @param {string} literal_name The name of the literal to remove
       * @returns {Jsep}
       */
      static removeLiteral(literal_name) {
        delete _Jsep.literals[literal_name];
        return _Jsep;
      }
      /**
       * @method removeAllLiterals
       * @returns {Jsep}
       */
      static removeAllLiterals() {
        _Jsep.literals = {};
        return _Jsep;
      }
      // ==================== END CONFIG ============================
      /**
       * @returns {string}
       */
      get char() {
        return this.expr.charAt(this.index);
      }
      /**
       * @returns {number}
       */
      get code() {
        return this.expr.charCodeAt(this.index);
      }
      /**
       * @param {string} expr a string with the passed in express
       * @returns Jsep
       */
      constructor(expr) {
        this.expr = expr;
        this.index = 0;
      }
      /**
       * static top-level parser
       * @returns {jsep.Expression}
       */
      static parse(expr) {
        return new _Jsep(expr).parse();
      }
      /**
       * Get the longest key length of any object
       * @param {object} obj
       * @returns {number}
       */
      static getMaxKeyLen(obj) {
        return Math.max(0, ...Object.keys(obj).map((k2) => k2.length));
      }
      /**
       * `ch` is a character code in the next three functions
       * @param {number} ch
       * @returns {boolean}
       */
      static isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      /**
       * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
       * @param {string} op_val
       * @returns {number}
       */
      static binaryPrecedence(op_val) {
        return _Jsep.binary_ops[op_val] || 0;
      }
      /**
       * Looks for start of identifier
       * @param {number} ch
       * @returns {boolean}
       */
      static isIdentifierStart(ch) {
        return ch >= 65 && ch <= 90 || // A...Z
        ch >= 97 && ch <= 122 || // a...z
        ch >= 128 && !_Jsep.binary_ops[String.fromCharCode(ch)] || // any non-ASCII that is not an operator
        _Jsep.additional_identifier_chars.has(String.fromCharCode(ch));
      }
      /**
       * @param {number} ch
       * @returns {boolean}
       */
      static isIdentifierPart(ch) {
        return _Jsep.isIdentifierStart(ch) || _Jsep.isDecimalDigit(ch);
      }
      /**
       * throw error at index of the expression
       * @param {string} message
       * @throws
       */
      throwError(message) {
        const error = new Error(message + " at character " + this.index);
        error.index = this.index;
        error.description = message;
        throw error;
      }
      /**
       * Run a given hook
       * @param {string} name
       * @param {jsep.Expression|false} [node]
       * @returns {?jsep.Expression}
       */
      runHook(name, node) {
        if (_Jsep.hooks[name]) {
          const env = { context: this, node };
          _Jsep.hooks.run(name, env);
          return env.node;
        }
        return node;
      }
      /**
       * Runs a given hook until one returns a node
       * @param {string} name
       * @returns {?jsep.Expression}
       */
      searchHook(name) {
        if (_Jsep.hooks[name]) {
          const env = { context: this };
          _Jsep.hooks[name].find(function(callback) {
            callback.call(env.context, env);
            return env.node;
          });
          return env.node;
        }
      }
      /**
       * Push `index` up to the next non-space character
       */
      gobbleSpaces() {
        let ch = this.code;
        while (ch === _Jsep.SPACE_CODE || ch === _Jsep.TAB_CODE || ch === _Jsep.LF_CODE || ch === _Jsep.CR_CODE) {
          ch = this.expr.charCodeAt(++this.index);
        }
        this.runHook("gobble-spaces");
      }
      /**
       * Top-level method to parse all expressions and returns compound or single node
       * @returns {jsep.Expression}
       */
      parse() {
        this.runHook("before-all");
        const nodes = this.gobbleExpressions();
        const node = nodes.length === 1 ? nodes[0] : {
          type: _Jsep.COMPOUND,
          body: nodes
        };
        return this.runHook("after-all", node);
      }
      /**
       * top-level parser (but can be reused within as well)
       * @param {number} [untilICode]
       * @returns {jsep.Expression[]}
       */
      gobbleExpressions(untilICode) {
        let nodes = [], ch_i, node;
        while (this.index < this.expr.length) {
          ch_i = this.code;
          if (ch_i === _Jsep.SEMCOL_CODE || ch_i === _Jsep.COMMA_CODE) {
            this.index++;
          } else {
            if (node = this.gobbleExpression()) {
              nodes.push(node);
            } else if (this.index < this.expr.length) {
              if (ch_i === untilICode) {
                break;
              }
              this.throwError('Unexpected "' + this.char + '"');
            }
          }
        }
        return nodes;
      }
      /**
       * The main parsing function.
       * @returns {?jsep.Expression}
       */
      gobbleExpression() {
        const node = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
        this.gobbleSpaces();
        return this.runHook("after-expression", node);
      }
      /**
       * Search for the operation portion of the string (e.g. `+`, `===`)
       * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
       * and move down from 3 to 2 to 1 character until a matching binary operation is found
       * then, return that binary operation
       * @returns {string|boolean}
       */
      gobbleBinaryOp() {
        this.gobbleSpaces();
        let to_check = this.expr.substr(this.index, _Jsep.max_binop_len);
        let tc_len = to_check.length;
        while (tc_len > 0) {
          if (_Jsep.binary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
            this.index += tc_len;
            return to_check;
          }
          to_check = to_check.substr(0, --tc_len);
        }
        return false;
      }
      /**
       * This function is responsible for gobbling an individual expression,
       * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
       * @returns {?jsep.BinaryExpression}
       */
      gobbleBinaryExpression() {
        let node, biop, prec, stack, biop_info, left, right, i3, cur_biop;
        left = this.gobbleToken();
        if (!left) {
          return left;
        }
        biop = this.gobbleBinaryOp();
        if (!biop) {
          return left;
        }
        biop_info = { value: biop, prec: _Jsep.binaryPrecedence(biop), right_a: _Jsep.right_associative.has(biop) };
        right = this.gobbleToken();
        if (!right) {
          this.throwError("Expected expression after " + biop);
        }
        stack = [left, biop_info, right];
        while (biop = this.gobbleBinaryOp()) {
          prec = _Jsep.binaryPrecedence(biop);
          if (prec === 0) {
            this.index -= biop.length;
            break;
          }
          biop_info = { value: biop, prec, right_a: _Jsep.right_associative.has(biop) };
          cur_biop = biop;
          const comparePrev = (prev) => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;
          while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {
            right = stack.pop();
            biop = stack.pop().value;
            left = stack.pop();
            node = {
              type: _Jsep.BINARY_EXP,
              operator: biop,
              left,
              right
            };
            stack.push(node);
          }
          node = this.gobbleToken();
          if (!node) {
            this.throwError("Expected expression after " + cur_biop);
          }
          stack.push(biop_info, node);
        }
        i3 = stack.length - 1;
        node = stack[i3];
        while (i3 > 1) {
          node = {
            type: _Jsep.BINARY_EXP,
            operator: stack[i3 - 1].value,
            left: stack[i3 - 2],
            right: node
          };
          i3 -= 2;
        }
        return node;
      }
      /**
       * An individual part of a binary expression:
       * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
       * @returns {boolean|jsep.Expression}
       */
      gobbleToken() {
        let ch, to_check, tc_len, node;
        this.gobbleSpaces();
        node = this.searchHook("gobble-token");
        if (node) {
          return this.runHook("after-token", node);
        }
        ch = this.code;
        if (_Jsep.isDecimalDigit(ch) || ch === _Jsep.PERIOD_CODE) {
          return this.gobbleNumericLiteral();
        }
        if (ch === _Jsep.SQUOTE_CODE || ch === _Jsep.DQUOTE_CODE) {
          node = this.gobbleStringLiteral();
        } else if (ch === _Jsep.OBRACK_CODE) {
          node = this.gobbleArray();
        } else {
          to_check = this.expr.substr(this.index, _Jsep.max_unop_len);
          tc_len = to_check.length;
          while (tc_len > 0) {
            if (_Jsep.unary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
              this.index += tc_len;
              const argument = this.gobbleToken();
              if (!argument) {
                this.throwError("missing unaryOp argument");
              }
              return this.runHook("after-token", {
                type: _Jsep.UNARY_EXP,
                operator: to_check,
                argument,
                prefix: true
              });
            }
            to_check = to_check.substr(0, --tc_len);
          }
          if (_Jsep.isIdentifierStart(ch)) {
            node = this.gobbleIdentifier();
            if (_Jsep.literals.hasOwnProperty(node.name)) {
              node = {
                type: _Jsep.LITERAL,
                value: _Jsep.literals[node.name],
                raw: node.name
              };
            } else if (node.name === _Jsep.this_str) {
              node = { type: _Jsep.THIS_EXP };
            }
          } else if (ch === _Jsep.OPAREN_CODE) {
            node = this.gobbleGroup();
          }
        }
        if (!node) {
          return this.runHook("after-token", false);
        }
        node = this.gobbleTokenProperty(node);
        return this.runHook("after-token", node);
      }
      /**
       * Gobble properties of of identifiers/strings/arrays/groups.
       * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
       * It also gobbles function calls:
       * e.g. `Math.acos(obj.angle)`
       * @param {jsep.Expression} node
       * @returns {jsep.Expression}
       */
      gobbleTokenProperty(node) {
        this.gobbleSpaces();
        let ch = this.code;
        while (ch === _Jsep.PERIOD_CODE || ch === _Jsep.OBRACK_CODE || ch === _Jsep.OPAREN_CODE || ch === _Jsep.QUMARK_CODE) {
          let optional;
          if (ch === _Jsep.QUMARK_CODE) {
            if (this.expr.charCodeAt(this.index + 1) !== _Jsep.PERIOD_CODE) {
              break;
            }
            optional = true;
            this.index += 2;
            this.gobbleSpaces();
            ch = this.code;
          }
          this.index++;
          if (ch === _Jsep.OBRACK_CODE) {
            node = {
              type: _Jsep.MEMBER_EXP,
              computed: true,
              object: node,
              property: this.gobbleExpression()
            };
            this.gobbleSpaces();
            ch = this.code;
            if (ch !== _Jsep.CBRACK_CODE) {
              this.throwError("Unclosed [");
            }
            this.index++;
          } else if (ch === _Jsep.OPAREN_CODE) {
            node = {
              type: _Jsep.CALL_EXP,
              "arguments": this.gobbleArguments(_Jsep.CPAREN_CODE),
              callee: node
            };
          } else if (ch === _Jsep.PERIOD_CODE || optional) {
            if (optional) {
              this.index--;
            }
            this.gobbleSpaces();
            node = {
              type: _Jsep.MEMBER_EXP,
              computed: false,
              object: node,
              property: this.gobbleIdentifier()
            };
          }
          if (optional) {
            node.optional = true;
          }
          this.gobbleSpaces();
          ch = this.code;
        }
        return node;
      }
      /**
       * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
       * keep track of everything in the numeric literal and then calling `parseFloat` on that string
       * @returns {jsep.Literal}
       */
      gobbleNumericLiteral() {
        let number = "", ch, chCode;
        while (_Jsep.isDecimalDigit(this.code)) {
          number += this.expr.charAt(this.index++);
        }
        if (this.code === _Jsep.PERIOD_CODE) {
          number += this.expr.charAt(this.index++);
          while (_Jsep.isDecimalDigit(this.code)) {
            number += this.expr.charAt(this.index++);
          }
        }
        ch = this.char;
        if (ch === "e" || ch === "E") {
          number += this.expr.charAt(this.index++);
          ch = this.char;
          if (ch === "+" || ch === "-") {
            number += this.expr.charAt(this.index++);
          }
          while (_Jsep.isDecimalDigit(this.code)) {
            number += this.expr.charAt(this.index++);
          }
          if (!_Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
            this.throwError("Expected exponent (" + number + this.char + ")");
          }
        }
        chCode = this.code;
        if (_Jsep.isIdentifierStart(chCode)) {
          this.throwError("Variable names cannot start with a number (" + number + this.char + ")");
        } else if (chCode === _Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === _Jsep.PERIOD_CODE) {
          this.throwError("Unexpected period");
        }
        return {
          type: _Jsep.LITERAL,
          value: parseFloat(number),
          raw: number
        };
      }
      /**
       * Parses a string literal, staring with single or double quotes with basic support for escape codes
       * e.g. `"hello world"`, `'this is\nJSEP'`
       * @returns {jsep.Literal}
       */
      gobbleStringLiteral() {
        let str = "";
        const startIndex = this.index;
        const quote = this.expr.charAt(this.index++);
        let closed = false;
        while (this.index < this.expr.length) {
          let ch = this.expr.charAt(this.index++);
          if (ch === quote) {
            closed = true;
            break;
          } else if (ch === "\\") {
            ch = this.expr.charAt(this.index++);
            switch (ch) {
              case "n":
                str += "\n";
                break;
              case "r":
                str += "\r";
                break;
              case "t":
                str += "	";
                break;
              case "b":
                str += "\b";
                break;
              case "f":
                str += "\f";
                break;
              case "v":
                str += "\v";
                break;
              default:
                str += ch;
            }
          } else {
            str += ch;
          }
        }
        if (!closed) {
          this.throwError('Unclosed quote after "' + str + '"');
        }
        return {
          type: _Jsep.LITERAL,
          value: str,
          raw: this.expr.substring(startIndex, this.index)
        };
      }
      /**
       * Gobbles only identifiers
       * e.g.: `foo`, `_value`, `$x1`
       * Also, this function checks if that identifier is a literal:
       * (e.g. `true`, `false`, `null`) or `this`
       * @returns {jsep.Identifier}
       */
      gobbleIdentifier() {
        let ch = this.code, start = this.index;
        if (_Jsep.isIdentifierStart(ch)) {
          this.index++;
        } else {
          this.throwError("Unexpected " + this.char);
        }
        while (this.index < this.expr.length) {
          ch = this.code;
          if (_Jsep.isIdentifierPart(ch)) {
            this.index++;
          } else {
            break;
          }
        }
        return {
          type: _Jsep.IDENTIFIER,
          name: this.expr.slice(start, this.index)
        };
      }
      /**
       * Gobbles a list of arguments within the context of a function call
       * or array literal. This function also assumes that the opening character
       * `(` or `[` has already been gobbled, and gobbles expressions and commas
       * until the terminator character `)` or `]` is encountered.
       * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
       * @param {number} termination
       * @returns {jsep.Expression[]}
       */
      gobbleArguments(termination) {
        const args = [];
        let closed = false;
        let separator_count = 0;
        while (this.index < this.expr.length) {
          this.gobbleSpaces();
          let ch_i = this.code;
          if (ch_i === termination) {
            closed = true;
            this.index++;
            if (termination === _Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
              this.throwError("Unexpected token " + String.fromCharCode(termination));
            }
            break;
          } else if (ch_i === _Jsep.COMMA_CODE) {
            this.index++;
            separator_count++;
            if (separator_count !== args.length) {
              if (termination === _Jsep.CPAREN_CODE) {
                this.throwError("Unexpected token ,");
              } else if (termination === _Jsep.CBRACK_CODE) {
                for (let arg = args.length; arg < separator_count; arg++) {
                  args.push(null);
                }
              }
            }
          } else if (args.length !== separator_count && separator_count !== 0) {
            this.throwError("Expected comma");
          } else {
            const node = this.gobbleExpression();
            if (!node || node.type === _Jsep.COMPOUND) {
              this.throwError("Expected comma");
            }
            args.push(node);
          }
        }
        if (!closed) {
          this.throwError("Expected " + String.fromCharCode(termination));
        }
        return args;
      }
      /**
       * Responsible for parsing a group of things within parentheses `()`
       * that have no identifier in front (so not a function call)
       * This function assumes that it needs to gobble the opening parenthesis
       * and then tries to gobble everything within that parenthesis, assuming
       * that the next thing it should see is the close parenthesis. If not,
       * then the expression probably doesn't have a `)`
       * @returns {boolean|jsep.Expression}
       */
      gobbleGroup() {
        this.index++;
        let nodes = this.gobbleExpressions(_Jsep.CPAREN_CODE);
        if (this.code === _Jsep.CPAREN_CODE) {
          this.index++;
          if (nodes.length === 1) {
            return nodes[0];
          } else if (!nodes.length) {
            return false;
          } else {
            return {
              type: _Jsep.SEQUENCE_EXP,
              expressions: nodes
            };
          }
        } else {
          this.throwError("Unclosed (");
        }
      }
      /**
       * Responsible for parsing Array literals `[1, 2, 3]`
       * This function assumes that it needs to gobble the opening bracket
       * and then tries to gobble the expressions as arguments.
       * @returns {jsep.ArrayExpression}
       */
      gobbleArray() {
        this.index++;
        return {
          type: _Jsep.ARRAY_EXP,
          elements: this.gobbleArguments(_Jsep.CBRACK_CODE)
        };
      }
    };
    var hooks = new Hooks();
    Object.assign(Jsep, {
      hooks,
      plugins: new Plugins(Jsep),
      // Node Types
      // ----------
      // This is the full set of types that any JSEP node can be.
      // Store them here to save space when minified
      COMPOUND: "Compound",
      SEQUENCE_EXP: "SequenceExpression",
      IDENTIFIER: "Identifier",
      MEMBER_EXP: "MemberExpression",
      LITERAL: "Literal",
      THIS_EXP: "ThisExpression",
      CALL_EXP: "CallExpression",
      UNARY_EXP: "UnaryExpression",
      BINARY_EXP: "BinaryExpression",
      ARRAY_EXP: "ArrayExpression",
      TAB_CODE: 9,
      LF_CODE: 10,
      CR_CODE: 13,
      SPACE_CODE: 32,
      PERIOD_CODE: 46,
      // '.'
      COMMA_CODE: 44,
      // ','
      SQUOTE_CODE: 39,
      // single quote
      DQUOTE_CODE: 34,
      // double quotes
      OPAREN_CODE: 40,
      // (
      CPAREN_CODE: 41,
      // )
      OBRACK_CODE: 91,
      // [
      CBRACK_CODE: 93,
      // ]
      QUMARK_CODE: 63,
      // ?
      SEMCOL_CODE: 59,
      // ;
      COLON_CODE: 58,
      // :
      // Operations
      // ----------
      // Use a quickly-accessible map to store all of the unary operators
      // Values are set to `1` (it really doesn't matter)
      unary_ops: {
        "-": 1,
        "!": 1,
        "~": 1,
        "+": 1
      },
      // Also use a map for the binary operations but set their values to their
      // binary precedence for quick reference (higher number = higher precedence)
      // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
      binary_ops: {
        "||": 1,
        "&&": 2,
        "|": 3,
        "^": 4,
        "&": 5,
        "==": 6,
        "!=": 6,
        "===": 6,
        "!==": 6,
        "<": 7,
        ">": 7,
        "<=": 7,
        ">=": 7,
        "<<": 8,
        ">>": 8,
        ">>>": 8,
        "+": 9,
        "-": 9,
        "*": 10,
        "/": 10,
        "%": 10
      },
      // sets specific binary_ops as right-associative
      right_associative: /* @__PURE__ */ new Set(),
      // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
      additional_identifier_chars: /* @__PURE__ */ new Set(["$", "_"]),
      // Literals
      // ----------
      // Store the values to return for the various literals we may encounter
      literals: {
        "true": true,
        "false": false,
        "null": null
      },
      // Except for `this`, which is special. This could be changed to something like `'self'` as well
      this_str: "this"
    });
    Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
    Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
    var jsep = (expr) => new Jsep(expr).parse();
    var staticMethods = Object.getOwnPropertyNames(Jsep);
    staticMethods.forEach((m2) => {
      if (jsep[m2] === void 0 && m2 !== "prototype") {
        jsep[m2] = Jsep[m2];
      }
    });
    jsep.Jsep = Jsep;
    var CONDITIONAL_EXP2 = "ConditionalExpression";
    var ternary = {
      name: "ternary",
      init(jsep2) {
        jsep2.hooks.add("after-expression", function gobbleTernary(env) {
          if (env.node && this.code === jsep2.QUMARK_CODE) {
            this.index++;
            const test = env.node;
            const consequent = this.gobbleExpression();
            if (!consequent) {
              this.throwError("Expected expression");
            }
            this.gobbleSpaces();
            if (this.code === jsep2.COLON_CODE) {
              this.index++;
              const alternate = this.gobbleExpression();
              if (!alternate) {
                this.throwError("Expected expression");
              }
              env.node = {
                type: CONDITIONAL_EXP2,
                test,
                consequent,
                alternate
              };
              if (test.operator && jsep2.binary_ops[test.operator] <= 0.9) {
                let newTest = test;
                while (newTest.right.operator && jsep2.binary_ops[newTest.right.operator] <= 0.9) {
                  newTest = newTest.right;
                }
                env.node.test = newTest.right;
                newTest.right = env.node;
                env.node = test;
              }
            } else {
              this.throwError("Expected :");
            }
          }
        });
      }
    };
    jsep.plugins.register(ternary);
    module2.exports = jsep;
  }
});

// ../../node_modules/simple-eval/dist/reduce.js
var require_reduce = __commonJS({
  "../../node_modules/simple-eval/dist/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function reduce(node, ctx) {
      switch (node.type) {
        case "Program":
          return reduceProgram(node, ctx);
        case "ExpressionStatement":
          return reduce(node.expression, ctx);
        case "MemberExpression":
          return reduceMemExpr(node, ctx);
        case "LogicalExpression":
          return reduceLogExpr(node, ctx);
        case "ConditionalExpression":
          return reduceConExpr(node, ctx);
        case "BinaryExpression":
          return reduceBinExpr(node, ctx);
        case "UnaryExpression":
          return reduceUnExpr(node, ctx);
        case "CallExpression":
          return reduceCallExpr(node, ctx);
        case "NewExpression":
          return reduceNewExpr(node, ctx);
        case "ArrayExpression":
          return reduceArrExpr(node, ctx);
        case "ThisExpression":
          return ctx;
        case "Identifier":
          return resolveIdentifier(node.name, ctx);
        case "Literal":
          return node.value;
        default:
          throw SyntaxError("Unexpected node");
      }
    }
    function reduceProgram(node, ctx) {
      if (node.body.length !== 1) {
        throw SyntaxError("Too complex expression");
      }
      return reduce(node.body[0], ctx);
    }
    function reduceMemExpr(node, ctx) {
      const value = reduce(node.object, ctx);
      const key = node.property.type === "Identifier" ? node.property.name : reduce(node.property, ctx);
      if (typeof value[key] === "function") {
        return value[key].bind(value);
      }
      return value[key];
    }
    function reduceCallExpr(node, ctx) {
      return Reflect.apply(
        reduce(node.callee, ctx),
        null,
        node.arguments.map((arg) => reduce(arg, ctx))
      );
    }
    function reduceNewExpr(node, ctx) {
      return Reflect.construct(
        reduce(node.callee, ctx),
        node.arguments.map((arg) => reduce(arg, ctx))
      );
    }
    function reduceUnExpr(node, ctx) {
      if (!node.prefix || node.argument.type === "UnaryExpression") {
        throw SyntaxError("Unexpected operator");
      }
      return Function("v", `return ${node.operator}v`)(reduce(node.argument, ctx));
    }
    function reduceConExpr(node, ctx) {
      return Function("t, c, a", `return t ? c : a`)(
        reduce(node.test, ctx),
        reduce(node.consequent, ctx),
        reduce(node.alternate, ctx)
      );
    }
    function reduceBinExpr(node, ctx) {
      return evalLhsRhs(node, ctx);
    }
    function reduceLogExpr(node, ctx) {
      return evalLhsRhs(node, ctx);
    }
    function reduceArrExpr(node, ctx) {
      return node.elements.map((el) => reduce(el, ctx));
    }
    function evalLhsRhs(node, ctx) {
      return Function("lhs, rhs", `return lhs ${node.operator} rhs`)(
        reduce(node.left, ctx),
        reduce(node.right, ctx)
      );
    }
    function resolveIdentifier(name, ctx) {
      if (ctx === void 0 || !(name in ctx)) {
        throw ReferenceError(`${name} is not defined`);
      }
      return Reflect.get(ctx, name, ctx);
    }
    exports.default = reduce;
  }
});

// ../../node_modules/simple-eval/dist/index.js
var require_dist7 = __commonJS({
  "../../node_modules/simple-eval/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsep = require_jsep_cjs();
    var reduce = require_reduce();
    function _interopDefaultLegacy(e3) {
      return e3 && typeof e3 === "object" && "default" in e3 ? e3 : { "default": e3 };
    }
    var jsep__default = /* @__PURE__ */ _interopDefaultLegacy(jsep);
    function parse2(expr) {
      try {
        return jsep__default["default"](expr);
      } catch (ex) {
        throw SyntaxError(ex.message);
      }
    }
    var index3 = (expr, ctx) => {
      const tree = typeof expr === "object" ? expr : parse2(expr);
      return reduce["default"](tree, Object.freeze(ctx));
    };
    exports.default = index3;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/utils/replacer.js
var require_replacer = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/utils/replacer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Replacer = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var simple_eval_1 = (0, tslib_1.__importDefault)(require_dist7());
    var Replacer = class {
      constructor(count2) {
        this.regex = new RegExp(`#?${"{".repeat(count2)}([^}
]+)${"}".repeat(count2)}`, "g");
        this.functions = {};
      }
      addFunction(name, filter2) {
        this.functions[name] = filter2;
      }
      print(input, values) {
        return input.replace(this.regex, (substr, identifier, index3) => {
          const shouldEvaluate = input[index3] === "#";
          if (shouldEvaluate) {
            return String((0, simple_eval_1.default)(identifier, {
              ...Object.entries(this.functions).reduce((fns, [name, fn]) => {
                fns[name] = fn.bind(values);
                return fns;
              }, {}),
              ...values
            }));
          }
          if (!(identifier in values)) {
            return "";
          }
          return String(values[identifier]);
        });
      }
    };
    exports.Replacer = Replacer;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/runner/utils/message.js
var require_message = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/runner/utils/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.message = void 0;
    var spectral_runtime_1 = require_dist5();
    var replacer_1 = require_replacer();
    var MessageReplacer = new replacer_1.Replacer(2);
    MessageReplacer.addFunction("print", function(type) {
      if (typeof type !== "string")
        return "";
      const { property, value } = this;
      switch (type) {
        case "property":
          if (property !== void 0 && property !== "") {
            return `"${property}" property `;
          }
          return `The document `;
        case "value":
          return (0, spectral_runtime_1.printValue)(value);
        default:
          if (type in this && this[type] !== null) {
            return String(this[type]);
          }
          return "";
      }
    });
    exports.message = MessageReplacer.print.bind(MessageReplacer);
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/runner/utils/index.js
var require_utils5 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/runner/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    (0, tslib_1.__exportStar)(require_getLintTargets(), exports);
    (0, tslib_1.__exportStar)(require_message(), exports);
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/runner/lintNode.js
var require_lintNode = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/runner/lintNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lintNode = void 0;
    var spectral_runtime_1 = require_dist5();
    var lodash_1 = require_lodash();
    var pony_cause_1 = require_pony_cause();
    var document_1 = require_document();
    var utils_1 = require_utils5();
    var lintNode = (context, node, rule) => {
      var _a;
      const givenPath = node.path.length > 0 && node.path[0] === "$" ? node.path.slice(1) : node.path.slice();
      const fnContext = {
        document: context.documentInventory.document,
        documentInventory: context.documentInventory,
        rule,
        path: givenPath
      };
      for (const then of rule.then) {
        const targets = (0, utils_1.getLintTargets)(node.value, then.field);
        for (const target of targets) {
          if (target.path.length > 0) {
            fnContext.path = [...givenPath, ...target.path];
          } else {
            fnContext.path = givenPath;
          }
          let targetResults;
          try {
            targetResults = then.function(target.value, (_a = then.functionOptions) !== null && _a !== void 0 ? _a : null, fnContext);
          } catch (e3) {
            throw new pony_cause_1.ErrorWithCause(`Function "${then.function.name}" threw an exception${(0, lodash_1.isError)(e3) ? `: ${e3.message}` : ""}`, {
              cause: e3
            });
          }
          if (targetResults === void 0)
            continue;
          if ("then" in targetResults) {
            const _fnContext = { ...fnContext };
            context.promises.push(targetResults.then((results) => results === void 0 ? void 0 : processTargetResults(context, _fnContext, results)));
          } else {
            processTargetResults(context, fnContext, targetResults);
          }
        }
      }
    };
    exports.lintNode = lintNode;
    function processTargetResults(context, fnContext, results) {
      var _a, _b, _c, _d, _e;
      const { rule, path: targetPath } = fnContext;
      for (const result of results) {
        const escapedJsonPath = ((_a = result.path) !== null && _a !== void 0 ? _a : targetPath).map(spectral_runtime_1.decodeSegmentFragment);
        const associatedItem = context.documentInventory.findAssociatedItemForPath(escapedJsonPath, rule.resolved);
        const path2 = (_b = associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.path) !== null && _b !== void 0 ? _b : (0, spectral_runtime_1.getClosestJsonPath)(context.documentInventory.resolved, escapedJsonPath);
        const source = associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.document.source;
        const document2 = (_c = associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.document) !== null && _c !== void 0 ? _c : context.documentInventory.document;
        const range = (_d = document2.getRangeForJsonPath(path2, true)) !== null && _d !== void 0 ? _d : document_1.Document.DEFAULT_RANGE;
        const value = path2.length === 0 ? document2.data : (0, lodash_1.get)(document2.data, path2);
        const vars = {
          property: (associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.missingPropertyPath) !== void 0 && associatedItem.missingPropertyPath.length > path2.length ? (0, spectral_runtime_1.printPath)(associatedItem.missingPropertyPath.slice(path2.length - 1), spectral_runtime_1.PrintStyle.Dot) : path2.length > 0 ? path2[path2.length - 1] : "",
          error: result.message,
          path: (0, spectral_runtime_1.printPath)(path2, spectral_runtime_1.PrintStyle.EscapedPointer),
          description: rule.description,
          value
        };
        const resultMessage = (0, utils_1.message)(result.message, vars);
        vars.error = resultMessage;
        const severity = source !== null && source !== void 0 ? rule.getSeverityForSource(source, path2) : rule.severity;
        if (severity === -1)
          continue;
        context.results.push({
          code: rule.name,
          message: (rule.message === null ? (_e = rule.description) !== null && _e !== void 0 ? _e : resultMessage : (0, utils_1.message)(rule.message, vars)).trim(),
          path: path2,
          severity,
          ...source !== null ? { source } : null,
          range
        });
      }
    }
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/_virtual/_rollupPluginBabelHelpers.js
var require_rollupPluginBabelHelpers = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/_virtual/_rollupPluginBabelHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classPrivateFieldGet(receiver, privateMap) {
      var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
      return _classApplyDescriptorGet(receiver, descriptor);
    }
    function _classPrivateFieldSet(receiver, privateMap, value) {
      var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
      _classApplyDescriptorSet(receiver, descriptor, value);
      return value;
    }
    function _classExtractFieldDescriptor(receiver, privateMap, action) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
      }
      return privateMap.get(receiver);
    }
    function _classApplyDescriptorGet(receiver, descriptor) {
      if (descriptor.get) {
        return descriptor.get.call(receiver);
      }
      return descriptor.value;
    }
    function _classApplyDescriptorSet(receiver, descriptor, value) {
      if (descriptor.set) {
        descriptor.set.call(receiver, value);
      } else {
        if (!descriptor.writable) {
          throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
      }
    }
    exports.classApplyDescriptorGet = _classApplyDescriptorGet;
    exports.classApplyDescriptorSet = _classApplyDescriptorSet;
    exports.classExtractFieldDescriptor = _classExtractFieldDescriptor;
    exports.classPrivateFieldGet = _classPrivateFieldGet;
    exports.classPrivateFieldSet = _classPrivateFieldSet;
    exports.defineProperty = _defineProperty;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/ast/builders.js
var require_builders = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/ast/builders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function program(body) {
      return {
        type: "Program",
        body
      };
    }
    function blockStatement(body, directives) {
      return {
        type: "BlockStatement",
        body,
        directives
      };
    }
    function expressionStatement(expression) {
      return {
        type: "ExpressionStatement",
        expression
      };
    }
    function literal(value) {
      switch (typeof value) {
        case "number":
          return numericLiteral(value);
        case "string":
          return stringLiteral(value);
        case "boolean":
          return booleanLiteral(value);
      }
    }
    function stringLiteral(value) {
      return {
        type: "StringLiteral",
        value
      };
    }
    function booleanLiteral(value) {
      return {
        type: "BooleanLiteral",
        value
      };
    }
    function numericLiteral(value) {
      return {
        type: "NumericLiteral",
        value
      };
    }
    function nullLiteral() {
      return {
        type: "NullLiteral",
        value: null
      };
    }
    function regExpLiteral(pattern, flags = "") {
      return {
        type: "RegExpLiteral",
        pattern,
        flags
      };
    }
    function identifier(name) {
      return {
        type: "Identifier",
        name
      };
    }
    function logicalExpression(operator, left, right) {
      return {
        type: "LogicalExpression",
        operator,
        left,
        right
      };
    }
    function conditionalExpression(test, consequent, alternate) {
      return {
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      };
    }
    function ifStatement(test, consequent, alternate) {
      return {
        type: "IfStatement",
        test,
        consequent,
        alternate
      };
    }
    function binaryExpression(operator, left, right) {
      return {
        type: "BinaryExpression",
        operator,
        left,
        right
      };
    }
    function safeBinaryExpression(operator, left, right) {
      let actualRight = right;
      if (right.type === "NumericLiteral") {
        actualRight = stringLiteral(String(right.value));
      } else if (right.type === "StringLiteral" && Number.isSafeInteger(Number(right.value))) {
        actualRight = stringLiteral(String(right.value));
      }
      return {
        type: "BinaryExpression",
        operator,
        left: actualRight === right ? left : callExpression(identifier("String"), [left]),
        right: actualRight
      };
    }
    function unaryExpression(operator, argument, prefix = true) {
      return {
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      };
    }
    function memberExpression(object, property, computed = false, optional = null) {
      return {
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      };
    }
    function assignmentExpression(operator, left, right) {
      return {
        type: "AssignmentExpression",
        operator,
        left,
        right
      };
    }
    function callExpression(callee, _arguments) {
      return {
        type: "CallExpression",
        callee,
        arguments: _arguments
      };
    }
    function functionDeclaration(id, params, body) {
      return {
        type: "FunctionDeclaration",
        id,
        params,
        body
      };
    }
    function returnStatement(argument) {
      return {
        type: "ReturnStatement",
        argument
      };
    }
    function sequenceExpression(expressions) {
      return {
        type: "SequenceExpression",
        expressions
      };
    }
    function forOfStatement(left, right, body, _await) {
      return {
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      };
    }
    function arrayExpression(elements) {
      return {
        type: "ArrayExpression",
        elements
      };
    }
    function objectExpression(properties) {
      return {
        type: "ObjectExpression",
        properties
      };
    }
    function objectMethod(kind, key, params, body, computed = false, generator = false, _async = false) {
      return {
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async: _async
      };
    }
    function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
      return {
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
      };
    }
    function variableDeclaration(kind, declarations) {
      return {
        type: "VariableDeclaration",
        kind,
        declarations
      };
    }
    function variableDeclarator(id, init) {
      return {
        type: "VariableDeclarator",
        id,
        init
      };
    }
    function newExpression(callee, _arguments) {
      return {
        type: "NewExpression",
        callee,
        arguments: _arguments
      };
    }
    function importDeclaration(specifiers, source) {
      return {
        type: "ImportDeclaration",
        specifiers,
        source
      };
    }
    function importSpecifier(local, imported) {
      return {
        type: "ImportSpecifier",
        local,
        imported
      };
    }
    function exportDefaultDeclaration(declaration) {
      return {
        type: "ExportDefaultDeclaration",
        declaration
      };
    }
    function arrowFunctionExpression(params, body, _async = false) {
      return {
        type: "ArrowFunctionExpression",
        params,
        body,
        async: _async
      };
    }
    function tryStatement(block, handler = null, finalizer = null) {
      return {
        type: "TryStatement",
        block,
        handler,
        finalizer
      };
    }
    function templateElement(value, tail = false) {
      return {
        type: "TemplateElement",
        value,
        tail
      };
    }
    function templateLiteral(quasis, expressions) {
      return {
        type: "TemplateLiteral",
        quasis,
        expressions
      };
    }
    exports.arrayExpression = arrayExpression;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.binaryExpression = binaryExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.callExpression = callExpression;
    exports.conditionalExpression = conditionalExpression;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.expressionStatement = expressionStatement;
    exports.forOfStatement = forOfStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.importDeclaration = importDeclaration;
    exports.importSpecifier = importSpecifier;
    exports.literal = literal;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.newExpression = newExpression;
    exports.nullLiteral = nullLiteral;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectProperty = objectProperty;
    exports.program = program;
    exports.regExpLiteral = regExpLiteral;
    exports.returnStatement = returnStatement;
    exports.safeBinaryExpression = safeBinaryExpression;
    exports.sequenceExpression = sequenceExpression;
    exports.stringLiteral = stringLiteral;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.tryStatement = tryStatement;
    exports.unaryExpression = unaryExpression;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/scope.js
var require_scope = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var SCOPE_IDENTIFIER = builders.identifier("scope");
    var scope = {
      _: SCOPE_IDENTIFIER,
      bail: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("bail")),
      callbacks: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("callbacks")),
      depth: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("depth")),
      destroy: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("destroy")),
      emit: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("emit")),
      fork: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("fork")),
      path: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("path")),
      property: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("property")),
      sandbox: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("sandbox")),
      traverse: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("traverse")),
      value: builders.memberExpression(SCOPE_IDENTIFIER, builders.identifier("value"))
    };
    exports["default"] = scope;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/emit-call.js
var require_emit_call = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/emit-call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var scope = require_scope();
    function generateEmitCall(id, {
      parents,
      keyed
    }) {
      return builders.expressionStatement(builders.callExpression(scope["default"].emit, [builders.stringLiteral(id), builders.numericLiteral(parents), builders.booleanLiteral(keyed)]));
    }
    exports["default"] = generateEmitCall;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/sandbox.js
var require_sandbox = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/sandbox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var scope = require_scope();
    var sandbox = {
      at: builders.memberExpression(scope["default"].sandbox, builders.identifier("at")),
      index: builders.memberExpression(scope["default"].sandbox, builders.identifier("index")),
      parent: builders.memberExpression(scope["default"].sandbox, builders.identifier("parent")),
      parentProperty: builders.memberExpression(scope["default"].sandbox, builders.identifier("parentProperty")),
      parentValue: builders.memberExpression(scope["default"].sandbox, builders.identifier("parentValue")),
      path: builders.memberExpression(scope["default"].sandbox, builders.identifier("path")),
      property: builders.memberExpression(scope["default"].sandbox, builders.identifier("property")),
      root: builders.memberExpression(scope["default"].sandbox, builders.identifier("root")),
      value: builders.memberExpression(scope["default"].sandbox, builders.identifier("value"))
    };
    exports["default"] = sandbox;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/all-parents.js
var require_all_parents = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/all-parents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var emitCall = require_emit_call();
    var sandbox = require_sandbox();
    var IS_OBJECT_IDENTIFIER = builders.identifier("isObject");
    var IS_NOT_OBJECT_IF_STATEMENT = builders.ifStatement(builders.unaryExpression("!", builders.callExpression(IS_OBJECT_IDENTIFIER, [sandbox["default"].value])), builders.returnStatement());
    var EMIT_ROOT_CALL_EXPRESSION = emitCall["default"]("$..", {
      keyed: false,
      parents: 0
    });
    var allParents = (nodes, tree, ctx) => {
      if (nodes.length !== 1 || nodes[0].type !== "AllParentExpression") {
        return false;
      }
      tree.addRuntimeDependency(IS_OBJECT_IDENTIFIER.name);
      tree.push(builders.blockStatement([IS_NOT_OBJECT_IF_STATEMENT, emitCall["default"](ctx.id, ctx.iterator.modifiers)]), "tree-method");
      tree.push(builders.stringLiteral(ctx.id), "traverse");
      tree.push(EMIT_ROOT_CALL_EXPRESSION, "body");
      return true;
    };
    exports["default"] = allParents;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/guards.js
var require_guards = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/guards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isMemberExpression(node) {
      return node.type === "MemberExpression";
    }
    function isScriptFilterExpression(node) {
      return node.type === "ScriptFilterExpression";
    }
    function isModifierExpression(node) {
      return node.type === "KeyExpression" || node.type === "ParentExpression";
    }
    function isWildcardExpression(node) {
      return node.type === "WildcardExpression";
    }
    function isDeep(node) {
      return node.deep;
    }
    exports.isDeep = isDeep;
    exports.isMemberExpression = isMemberExpression;
    exports.isModifierExpression = isModifierExpression;
    exports.isScriptFilterExpression = isScriptFilterExpression;
    exports.isWildcardExpression = isWildcardExpression;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/deep-single-member.js
var require_deep_single_member = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/deep-single-member.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var guards = require_guards();
    var emitCall = require_emit_call();
    var scope = require_scope();
    var deepSingleMember = (nodes, tree, ctx) => {
      if (nodes.length !== 1 || !guards.isDeep(nodes[0]) || !guards.isMemberExpression(nodes[0])) {
        return false;
      }
      tree.push(builders.blockStatement([builders.ifStatement(builders.safeBinaryExpression("!==", scope["default"].property, builders.stringLiteral(nodes[0].value)), builders.returnStatement()), emitCall["default"](ctx.id, ctx.iterator.modifiers)]), "tree-method");
      tree.push(builders.stringLiteral(ctx.id), "traverse");
      return true;
    };
    exports["default"] = deepSingleMember;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/deep-wildcard.js
var require_deep_wildcard = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/deep-wildcard.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var guards = require_guards();
    var emitCall = require_emit_call();
    var deepWildcard = (nodes, tree, ctx) => {
      if (nodes.length !== 1 || !guards.isWildcardExpression(nodes[0]) || !guards.isDeep(nodes[0])) {
        return false;
      }
      tree.push(builders.blockStatement([emitCall["default"](ctx.id, ctx.iterator.modifiers)]), "tree-method");
      tree.push(builders.stringLiteral(ctx.id), "traverse");
      return true;
    };
    exports["default"] = deepWildcard;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/fn-params.js
var require_fn_params = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/fn-params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var scope = require_scope();
    var fnParams = [scope["default"]._];
    exports["default"] = fnParams;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/internal-scope.js
var require_internal_scope = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/internal-scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var internalScope = {
      pos: builders.identifier("pos"),
      shorthands: builders.identifier("shorthands"),
      tree: builders.identifier("tree")
    };
    exports["default"] = internalScope;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/tree-method-call.js
var require_tree_method_call = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/tree-method-call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var fnParams = require_fn_params();
    var internalScope = require_internal_scope();
    function treeMethodCall(id) {
      const property = builders.stringLiteral(id);
      return builders.expressionStatement(builders.callExpression(builders.memberExpression(internalScope["default"].tree, property, true), fnParams["default"]));
    }
    exports["default"] = treeMethodCall;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/fixed.js
var require_fixed = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/fixed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var guards = require_guards();
    var emitCall = require_emit_call();
    var sandbox = require_sandbox();
    var scope = require_scope();
    var treeMethodCall = require_tree_method_call();
    var VALUE_IDENTIFIER = builders.identifier("value");
    var IS_OBJECT_IDENTIFIER = builders.identifier("isObject");
    var GET_IDENTIFIER = builders.identifier("get");
    var IS_NOT_OBJECT_IF_STATEMENT = builders.ifStatement(builders.unaryExpression("!", builders.callExpression(IS_OBJECT_IDENTIFIER, [VALUE_IDENTIFIER])), builders.returnStatement());
    var IS_NULL_SCOPE_IF_STATEMENT = builders.ifStatement(builders.binaryExpression("===", scope["default"]._, builders.nullLiteral()), builders.returnStatement());
    function toLiteral(node) {
      return builders.literal(node.value);
    }
    var fixed = (nodes, tree, ctx) => {
      if (!nodes.every(guards.isMemberExpression) || nodes.some(guards.isDeep)) {
        return false;
      }
      const valueVariableDeclaration = builders.variableDeclaration("const", [builders.variableDeclarator(VALUE_IDENTIFIER, nodes.slice(0, -1).reduce((object, node) => {
        if (tree.format === "ES2018") {
          object.arguments[1].elements.push(builders.literal(node.value));
          return object;
        }
        return builders.memberExpression(object, builders.literal(node.value), true, true);
      }, tree.format === "ES2018" && nodes.length > 0 ? builders.callExpression(builders.identifier("get"), [sandbox["default"].root, builders.arrayExpression([])]) : sandbox["default"].root))]);
      tree.addRuntimeDependency(IS_OBJECT_IDENTIFIER.name);
      if (tree.format === "ES2018") {
        tree.addRuntimeDependency(GET_IDENTIFIER.name);
      }
      tree.pushAll([[builders.blockStatement([valueVariableDeclaration, IS_NOT_OBJECT_IF_STATEMENT, builders.expressionStatement(builders.assignmentExpression("=", scope["default"]._, builders.callExpression(scope["default"].fork, [builders.arrayExpression(nodes.map(toLiteral))]))), IS_NULL_SCOPE_IF_STATEMENT, emitCall["default"](ctx.id, ctx.iterator.modifiers)]), "tree-method"], [treeMethodCall["default"](ctx.id), "body"]]);
      return true;
    };
    exports["default"] = fixed;
  }
});

// ../../node_modules/@jsep-plugin/regex/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  default: () => index
});
var FSLASH_CODE, BSLASH_CODE, index;
var init_dist2 = __esm({
  "../../node_modules/@jsep-plugin/regex/dist/index.js"() {
    "use strict";
    FSLASH_CODE = 47;
    BSLASH_CODE = 92;
    index = {
      name: "regex",
      init(jsep) {
        jsep.hooks.add("gobble-token", function gobbleRegexLiteral(env) {
          if (this.code === FSLASH_CODE) {
            const patternIndex = ++this.index;
            let inCharSet = false;
            while (this.index < this.expr.length) {
              if (this.code === FSLASH_CODE && !inCharSet) {
                const pattern = this.expr.slice(patternIndex, this.index);
                let flags = "";
                while (++this.index < this.expr.length) {
                  const code = this.code;
                  if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57) {
                    flags += this.char;
                  } else {
                    break;
                  }
                }
                let value;
                try {
                  value = new RegExp(pattern, flags);
                } catch (e3) {
                  this.throwError(e3.message);
                }
                env.node = {
                  type: jsep.LITERAL,
                  value,
                  raw: this.expr.slice(patternIndex - 1, this.index)
                };
                env.node = this.gobbleTokenProperty(env.node);
                return env.node;
              }
              if (this.code === jsep.OBRACK_CODE) {
                inCharSet = true;
              } else if (inCharSet && this.code === jsep.CBRACK_CODE) {
                inCharSet = false;
              }
              this.index += this.code === BSLASH_CODE ? 2 : 1;
            }
            this.throwError("Unclosed Regex");
          }
        });
      }
    };
  }
});

// ../../node_modules/@jsep-plugin/ternary/dist/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  default: () => index2
});
var CONDITIONAL_EXP, index2;
var init_dist3 = __esm({
  "../../node_modules/@jsep-plugin/ternary/dist/index.js"() {
    "use strict";
    CONDITIONAL_EXP = "ConditionalExpression";
    index2 = {
      name: "ternary",
      init(jsep) {
        jsep.hooks.add("after-expression", function gobbleTernary(env) {
          if (env.node && this.code === jsep.QUMARK_CODE) {
            this.index++;
            const test = env.node;
            const consequent = this.gobbleExpression();
            if (!consequent) {
              this.throwError("Expected expression");
            }
            this.gobbleSpaces();
            if (this.code === jsep.COLON_CODE) {
              this.index++;
              const alternate = this.gobbleExpression();
              if (!alternate) {
                this.throwError("Expected expression");
              }
              env.node = {
                type: CONDITIONAL_EXP,
                test,
                consequent,
                alternate
              };
              if (test.operator && jsep.binary_ops[test.operator] <= 0.9) {
                let newTest = test;
                while (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {
                  newTest = newTest.right;
                }
                env.node.test = newTest.right;
                newTest.right = env.node;
                env.node = test;
              }
            } else {
              this.throwError("Expected :");
            }
          }
        });
      }
    };
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/parser/jsep.js
var require_jsep = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/parser/jsep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var regex3 = (init_dist2(), __toCommonJS(dist_exports));
    var ternary = (init_dist3(), __toCommonJS(dist_exports2));
    var Jsep = require_jsep_cjs();
    function _interopDefaultLegacy(e3) {
      return e3 && typeof e3 === "object" && "default" in e3 ? e3 : { "default": e3 };
    }
    var regex__default = /* @__PURE__ */ _interopDefaultLegacy(regex3);
    var ternary__default = /* @__PURE__ */ _interopDefaultLegacy(ternary);
    var Jsep__default = /* @__PURE__ */ _interopDefaultLegacy(Jsep);
    Jsep__default["default"].addIdentifierChar("@");
    Jsep__default["default"].addUnaryOp("void");
    Jsep__default["default"].addBinaryOp("in", 12);
    Jsep__default["default"].addBinaryOp("~=", 20);
    Jsep__default["default"].plugins.register(regex__default["default"], ternary__default["default"]);
    var jsep = (expr) => Jsep__default["default"].parse(expr);
    exports["default"] = jsep;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/baseline/generators.js
var require_generators = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/baseline/generators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsep = require_jsep();
    var builders = require_builders();
    var internalScope = require_internal_scope();
    var sandbox = require_sandbox();
    var scope = require_scope();
    function generateMemberExpression(iterator, {
      deep,
      value
    }) {
      if (iterator.feedback.bailed) {
        return builders.safeBinaryExpression("!==", scope["default"].property, builders.literal(value));
      }
      if (iterator.state.inverted) {
        return builders.safeBinaryExpression("!==", iterator.state.pos === 0 ? scope["default"].property : builders.memberExpression(scope["default"].path, builders.binaryExpression("-", scope["default"].depth, builders.numericLiteral(Math.abs(iterator.state.pos))), true), builders.literal(value));
      }
      if (deep) {
        var _iterator$feedback;
        const isLastNode = iterator.nextNode === null || iterator.nextNode === "KeyExpression";
        (_iterator$feedback = iterator.feedback).mutatesPos || (_iterator$feedback.mutatesPos = !isLastNode);
        const right2 = builders.sequenceExpression([builders.assignmentExpression("=", internalScope["default"].pos, isLastNode ? builders.conditionalExpression(builders.safeBinaryExpression("!==", scope["default"].property, builders.literal(value)), builders.numericLiteral(-1), scope["default"].depth) : builders.callExpression(builders.memberExpression(scope["default"].path, builders.identifier("indexOf")), [builders.literal(value), iterator.state.pos === 0 ? internalScope["default"].pos : builders.binaryExpression("+", internalScope["default"].pos, builders.numericLiteral(1))])), builders.binaryExpression("===", internalScope["default"].pos, builders.numericLiteral(-1))]);
        if (isLastNode) {
          return builders.logicalExpression("||", builders.binaryExpression("<", scope["default"].depth, iterator.state.pos === 0 ? internalScope["default"].pos : builders.binaryExpression("+", internalScope["default"].pos, builders.numericLiteral(iterator.state.pos))), right2);
        }
        return right2;
      }
      let left;
      if (!iterator.feedback.fixed && iterator.state.absolutePos !== 0) {
        left = builders.binaryExpression("<", scope["default"].depth, iterator.state.pos === 0 ? internalScope["default"].pos : builders.binaryExpression("+", internalScope["default"].pos, builders.numericLiteral(iterator.state.pos)));
      }
      const right = builders.safeBinaryExpression("!==", builders.memberExpression(scope["default"].path, iterator.state.pos === 0 ? builders.numericLiteral(0) : iterator.feedback.fixed ? builders.numericLiteral(iterator.state.pos) : builders.binaryExpression("+", internalScope["default"].pos, builders.numericLiteral(iterator.state.pos)), true), builders.literal(value));
      return left !== void 0 ? builders.logicalExpression("||", left, right) : right;
    }
    function generateMultipleMemberExpression(iterator, node) {
      return node.value.slice(1).reduce((concat, member) => builders.logicalExpression("&&", concat, generateMemberExpression(iterator, {
        type: "MemberExpression",
        value: member,
        // eslint-disable-next-line sort-keys
        deep: node.deep
      })), generateMemberExpression(iterator, {
        type: "MemberExpression",
        value: node.value[0],
        // eslint-disable-next-line sort-keys
        deep: node.deep
      }));
    }
    var IN_BOUNDS_IDENTIFIER = builders.identifier("inBounds");
    function generateSliceExpression(iterator, node, tree) {
      const member = iterator.state.inverted ? builders.binaryExpression("-", scope["default"].depth, builders.numericLiteral(iterator.state.pos)) : iterator.state.pos === 0 ? builders.numericLiteral(0) : iterator.feedback.fixed ? builders.numericLiteral(iterator.state.pos) : builders.binaryExpression("+", internalScope["default"].pos, builders.numericLiteral(iterator.state.pos));
      const path2 = iterator.feedback.bailed ? scope["default"].property : builders.memberExpression(scope["default"].path, member, true);
      const isNumberBinaryExpression = builders.binaryExpression("!==", builders.unaryExpression("typeof", path2), builders.stringLiteral("number"));
      const hasNegativeIndex = node.value.some((value) => Number.isFinite(value) && value < 0);
      if (hasNegativeIndex) {
        tree.addRuntimeDependency(IN_BOUNDS_IDENTIFIER.name);
        return builders.binaryExpression("||", isNumberBinaryExpression, builders.unaryExpression("!", builders.callExpression(IN_BOUNDS_IDENTIFIER, [iterator.state.absolutePos === 0 ? remapSandbox(sandbox["default"].value, iterator.state.absolutePos - 2) : remapSandbox(sandbox["default"].value, iterator.state.absolutePos), builders.memberExpression(scope["default"].path, iterator.feedback.bailed ? builders.binaryExpression("-", builders.memberExpression(scope["default"].path, builders.identifier("length")), builders.numericLiteral(1)) : member, true), ...node.value.map((value) => builders.numericLiteral(value))])));
      }
      return node.value.reduce((merged, value, i3) => {
        if (i3 === 0 && value === 0) {
          return merged;
        }
        if (i3 === 1 && !Number.isFinite(value)) {
          return merged;
        }
        if (i3 === 2 && value === 1) {
          return merged;
        }
        const operator = i3 === 0 ? "<" : i3 === 1 ? ">=" : "%";
        const expression = builders.binaryExpression(operator, path2, builders.numericLiteral(Number(value)));
        return builders.logicalExpression("||", merged, operator === "%" ? builders.logicalExpression("&&", builders.binaryExpression("!==", path2, builders.numericLiteral(node.value[0])), builders.binaryExpression("!==", expression, builders.numericLiteral(node.value[0]))) : expression);
      }, isNumberBinaryExpression);
    }
    function generateWildcardExpression(iterator) {
      if (iterator.feedback.bailed) {
        return builders.booleanLiteral(false);
      } else if (iterator.nextNode === null && !iterator.feedback.fixed) {
        return builders.sequenceExpression([builders.assignmentExpression("=", internalScope["default"].pos, builders.conditionalExpression(builders.binaryExpression("<", scope["default"].depth, builders.numericLiteral(iterator.state.pos)), builders.numericLiteral(-1), scope["default"].depth)), builders.binaryExpression("===", internalScope["default"].pos, builders.numericLiteral(-1))]);
      } else {
        return null;
      }
    }
    function generateFilterScriptExpression(iterator, {
      deep,
      value
    }, tree) {
      var _iterator$feedback2;
      const esTree = jsep["default"](value);
      assertDefinedIdentifier(esTree);
      const node = builders.unaryExpression("!", rewriteESTree(tree, esTree, iterator.state.fixed && iterator.state.pos > 0 && iterator.nextNode !== null ? iterator.state.pos + 1 : iterator.state.inverted && iterator.state.pos !== 0 ? iterator.state.pos - 1 : 0));
      if (iterator.feedback.bailed || !deep || iterator.state.inverted)
        return node;
      (_iterator$feedback2 = iterator.feedback).mutatesPos || (_iterator$feedback2.mutatesPos = iterator.nextNode !== null && iterator.nextNode !== "KeyExpression");
      const assignment = builders.sequenceExpression([builders.assignmentExpression("=", internalScope["default"].pos, builders.conditionalExpression(node, builders.numericLiteral(-1), scope["default"].depth)), builders.binaryExpression("===", internalScope["default"].pos, builders.numericLiteral(-1))]);
      if (iterator.state.pos === 0)
        return assignment;
      return builders.logicalExpression("||", builders.binaryExpression("<", scope["default"].depth, iterator.state.pos === 0 ? internalScope["default"].pos : builders.binaryExpression("+", internalScope["default"].pos, builders.numericLiteral(iterator.state.pos))), assignment);
    }
    function rewriteESTree(tree, node, pos) {
      switch (node.type) {
        case "LogicalExpression":
        case "BinaryExpression":
          if (node.operator === "in") {
            node.operator = "===";
            node.left = builders.callExpression(builders.memberExpression(node.right, builders.identifier("includes")), [rewriteESTree(tree, node.left, pos)]);
            node.right = builders.booleanLiteral(true);
          } else if (node.operator === "~=") {
            node.operator = "===";
            if (node.right.type !== "Literal") {
              throw SyntaxError("Expected string");
            }
            node.left = builders.callExpression(builders.memberExpression(builders.regExpLiteral(node.right.value, ""), builders.identifier("test")), [rewriteESTree(tree, node.left, pos)]);
            node.right = builders.booleanLiteral(true);
          } else {
            node.left = rewriteESTree(tree, node.left, pos);
            node.right = rewriteESTree(tree, node.right, pos);
            assertDefinedIdentifier(node.left);
            assertDefinedIdentifier(node.right);
          }
          break;
        case "UnaryExpression":
          node.argument = rewriteESTree(tree, node.argument, pos);
          assertDefinedIdentifier(node.argument);
          return node;
        case "MemberExpression":
          node.object = rewriteESTree(tree, node.object, pos);
          assertDefinedIdentifier(node.object);
          node.property = rewriteESTree(tree, node.property, pos);
          if (node.computed) {
            assertDefinedIdentifier(node.property);
          }
          break;
        case "CallExpression":
          if (node.callee.type === "Identifier" && node.callee.name.startsWith("@")) {
            return processAtIdentifier(tree, node.callee.name, pos);
          }
          node.callee = rewriteESTree(tree, node.callee, pos);
          node.arguments = node.arguments.map((argument) => rewriteESTree(tree, argument, pos));
          if (node.callee.type === "MemberExpression" && node.callee.object === sandbox["default"].property && node.callee.property.name in String.prototype) {
            node.callee.object = builders.callExpression(builders.identifier("String"), [node.callee.object]);
          }
          assertDefinedIdentifier(node.callee);
          break;
        case "Identifier":
          if (node.name.startsWith("@")) {
            return processAtIdentifier(tree, node.name, pos);
          }
          if (node.name === "undefined") {
            return builders.unaryExpression("void", builders.numericLiteral(0));
          }
          if (node.name === "index") {
            return sandbox["default"].index;
          }
          break;
      }
      return node;
    }
    function processAtIdentifier(tree, name, pos) {
      switch (name) {
        case "@":
          return remapSandbox(sandbox["default"].value, pos);
        case "@root":
          return remapSandbox(sandbox["default"].root, pos);
        case "@path":
          return remapSandbox(sandbox["default"].path, pos);
        case "@property":
          return remapSandbox(sandbox["default"].property, pos);
        case "@parent":
          return remapSandbox(sandbox["default"].parentValue, pos);
        case "@parentProperty":
          return remapSandbox(sandbox["default"].parentProperty, pos);
        case "@string":
        case "@number":
        case "@boolean":
          return builders.binaryExpression("===", builders.unaryExpression("typeof", remapSandbox(sandbox["default"].value, pos)), builders.stringLiteral(name.slice(1)));
        case "@scalar":
          return builders.logicalExpression("||", builders.binaryExpression("===", remapSandbox(sandbox["default"].value, pos), builders.nullLiteral()), builders.binaryExpression("!==", builders.unaryExpression("typeof", remapSandbox(sandbox["default"].value, pos)), builders.stringLiteral("object")));
        case "@array":
          return builders.callExpression(builders.memberExpression(builders.identifier("Array"), builders.identifier("isArray")), [remapSandbox(sandbox["default"].value, pos)]);
        case "@null":
          return builders.binaryExpression("===", remapSandbox(sandbox["default"].value, pos), builders.nullLiteral());
        case "@object":
          return builders.logicalExpression("&&", builders.binaryExpression("!==", remapSandbox(sandbox["default"].value, pos), builders.nullLiteral()), builders.binaryExpression("===", builders.unaryExpression("typeof", remapSandbox(sandbox["default"].value, pos)), builders.stringLiteral("object")));
        case "@integer":
          return builders.callExpression(builders.memberExpression(builders.identifier("Number"), builders.identifier("isInteger")), [remapSandbox(sandbox["default"].value, pos)]);
        default:
          if (name.startsWith("@@")) {
            const shorthandName = name.slice(2);
            tree.attachCustomShorthand(shorthandName);
            return builders.callExpression(builders.memberExpression(internalScope["default"].shorthands, builders.identifier(shorthandName)), [scope["default"]._]);
          }
          throw new SyntaxError(`Unsupported shorthand '${name}'`);
      }
    }
    var KNOWN_IDENTIFIERS = [scope["default"]._.name, "index"];
    function assertDefinedIdentifier(node) {
      if (node.type !== "Identifier")
        return;
      if (KNOWN_IDENTIFIERS.includes(node.name))
        return;
      throw ReferenceError(`'${node.name}' is not defined`);
    }
    function remapSandbox(node, pos) {
      if (node.type === "MemberExpression" && pos !== 0) {
        return {
          ...node,
          object: builders.callExpression(sandbox["default"].at, [builders.numericLiteral(pos)])
        };
      }
      return node;
    }
    exports.generateFilterScriptExpression = generateFilterScriptExpression;
    exports.generateMemberExpression = generateMemberExpression;
    exports.generateMultipleMemberExpression = generateMultipleMemberExpression;
    exports.generateSliceExpression = generateSliceExpression;
    exports.generateWildcardExpression = generateWildcardExpression;
    exports.rewriteESTree = rewriteESTree;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/only-filter-script-expression.js
var require_only_filter_script_expression = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/only-filter-script-expression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsep = require_jsep();
    var builders = require_builders();
    var generators = require_generators();
    var guards = require_guards();
    var emitCall = require_emit_call();
    var scope = require_scope();
    var TOP_LEVEL_DEPTH_IF_STATEMENT = builders.ifStatement(builders.binaryExpression("!==", scope["default"].depth, builders.numericLiteral(0)), builders.returnStatement());
    var onlyFilterScriptExpression = (nodes, tree, ctx) => {
      if (nodes.length !== 1 || !guards.isScriptFilterExpression(nodes[0])) {
        return false;
      }
      const condition = builders.unaryExpression("!", generators.rewriteESTree(tree, jsep["default"](nodes[0].value), 0), true);
      tree.pushAll([[builders.blockStatement([...guards.isDeep(nodes[0]) ? [] : [TOP_LEVEL_DEPTH_IF_STATEMENT], builders.ifStatement(condition, builders.returnStatement()), emitCall["default"](ctx.id, ctx.iterator.modifiers)]), "tree-method"], [builders.stringLiteral(ctx.id), "traverse"]]);
      if (!guards.isDeep(nodes[0])) {
        var _tree$traversalZones$;
        (_tree$traversalZones$ = tree.traversalZones.create()) === null || _tree$traversalZones$ === void 0 ? void 0 : _tree$traversalZones$.resize().attach();
      }
      return true;
    };
    exports["default"] = onlyFilterScriptExpression;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/root.js
var require_root2 = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/root.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var emitCall = require_emit_call();
    var EMIT_ROOT_CALL_EXPRESSION = emitCall["default"]("$", {
      keyed: false,
      parents: 0
    });
    var root = (nodes, tree) => {
      if (nodes.length > 0) {
        return false;
      }
      tree.push(EMIT_ROOT_CALL_EXPRESSION, "body");
      return true;
    };
    exports["default"] = root;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/top-level-wildcard.js
var require_top_level_wildcard = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/top-level-wildcard.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var guards = require_guards();
    var emitCall = require_emit_call();
    var scope = require_scope();
    var IS_NOT_ZERO_DEPTH_IF_STATEMENT = builders.ifStatement(builders.binaryExpression("!==", scope["default"].depth, builders.numericLiteral(0)), builders.returnStatement());
    var topLevelWildcard = (nodes, tree, ctx) => {
      var _tree$traversalZones$;
      if (nodes.length !== 1 || !guards.isWildcardExpression(nodes[0]) || guards.isDeep(nodes[0])) {
        return false;
      }
      tree.push(builders.blockStatement([IS_NOT_ZERO_DEPTH_IF_STATEMENT, emitCall["default"](ctx.id, ctx.iterator.modifiers)]), "tree-method");
      tree.push(builders.stringLiteral(ctx.id), "traverse");
      (_tree$traversalZones$ = tree.traversalZones.create()) === null || _tree$traversalZones$ === void 0 ? void 0 : _tree$traversalZones$.resize().attach();
      return true;
    };
    exports["default"] = topLevelWildcard;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/index.js
var require_fast_paths = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/fast-paths/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var allParents = require_all_parents();
    var deepSingleMember = require_deep_single_member();
    var deepWildcard = require_deep_wildcard();
    var fixed = require_fixed();
    var onlyFilterScriptExpression = require_only_filter_script_expression();
    var root = require_root2();
    var topLevelWildcard = require_top_level_wildcard();
    var fastPaths = [root["default"], onlyFilterScriptExpression["default"], deepSingleMember["default"], deepWildcard["default"], topLevelWildcard["default"], fixed["default"], allParents["default"]];
    exports["default"] = fastPaths;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
    var guards = require_guards();
    var _Symbol$iterator;
    function isBailable(nodes) {
      let deep = false;
      for (let i3 = 0; i3 < nodes.length; i3++) {
        const node = nodes[i3];
        if (!guards.isDeep(node))
          continue;
        if (deep) {
          return true;
        } else if (guards.isMemberExpression(node)) {
          i3++;
          let hadFlatMemberExpressions = false;
          let deepNodes = 1;
          for (; i3 < nodes.length - 1; i3++) {
            const node2 = nodes[i3];
            if (guards.isDeep(node2)) {
              deepNodes++;
            } else {
              hadFlatMemberExpressions || (hadFlatMemberExpressions = guards.isMemberExpression(node2) || guards.isWildcardExpression(node2));
              continue;
            }
            if (guards.isMemberExpression(node2) || guards.isWildcardExpression(node2)) {
              if (hadFlatMemberExpressions)
                return true;
              continue;
            }
            return true;
          }
          return guards.isDeep(nodes[nodes.length - 1]) ? hadFlatMemberExpressions || guards.isWildcardExpression(nodes[nodes.length - 1]) : deepNodes > 1;
        } else {
          deep = true;
        }
      }
      return false;
    }
    var _i = /* @__PURE__ */ new WeakMap();
    _Symbol$iterator = Symbol.iterator;
    var Iterator = class _Iterator {
      constructor(nodes) {
        _rollupPluginBabelHelpers.defineProperty(this, "nodes", void 0);
        _i.set(this, {
          writable: true,
          value: void 0
        });
        this.modifiers = _Iterator.trim(nodes);
        this.nodes = _Iterator.compact(nodes);
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _i, -1);
        this.feedback = _Iterator.analyze(this.nodes, this.modifiers.keyed || this.modifiers.parents > 0);
        this.length = this.nodes.length;
        this.state = {
          absolutePos: -1,
          fixed: true,
          inverted: false,
          pos: -1
        };
        if (this.feedback.fixed && this.modifiers.parents > this.length) {
          this.length = -1;
        }
      }
      get nextNode() {
        return _rollupPluginBabelHelpers.classPrivateFieldGet(this, _i) + 1 < this.nodes.length ? this.nodes[_rollupPluginBabelHelpers.classPrivateFieldGet(this, _i) + 1] : null;
      }
      static compact(nodes) {
        let marked;
        for (let i3 = 0; i3 < nodes.length; i3++) {
          if (guards.isWildcardExpression(nodes[i3]) && guards.isDeep(nodes[i3]) && i3 !== nodes.length - 1) {
            var _marked;
            ((_marked = marked) !== null && _marked !== void 0 ? _marked : marked = []).push(i3);
          }
        }
        if (marked === void 0) {
          return nodes;
        }
        const _nodes = nodes.slice();
        for (let i3 = 0; i3 < marked.length; i3++) {
          _nodes[marked[i3] - i3 + 1].deep = true;
          _nodes.splice(marked[i3] - i3, 1);
        }
        return _nodes;
      }
      static trim(nodes) {
        const modifiers = {
          keyed: false,
          parents: 0
        };
        while (nodes.length > 0 && guards.isModifierExpression(nodes[nodes.length - 1])) {
          switch (nodes.pop().type) {
            case "KeyExpression":
              modifiers.keyed = true;
              modifiers.parents = 0;
              break;
            case "ParentExpression":
              modifiers.parents++;
              break;
          }
        }
        return modifiers;
      }
      static analyze(nodes) {
        const feedback = {
          bailed: isBailable(nodes),
          fixed: true,
          inverseAt: -1
        };
        if (feedback.bailed) {
          feedback.fixed = false;
          return feedback;
        }
        let potentialInvertAtPoint = -1;
        for (let i3 = 0; i3 < nodes.length; i3++) {
          const node = nodes[i3];
          if (!guards.isDeep(node))
            continue;
          feedback.fixed = false;
          i3++;
          potentialInvertAtPoint = i3 - 1;
          for (; i3 < nodes.length; i3++) {
            const nextNode = nodes[i3];
            if (guards.isDeep(nextNode)) {
              potentialInvertAtPoint = -1;
            }
          }
        }
        if (nodes.length > 1 && potentialInvertAtPoint !== -1 && potentialInvertAtPoint < nodes.length - 1) {
          feedback.inverseAt = potentialInvertAtPoint;
        }
        return feedback;
      }
      *[_Symbol$iterator]() {
        if (this.feedback.bailed) {
          return yield* this.nodes;
        }
        const {
          ...feedback
        } = this.feedback;
        let order = 1;
        const nodes = this.feedback.inverseAt !== -1 ? this.nodes.slice() : this.nodes;
        for (let i3 = 0; i3 < nodes.length; i3++) {
          if (this.feedback.inverseAt !== -1 && i3 === this.feedback.inverseAt) {
            nodes.splice(0, i3);
            nodes.reverse();
            this.state.pos = 1;
            i3 = 0;
            this.feedback.inverseAt = -1;
            this.state.inverted = true;
            order = -1;
          }
          const node = nodes[i3];
          this.state.pos += order;
          _rollupPluginBabelHelpers.classPrivateFieldSet(this, _i, +_rollupPluginBabelHelpers.classPrivateFieldGet(this, _i) + 1);
          this.state.absolutePos++;
          if (guards.isDeep(node)) {
            this.state.fixed = false;
            yield node;
            this.state.pos = 0;
          } else {
            yield node;
          }
        }
        Object.assign(this.feedback, {
          ...feedback,
          mutatesPos: this.feedback.mutatesPos
        });
      }
    };
    exports["default"] = Iterator;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/optimizer/index.js
var require_optimizer = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/optimizer/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var internalScope = require_internal_scope();
    var scope = require_scope();
    function dropNode(branch, i3) {
      branch.splice(i3, 1);
      return i3 - 1;
    }
    function leftOrRight(node, left, right) {
      if (left === null) {
        return right;
      } else if (right === null) {
        return left;
      }
      node.left = left;
      node.right = right;
      return node;
    }
    function reduceBinaryExpression(node) {
      if (node.operator === "<" && node.left === scope["default"].depth) {
        return null;
      }
      return leftOrRight(node, eliminate(node.left), eliminate(node.right));
    }
    function eliminate(node) {
      switch (node.type) {
        case "AssignmentExpression":
          if (node.left !== internalScope["default"].pos) {
            return node;
          }
          return eliminate(node.right);
        case "ConditionalExpression":
          if (node.consequent.type === "NumericLiteral" && node.consequent.value === -1) {
            return eliminate(node.test);
          }
          return node;
        case "SequenceExpression":
          return eliminate(node.expressions[0]);
        case "LogicalExpression":
          return leftOrRight(node, eliminate(node.left), eliminate(node.right));
        case "BinaryExpression":
          return reduceBinaryExpression(node);
        case "IfStatement":
          return eliminate(node.test);
        case "Identifier":
          if (node === internalScope["default"].pos) {
            return null;
          }
          return node;
        case "MemberExpression":
          node.property = eliminate(node.property);
          return node;
        default:
          return node;
      }
    }
    function optimizer(branch, iterator) {
      if (iterator.feedback.mutatesPos)
        return;
      let i3 = Math.max(0, Math.min(1, iterator.length));
      for (; i3 < branch.length; i3++) {
        const node = branch[i3];
        if (node.type === "VariableDeclaration" && node.kind === "let" && node.declarations[0].id === internalScope["default"].pos) {
          i3 = dropNode(branch, i3);
          continue;
        }
        const test = eliminate(node);
        if (test === null || test === scope["default"].depth) {
          i3 = dropNode(branch, i3);
        } else {
          node.test = test;
        }
      }
    }
    exports["default"] = optimizer;
  }
});

// ../../node_modules/astring/dist/astring.js
var require_astring = __commonJS({
  "../../node_modules/astring/dist/astring.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.generate = generate;
    exports.baseGenerator = exports.GENERATOR = exports.EXPRESSIONS_PRECEDENCE = exports.NEEDS_PARENTHESES = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var stringify2 = JSON.stringify;
    if (!String.prototype.repeat) {
      throw new Error("String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation");
    }
    if (!String.prototype.endsWith) {
      throw new Error("String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation");
    }
    var OPERATOR_PRECEDENCE = {
      "||": 2,
      "??": 3,
      "&&": 4,
      "|": 5,
      "^": 6,
      "&": 7,
      "==": 8,
      "!=": 8,
      "===": 8,
      "!==": 8,
      "<": 9,
      ">": 9,
      "<=": 9,
      ">=": 9,
      "in": 9,
      "instanceof": 9,
      "<<": 10,
      ">>": 10,
      ">>>": 10,
      "+": 11,
      "-": 11,
      "*": 12,
      "%": 12,
      "/": 12,
      "**": 13
    };
    var NEEDS_PARENTHESES = 17;
    exports.NEEDS_PARENTHESES = NEEDS_PARENTHESES;
    var EXPRESSIONS_PRECEDENCE = {
      ArrayExpression: 20,
      TaggedTemplateExpression: 20,
      ThisExpression: 20,
      Identifier: 20,
      PrivateIdentifier: 20,
      Literal: 18,
      TemplateLiteral: 20,
      Super: 20,
      SequenceExpression: 20,
      MemberExpression: 19,
      ChainExpression: 19,
      CallExpression: 19,
      NewExpression: 19,
      ArrowFunctionExpression: NEEDS_PARENTHESES,
      ClassExpression: NEEDS_PARENTHESES,
      FunctionExpression: NEEDS_PARENTHESES,
      ObjectExpression: NEEDS_PARENTHESES,
      UpdateExpression: 16,
      UnaryExpression: 15,
      AwaitExpression: 15,
      BinaryExpression: 14,
      LogicalExpression: 13,
      ConditionalExpression: 4,
      AssignmentExpression: 3,
      YieldExpression: 2,
      RestElement: 1
    };
    exports.EXPRESSIONS_PRECEDENCE = EXPRESSIONS_PRECEDENCE;
    function formatSequence(state, nodes) {
      var generator = state.generator;
      state.write("(");
      if (nodes != null && nodes.length > 0) {
        generator[nodes[0].type](nodes[0], state);
        var length = nodes.length;
        for (var i3 = 1; i3 < length; i3++) {
          var param = nodes[i3];
          state.write(", ");
          generator[param.type](param, state);
        }
      }
      state.write(")");
    }
    function expressionNeedsParenthesis(state, node, parentNode, isRightHand) {
      var nodePrecedence = state.expressionsPrecedence[node.type];
      if (nodePrecedence === NEEDS_PARENTHESES) {
        return true;
      }
      var parentNodePrecedence = state.expressionsPrecedence[parentNode.type];
      if (nodePrecedence !== parentNodePrecedence) {
        return !isRightHand && nodePrecedence === 15 && parentNodePrecedence === 14 && parentNode.operator === "**" || nodePrecedence < parentNodePrecedence;
      }
      if (nodePrecedence !== 13 && nodePrecedence !== 14) {
        return false;
      }
      if (node.operator === "**" && parentNode.operator === "**") {
        return !isRightHand;
      }
      if (nodePrecedence === 13 && parentNodePrecedence === 13 && (node.operator === "??" || parentNode.operator === "??")) {
        return true;
      }
      if (isRightHand) {
        return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parentNode.operator];
      }
      return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parentNode.operator];
    }
    function formatExpression(state, node, parentNode, isRightHand) {
      var generator = state.generator;
      if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {
        state.write("(");
        generator[node.type](node, state);
        state.write(")");
      } else {
        generator[node.type](node, state);
      }
    }
    function reindent(state, text, indent, lineEnd) {
      var lines = text.split("\n");
      var end = lines.length - 1;
      state.write(lines[0].trim());
      if (end > 0) {
        state.write(lineEnd);
        for (var i3 = 1; i3 < end; i3++) {
          state.write(indent + lines[i3].trim() + lineEnd);
        }
        state.write(indent + lines[end].trim());
      }
    }
    function formatComments(state, comments, indent, lineEnd) {
      var length = comments.length;
      for (var i3 = 0; i3 < length; i3++) {
        var comment = comments[i3];
        state.write(indent);
        if (comment.type[0] === "L") {
          state.write("// " + comment.value.trim() + "\n", comment);
        } else {
          state.write("/*");
          reindent(state, comment.value, indent, lineEnd);
          state.write("*/" + lineEnd);
        }
      }
    }
    function hasCallExpression(node) {
      var currentNode = node;
      while (currentNode != null) {
        var _currentNode = currentNode, type = _currentNode.type;
        if (type[0] === "C" && type[1] === "a") {
          return true;
        } else if (type[0] === "M" && type[1] === "e" && type[2] === "m") {
          currentNode = currentNode.object;
        } else {
          return false;
        }
      }
    }
    function formatVariableDeclaration(state, node) {
      var generator = state.generator;
      var declarations = node.declarations;
      state.write(node.kind + " ");
      var length = declarations.length;
      if (length > 0) {
        generator.VariableDeclarator(declarations[0], state);
        for (var i3 = 1; i3 < length; i3++) {
          state.write(", ");
          generator.VariableDeclarator(declarations[i3], state);
        }
      }
    }
    var ForInStatement;
    var FunctionDeclaration;
    var RestElement;
    var BinaryExpression;
    var ArrayExpression;
    var BlockStatement;
    var GENERATOR = {
      Program: function Program(node, state) {
        var indent = state.indent.repeat(state.indentLevel);
        var lineEnd = state.lineEnd, writeComments = state.writeComments;
        if (writeComments && node.comments != null) {
          formatComments(state, node.comments, indent, lineEnd);
        }
        var statements = node.body;
        var length = statements.length;
        for (var i3 = 0; i3 < length; i3++) {
          var statement = statements[i3];
          if (writeComments && statement.comments != null) {
            formatComments(state, statement.comments, indent, lineEnd);
          }
          state.write(indent);
          this[statement.type](statement, state);
          state.write(lineEnd);
        }
        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, indent, lineEnd);
        }
      },
      BlockStatement: BlockStatement = function BlockStatement2(node, state) {
        var indent = state.indent.repeat(state.indentLevel++);
        var lineEnd = state.lineEnd, writeComments = state.writeComments;
        var statementIndent = indent + state.indent;
        state.write("{");
        var statements = node.body;
        if (statements != null && statements.length > 0) {
          state.write(lineEnd);
          if (writeComments && node.comments != null) {
            formatComments(state, node.comments, statementIndent, lineEnd);
          }
          var length = statements.length;
          for (var i3 = 0; i3 < length; i3++) {
            var statement = statements[i3];
            if (writeComments && statement.comments != null) {
              formatComments(state, statement.comments, statementIndent, lineEnd);
            }
            state.write(statementIndent);
            this[statement.type](statement, state);
            state.write(lineEnd);
          }
          state.write(indent);
        } else {
          if (writeComments && node.comments != null) {
            state.write(lineEnd);
            formatComments(state, node.comments, statementIndent, lineEnd);
            state.write(indent);
          }
        }
        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, statementIndent, lineEnd);
        }
        state.write("}");
        state.indentLevel--;
      },
      ClassBody: BlockStatement,
      StaticBlock: function StaticBlock(node, state) {
        state.write("static ");
        this.BlockStatement(node, state);
      },
      EmptyStatement: function EmptyStatement(node, state) {
        state.write(";");
      },
      ExpressionStatement: function ExpressionStatement(node, state) {
        var precedence = state.expressionsPrecedence[node.expression.type];
        if (precedence === NEEDS_PARENTHESES || precedence === 3 && node.expression.left.type[0] === "O") {
          state.write("(");
          this[node.expression.type](node.expression, state);
          state.write(")");
        } else {
          this[node.expression.type](node.expression, state);
        }
        state.write(";");
      },
      IfStatement: function IfStatement(node, state) {
        state.write("if (");
        this[node.test.type](node.test, state);
        state.write(") ");
        this[node.consequent.type](node.consequent, state);
        if (node.alternate != null) {
          state.write(" else ");
          this[node.alternate.type](node.alternate, state);
        }
      },
      LabeledStatement: function LabeledStatement(node, state) {
        this[node.label.type](node.label, state);
        state.write(": ");
        this[node.body.type](node.body, state);
      },
      BreakStatement: function BreakStatement(node, state) {
        state.write("break");
        if (node.label != null) {
          state.write(" ");
          this[node.label.type](node.label, state);
        }
        state.write(";");
      },
      ContinueStatement: function ContinueStatement(node, state) {
        state.write("continue");
        if (node.label != null) {
          state.write(" ");
          this[node.label.type](node.label, state);
        }
        state.write(";");
      },
      WithStatement: function WithStatement(node, state) {
        state.write("with (");
        this[node.object.type](node.object, state);
        state.write(") ");
        this[node.body.type](node.body, state);
      },
      SwitchStatement: function SwitchStatement(node, state) {
        var indent = state.indent.repeat(state.indentLevel++);
        var lineEnd = state.lineEnd, writeComments = state.writeComments;
        state.indentLevel++;
        var caseIndent = indent + state.indent;
        var statementIndent = caseIndent + state.indent;
        state.write("switch (");
        this[node.discriminant.type](node.discriminant, state);
        state.write(") {" + lineEnd);
        var occurences = node.cases;
        var occurencesCount = occurences.length;
        for (var i3 = 0; i3 < occurencesCount; i3++) {
          var occurence = occurences[i3];
          if (writeComments && occurence.comments != null) {
            formatComments(state, occurence.comments, caseIndent, lineEnd);
          }
          if (occurence.test) {
            state.write(caseIndent + "case ");
            this[occurence.test.type](occurence.test, state);
            state.write(":" + lineEnd);
          } else {
            state.write(caseIndent + "default:" + lineEnd);
          }
          var consequent = occurence.consequent;
          var consequentCount = consequent.length;
          for (var _i = 0; _i < consequentCount; _i++) {
            var statement = consequent[_i];
            if (writeComments && statement.comments != null) {
              formatComments(state, statement.comments, statementIndent, lineEnd);
            }
            state.write(statementIndent);
            this[statement.type](statement, state);
            state.write(lineEnd);
          }
        }
        state.indentLevel -= 2;
        state.write(indent + "}");
      },
      ReturnStatement: function ReturnStatement(node, state) {
        state.write("return");
        if (node.argument) {
          state.write(" ");
          this[node.argument.type](node.argument, state);
        }
        state.write(";");
      },
      ThrowStatement: function ThrowStatement(node, state) {
        state.write("throw ");
        this[node.argument.type](node.argument, state);
        state.write(";");
      },
      TryStatement: function TryStatement(node, state) {
        state.write("try ");
        this[node.block.type](node.block, state);
        if (node.handler) {
          var handler = node.handler;
          if (handler.param == null) {
            state.write(" catch ");
          } else {
            state.write(" catch (");
            this[handler.param.type](handler.param, state);
            state.write(") ");
          }
          this[handler.body.type](handler.body, state);
        }
        if (node.finalizer) {
          state.write(" finally ");
          this[node.finalizer.type](node.finalizer, state);
        }
      },
      WhileStatement: function WhileStatement(node, state) {
        state.write("while (");
        this[node.test.type](node.test, state);
        state.write(") ");
        this[node.body.type](node.body, state);
      },
      DoWhileStatement: function DoWhileStatement(node, state) {
        state.write("do ");
        this[node.body.type](node.body, state);
        state.write(" while (");
        this[node.test.type](node.test, state);
        state.write(");");
      },
      ForStatement: function ForStatement(node, state) {
        state.write("for (");
        if (node.init != null) {
          var init = node.init;
          if (init.type[0] === "V") {
            formatVariableDeclaration(state, init);
          } else {
            this[init.type](init, state);
          }
        }
        state.write("; ");
        if (node.test) {
          this[node.test.type](node.test, state);
        }
        state.write("; ");
        if (node.update) {
          this[node.update.type](node.update, state);
        }
        state.write(") ");
        this[node.body.type](node.body, state);
      },
      ForInStatement: ForInStatement = function ForInStatement2(node, state) {
        state.write("for ".concat(node["await"] ? "await " : "", "("));
        var left = node.left;
        if (left.type[0] === "V") {
          formatVariableDeclaration(state, left);
        } else {
          this[left.type](left, state);
        }
        state.write(node.type[3] === "I" ? " in " : " of ");
        this[node.right.type](node.right, state);
        state.write(") ");
        this[node.body.type](node.body, state);
      },
      ForOfStatement: ForInStatement,
      DebuggerStatement: function DebuggerStatement(node, state) {
        state.write("debugger;", node);
      },
      FunctionDeclaration: FunctionDeclaration = function FunctionDeclaration2(node, state) {
        state.write((node.async ? "async " : "") + (node.generator ? "function* " : "function ") + (node.id ? node.id.name : ""), node);
        formatSequence(state, node.params);
        state.write(" ");
        this[node.body.type](node.body, state);
      },
      FunctionExpression: FunctionDeclaration,
      VariableDeclaration: function VariableDeclaration(node, state) {
        formatVariableDeclaration(state, node);
        state.write(";");
      },
      VariableDeclarator: function VariableDeclarator(node, state) {
        this[node.id.type](node.id, state);
        if (node.init != null) {
          state.write(" = ");
          this[node.init.type](node.init, state);
        }
      },
      ClassDeclaration: function ClassDeclaration(node, state) {
        state.write("class " + (node.id ? "".concat(node.id.name, " ") : ""), node);
        if (node.superClass) {
          state.write("extends ");
          var superClass = node.superClass;
          var type = superClass.type;
          var precedence = state.expressionsPrecedence[type];
          if ((type[0] !== "C" || type[1] !== "l" || type[5] !== "E") && (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.ClassExpression)) {
            state.write("(");
            this[node.superClass.type](superClass, state);
            state.write(")");
          } else {
            this[superClass.type](superClass, state);
          }
          state.write(" ");
        }
        this.ClassBody(node.body, state);
      },
      ImportDeclaration: function ImportDeclaration(node, state) {
        state.write("import ");
        var specifiers = node.specifiers;
        var length = specifiers.length;
        var i3 = 0;
        if (length > 0) {
          for (; i3 < length; ) {
            if (i3 > 0) {
              state.write(", ");
            }
            var specifier = specifiers[i3];
            var type = specifier.type[6];
            if (type === "D") {
              state.write(specifier.local.name, specifier);
              i3++;
            } else if (type === "N") {
              state.write("* as " + specifier.local.name, specifier);
              i3++;
            } else {
              break;
            }
          }
          if (i3 < length) {
            state.write("{");
            for (; ; ) {
              var _specifier = specifiers[i3];
              var name = _specifier.imported.name;
              state.write(name, _specifier);
              if (name !== _specifier.local.name) {
                state.write(" as " + _specifier.local.name);
              }
              if (++i3 < length) {
                state.write(", ");
              } else {
                break;
              }
            }
            state.write("}");
          }
          state.write(" from ");
        }
        this.Literal(node.source, state);
        state.write(";");
      },
      ImportExpression: function ImportExpression(node, state) {
        state.write("import(");
        this[node.source.type](node.source, state);
        state.write(")");
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(node, state) {
        state.write("export default ");
        this[node.declaration.type](node.declaration, state);
        if (state.expressionsPrecedence[node.declaration.type] != null && node.declaration.type[0] !== "F") {
          state.write(";");
        }
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(node, state) {
        state.write("export ");
        if (node.declaration) {
          this[node.declaration.type](node.declaration, state);
        } else {
          state.write("{");
          var specifiers = node.specifiers, length = specifiers.length;
          if (length > 0) {
            for (var i3 = 0; ; ) {
              var specifier = specifiers[i3];
              var name = specifier.local.name;
              state.write(name, specifier);
              if (name !== specifier.exported.name) {
                state.write(" as " + specifier.exported.name);
              }
              if (++i3 < length) {
                state.write(", ");
              } else {
                break;
              }
            }
          }
          state.write("}");
          if (node.source) {
            state.write(" from ");
            this.Literal(node.source, state);
          }
          state.write(";");
        }
      },
      ExportAllDeclaration: function ExportAllDeclaration(node, state) {
        if (node.exported != null) {
          state.write("export * as " + node.exported.name + " from ");
        } else {
          state.write("export * from ");
        }
        this.Literal(node.source, state);
        state.write(";");
      },
      MethodDefinition: function MethodDefinition(node, state) {
        if (node["static"]) {
          state.write("static ");
        }
        var kind = node.kind[0];
        if (kind === "g" || kind === "s") {
          state.write(node.kind + " ");
        }
        if (node.value.async) {
          state.write("async ");
        }
        if (node.value.generator) {
          state.write("*");
        }
        if (node.computed) {
          state.write("[");
          this[node.key.type](node.key, state);
          state.write("]");
        } else {
          this[node.key.type](node.key, state);
        }
        formatSequence(state, node.value.params);
        state.write(" ");
        this[node.value.body.type](node.value.body, state);
      },
      ClassExpression: function ClassExpression(node, state) {
        this.ClassDeclaration(node, state);
      },
      ArrowFunctionExpression: function ArrowFunctionExpression(node, state) {
        state.write(node.async ? "async " : "", node);
        var params = node.params;
        if (params != null) {
          if (params.length === 1 && params[0].type[0] === "I") {
            state.write(params[0].name, params[0]);
          } else {
            formatSequence(state, node.params);
          }
        }
        state.write(" => ");
        if (node.body.type[0] === "O") {
          state.write("(");
          this.ObjectExpression(node.body, state);
          state.write(")");
        } else {
          this[node.body.type](node.body, state);
        }
      },
      ThisExpression: function ThisExpression(node, state) {
        state.write("this", node);
      },
      Super: function Super(node, state) {
        state.write("super", node);
      },
      RestElement: RestElement = function RestElement2(node, state) {
        state.write("...");
        this[node.argument.type](node.argument, state);
      },
      SpreadElement: RestElement,
      YieldExpression: function YieldExpression(node, state) {
        state.write(node.delegate ? "yield*" : "yield");
        if (node.argument) {
          state.write(" ");
          this[node.argument.type](node.argument, state);
        }
      },
      AwaitExpression: function AwaitExpression(node, state) {
        state.write("await ", node);
        formatExpression(state, node.argument, node);
      },
      TemplateLiteral: function TemplateLiteral(node, state) {
        var quasis = node.quasis, expressions = node.expressions;
        state.write("`");
        var length = expressions.length;
        for (var i3 = 0; i3 < length; i3++) {
          var expression = expressions[i3];
          var _quasi = quasis[i3];
          state.write(_quasi.value.raw, _quasi);
          state.write("${");
          this[expression.type](expression, state);
          state.write("}");
        }
        var quasi = quasis[quasis.length - 1];
        state.write(quasi.value.raw, quasi);
        state.write("`");
      },
      TemplateElement: function TemplateElement(node, state) {
        state.write(node.value.raw, node);
      },
      TaggedTemplateExpression: function TaggedTemplateExpression(node, state) {
        formatExpression(state, node.tag, node);
        this[node.quasi.type](node.quasi, state);
      },
      ArrayExpression: ArrayExpression = function ArrayExpression2(node, state) {
        state.write("[");
        if (node.elements.length > 0) {
          var elements = node.elements, length = elements.length;
          for (var i3 = 0; ; ) {
            var element = elements[i3];
            if (element != null) {
              this[element.type](element, state);
            }
            if (++i3 < length) {
              state.write(", ");
            } else {
              if (element == null) {
                state.write(", ");
              }
              break;
            }
          }
        }
        state.write("]");
      },
      ArrayPattern: ArrayExpression,
      ObjectExpression: function ObjectExpression(node, state) {
        var indent = state.indent.repeat(state.indentLevel++);
        var lineEnd = state.lineEnd, writeComments = state.writeComments;
        var propertyIndent = indent + state.indent;
        state.write("{");
        if (node.properties.length > 0) {
          state.write(lineEnd);
          if (writeComments && node.comments != null) {
            formatComments(state, node.comments, propertyIndent, lineEnd);
          }
          var comma = "," + lineEnd;
          var properties = node.properties, length = properties.length;
          for (var i3 = 0; ; ) {
            var property = properties[i3];
            if (writeComments && property.comments != null) {
              formatComments(state, property.comments, propertyIndent, lineEnd);
            }
            state.write(propertyIndent);
            this[property.type](property, state);
            if (++i3 < length) {
              state.write(comma);
            } else {
              break;
            }
          }
          state.write(lineEnd);
          if (writeComments && node.trailingComments != null) {
            formatComments(state, node.trailingComments, propertyIndent, lineEnd);
          }
          state.write(indent + "}");
        } else if (writeComments) {
          if (node.comments != null) {
            state.write(lineEnd);
            formatComments(state, node.comments, propertyIndent, lineEnd);
            if (node.trailingComments != null) {
              formatComments(state, node.trailingComments, propertyIndent, lineEnd);
            }
            state.write(indent + "}");
          } else if (node.trailingComments != null) {
            state.write(lineEnd);
            formatComments(state, node.trailingComments, propertyIndent, lineEnd);
            state.write(indent + "}");
          } else {
            state.write("}");
          }
        } else {
          state.write("}");
        }
        state.indentLevel--;
      },
      Property: function Property(node, state) {
        if (node.method || node.kind[0] !== "i") {
          this.MethodDefinition(node, state);
        } else {
          if (!node.shorthand) {
            if (node.computed) {
              state.write("[");
              this[node.key.type](node.key, state);
              state.write("]");
            } else {
              this[node.key.type](node.key, state);
            }
            state.write(": ");
          }
          this[node.value.type](node.value, state);
        }
      },
      PropertyDefinition: function PropertyDefinition(node, state) {
        if (node["static"]) {
          state.write("static ");
        }
        if (node.computed) {
          state.write("[");
        }
        this[node.key.type](node.key, state);
        if (node.computed) {
          state.write("]");
        }
        if (node.value == null) {
          if (node.key.type[0] !== "F") {
            state.write(";");
          }
          return;
        }
        state.write(" = ");
        this[node.value.type](node.value, state);
        state.write(";");
      },
      ObjectPattern: function ObjectPattern(node, state) {
        state.write("{");
        if (node.properties.length > 0) {
          var properties = node.properties, length = properties.length;
          for (var i3 = 0; ; ) {
            this[properties[i3].type](properties[i3], state);
            if (++i3 < length) {
              state.write(", ");
            } else {
              break;
            }
          }
        }
        state.write("}");
      },
      SequenceExpression: function SequenceExpression(node, state) {
        formatSequence(state, node.expressions);
      },
      UnaryExpression: function UnaryExpression(node, state) {
        if (node.prefix) {
          var operator = node.operator, argument = node.argument, type = node.argument.type;
          state.write(operator);
          var needsParentheses = expressionNeedsParenthesis(state, argument, node);
          if (!needsParentheses && (operator.length > 1 || type[0] === "U" && (type[1] === "n" || type[1] === "p") && argument.prefix && argument.operator[0] === operator && (operator === "+" || operator === "-"))) {
            state.write(" ");
          }
          if (needsParentheses) {
            state.write(operator.length > 1 ? " (" : "(");
            this[type](argument, state);
            state.write(")");
          } else {
            this[type](argument, state);
          }
        } else {
          this[node.argument.type](node.argument, state);
          state.write(node.operator);
        }
      },
      UpdateExpression: function UpdateExpression(node, state) {
        if (node.prefix) {
          state.write(node.operator);
          this[node.argument.type](node.argument, state);
        } else {
          this[node.argument.type](node.argument, state);
          state.write(node.operator);
        }
      },
      AssignmentExpression: function AssignmentExpression(node, state) {
        this[node.left.type](node.left, state);
        state.write(" " + node.operator + " ");
        this[node.right.type](node.right, state);
      },
      AssignmentPattern: function AssignmentPattern(node, state) {
        this[node.left.type](node.left, state);
        state.write(" = ");
        this[node.right.type](node.right, state);
      },
      BinaryExpression: BinaryExpression = function BinaryExpression2(node, state) {
        var isIn = node.operator === "in";
        if (isIn) {
          state.write("(");
        }
        formatExpression(state, node.left, node, false);
        state.write(" " + node.operator + " ");
        formatExpression(state, node.right, node, true);
        if (isIn) {
          state.write(")");
        }
      },
      LogicalExpression: BinaryExpression,
      ConditionalExpression: function ConditionalExpression(node, state) {
        var test = node.test;
        var precedence = state.expressionsPrecedence[test.type];
        if (precedence === NEEDS_PARENTHESES || precedence <= state.expressionsPrecedence.ConditionalExpression) {
          state.write("(");
          this[test.type](test, state);
          state.write(")");
        } else {
          this[test.type](test, state);
        }
        state.write(" ? ");
        this[node.consequent.type](node.consequent, state);
        state.write(" : ");
        this[node.alternate.type](node.alternate, state);
      },
      NewExpression: function NewExpression(node, state) {
        state.write("new ");
        var precedence = state.expressionsPrecedence[node.callee.type];
        if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression || hasCallExpression(node.callee)) {
          state.write("(");
          this[node.callee.type](node.callee, state);
          state.write(")");
        } else {
          this[node.callee.type](node.callee, state);
        }
        formatSequence(state, node["arguments"]);
      },
      CallExpression: function CallExpression(node, state) {
        var precedence = state.expressionsPrecedence[node.callee.type];
        if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression) {
          state.write("(");
          this[node.callee.type](node.callee, state);
          state.write(")");
        } else {
          this[node.callee.type](node.callee, state);
        }
        if (node.optional) {
          state.write("?.");
        }
        formatSequence(state, node["arguments"]);
      },
      ChainExpression: function ChainExpression(node, state) {
        this[node.expression.type](node.expression, state);
      },
      MemberExpression: function MemberExpression(node, state) {
        var precedence = state.expressionsPrecedence[node.object.type];
        if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.MemberExpression) {
          state.write("(");
          this[node.object.type](node.object, state);
          state.write(")");
        } else {
          this[node.object.type](node.object, state);
        }
        if (node.computed) {
          if (node.optional) {
            state.write("?.");
          }
          state.write("[");
          this[node.property.type](node.property, state);
          state.write("]");
        } else {
          if (node.optional) {
            state.write("?.");
          } else {
            state.write(".");
          }
          this[node.property.type](node.property, state);
        }
      },
      MetaProperty: function MetaProperty(node, state) {
        state.write(node.meta.name + "." + node.property.name, node);
      },
      Identifier: function Identifier(node, state) {
        state.write(node.name, node);
      },
      PrivateIdentifier: function PrivateIdentifier(node, state) {
        state.write("#".concat(node.name), node);
      },
      Literal: function Literal(node, state) {
        if (node.raw != null) {
          state.write(node.raw, node);
        } else if (node.regex != null) {
          this.RegExpLiteral(node, state);
        } else if (node.bigint != null) {
          state.write(node.bigint + "n", node);
        } else {
          state.write(stringify2(node.value), node);
        }
      },
      RegExpLiteral: function RegExpLiteral(node, state) {
        var regex3 = node.regex;
        state.write("/".concat(regex3.pattern, "/").concat(regex3.flags), node);
      }
    };
    exports.GENERATOR = GENERATOR;
    var EMPTY_OBJECT = {};
    var baseGenerator = GENERATOR;
    exports.baseGenerator = baseGenerator;
    var State = function() {
      function State2(options) {
        _classCallCheck(this, State2);
        var setup = options == null ? EMPTY_OBJECT : options;
        this.output = "";
        if (setup.output != null) {
          this.output = setup.output;
          this.write = this.writeToStream;
        } else {
          this.output = "";
        }
        this.generator = setup.generator != null ? setup.generator : GENERATOR;
        this.expressionsPrecedence = setup.expressionsPrecedence != null ? setup.expressionsPrecedence : EXPRESSIONS_PRECEDENCE;
        this.indent = setup.indent != null ? setup.indent : "  ";
        this.lineEnd = setup.lineEnd != null ? setup.lineEnd : "\n";
        this.indentLevel = setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
        this.writeComments = setup.comments ? setup.comments : false;
        if (setup.sourceMap != null) {
          this.write = setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
          this.sourceMap = setup.sourceMap;
          this.line = 1;
          this.column = 0;
          this.lineEndSize = this.lineEnd.split("\n").length - 1;
          this.mapping = {
            original: null,
            generated: this,
            name: void 0,
            source: setup.sourceMap.file || setup.sourceMap._file
          };
        }
      }
      _createClass(State2, [{
        key: "write",
        value: function write(code) {
          this.output += code;
        }
      }, {
        key: "writeToStream",
        value: function writeToStream2(code) {
          this.output.write(code);
        }
      }, {
        key: "writeAndMap",
        value: function writeAndMap(code, node) {
          this.output += code;
          this.map(code, node);
        }
      }, {
        key: "writeToStreamAndMap",
        value: function writeToStreamAndMap(code, node) {
          this.output.write(code);
          this.map(code, node);
        }
      }, {
        key: "map",
        value: function map(code, node) {
          if (node != null) {
            var type = node.type;
            if (type[0] === "L" && type[2] === "n") {
              this.column = 0;
              this.line++;
              return;
            }
            if (node.loc != null) {
              var mapping = this.mapping;
              mapping.original = node.loc.start;
              mapping.name = node.name;
              this.sourceMap.addMapping(mapping);
            }
            if (type[0] === "T" && type[8] === "E" || type[0] === "L" && type[1] === "i" && typeof node.value === "string") {
              var _length = code.length;
              var column = this.column, line = this.line;
              for (var i3 = 0; i3 < _length; i3++) {
                if (code[i3] === "\n") {
                  column = 0;
                  line++;
                } else {
                  column++;
                }
              }
              this.column = column;
              this.line = line;
              return;
            }
          }
          var length = code.length;
          var lineEnd = this.lineEnd;
          if (length > 0) {
            if (this.lineEndSize > 0 && (lineEnd.length === 1 ? code[length - 1] === lineEnd : code.endsWith(lineEnd))) {
              this.line += this.lineEndSize;
              this.column = 0;
            } else {
              this.column += length;
            }
          }
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.output;
        }
      }]);
      return State2;
    }();
    function generate(node, options) {
      var state = new State(options);
      state.generator[node.type](node, state);
      return state.output;
    }
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/dump.js
var require_dump = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/dump.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var astring$1 = require_astring();
    function _interopNamespace(e3) {
      if (e3 && e3.__esModule)
        return e3;
      var n3 = /* @__PURE__ */ Object.create(null);
      if (e3) {
        Object.keys(e3).forEach(function(k2) {
          if (k2 !== "default") {
            var d2 = Object.getOwnPropertyDescriptor(e3, k2);
            Object.defineProperty(n3, k2, d2.get ? d2 : {
              enumerable: true,
              get: function() {
                return e3[k2];
              }
            });
          }
        });
      }
      n3["default"] = e3;
      return Object.freeze(n3);
    }
    var astring__namespace = /* @__PURE__ */ _interopNamespace(astring$1);
    var customGenerator = {
      ...astring__namespace.baseGenerator,
      BooleanLiteral(node, state) {
        state.write(`${node.value}`, node);
      },
      NullLiteral(node, state) {
        state.write("null", node);
      },
      NumericLiteral(node, state) {
        state.write(node.value, node);
      },
      ObjectMethod(node, state) {
        const {
          key,
          type,
          ...value
        } = node;
        return this.ObjectProperty({
          key: node.key,
          value: {
            type: "FunctionExpression",
            ...value
          }
        }, state);
      },
      ObjectProperty(node, state) {
        return this.Property({
          ...node,
          kind: "init"
        }, state);
      },
      RegExpLiteral(node, state) {
        state.write(`/${node.pattern}/${node.flags}`, node);
      },
      StringLiteral(node, state) {
        state.write(JSON.stringify(node.value), node);
      }
    };
    function astring(tree) {
      return astring__namespace.generate(tree, {
        generator: customGenerator
      });
    }
    exports["default"] = astring;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/fallback-expressions.js
var require_fallback_expressions = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/fallback-expressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var scope = require_scope();
    function generateFallbackExpressions(fallback, expressions) {
      const path2 = builders.identifier("path");
      return builders.forOfStatement(builders.variableDeclaration("const", [builders.variableDeclarator(path2)]), builders.arrayExpression(expressions.map(builders.stringLiteral)), builders.blockStatement([builders.callExpression(fallback, [builders.identifier("input"), path2, builders.memberExpression(scope["default"].callbacks, path2, true)])]));
    }
    exports["default"] = generateFallbackExpressions;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/codegen-functions/is-object.js
var require_is_object = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/codegen-functions/is-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObject4(maybeObj) {
      return typeof maybeObj === "object" && maybeObj !== null;
    }
    exports["default"] = isObject4;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/errors/aggregate-error.js
var require_aggregate_error = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/errors/aggregate-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isObject4 = require_is_object();
    var _globalThis$Aggregate;
    function isIterable(value) {
      return isObject4["default"](value) && typeof value[Symbol.iterator] === "function";
    }
    var AggregateError2 = (_globalThis$Aggregate = globalThis.AggregateError) !== null && _globalThis$Aggregate !== void 0 ? _globalThis$Aggregate : class AggregateError extends Error {
      constructor(errors, message = "") {
        super(message);
        if (!Array.isArray(errors) && !isIterable(errors)) {
          throw new TypeError(`${errors} is not an iterable`);
        }
        this.errors = [...errors];
      }
    };
    exports["default"] = AggregateError2;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/templates/build-json.js
var require_build_json = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/templates/build-json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    function buildJson(input) {
      switch (typeof input) {
        case "boolean":
          return builders.booleanLiteral(input);
        case "string":
          return builders.stringLiteral(input);
        case "number":
          return builders.numericLiteral(input);
        case "object":
          if (input === null) {
            return builders.nullLiteral();
          }
          if (Array.isArray(input)) {
            return builders.arrayExpression(input.map(buildJson));
          }
          return builders.objectExpression(Object.keys(input).map((key) => builders.objectProperty(builders.stringLiteral(key), buildJson(input[key]))));
      }
    }
    exports["default"] = buildJson;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/tree/traversal-zones.js
var require_traversal_zones = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/tree/traversal-zones.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
    var isObject4 = require_is_object();
    require_aggregate_error();
    var builders = require_builders();
    var buildJson = require_build_json();
    var _isDestroyed = /* @__PURE__ */ new WeakMap();
    var _zones = /* @__PURE__ */ new WeakMap();
    var TraversalZones = class {
      constructor() {
        _isDestroyed.set(this, {
          writable: true,
          value: false
        });
        _zones.set(this, {
          writable: true,
          value: []
        });
      }
      get root() {
        if (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _isDestroyed) || _rollupPluginBabelHelpers.classPrivateFieldGet(this, _zones).length === 0) {
          return null;
        }
        const zonesIdentifier = builders.identifier("zones");
        return builders.variableDeclaration("const", [builders.variableDeclarator(zonesIdentifier, buildJson["default"](mergeZones(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _zones))))]);
      }
      destroy() {
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _isDestroyed, true);
      }
      attach(zone) {
        _rollupPluginBabelHelpers.classPrivateFieldGet(this, _zones).push(zone);
      }
      create() {
        if (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _isDestroyed)) {
          return null;
        }
        return new Zone(this);
      }
    };
    var _zones2 = /* @__PURE__ */ new WeakMap();
    var _localZones = /* @__PURE__ */ new WeakMap();
    var _relationships = /* @__PURE__ */ new WeakMap();
    var Zone = class {
      constructor(zones) {
        _zones2.set(this, {
          writable: true,
          value: void 0
        });
        _localZones.set(this, {
          writable: true,
          value: void 0
        });
        _relationships.set(this, {
          writable: true,
          value: void 0
        });
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _zones2, zones);
        this.root = {};
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _localZones, [this.root]);
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _relationships, /* @__PURE__ */ new Map());
      }
      attach() {
        _rollupPluginBabelHelpers.classPrivateFieldGet(this, _zones2).attach(this.root);
        _rollupPluginBabelHelpers.classPrivateFieldGet(this, _relationships).clear();
      }
      expand(property) {
        let i3 = 0;
        for (const value of _rollupPluginBabelHelpers.classPrivateFieldGet(this, _localZones)) {
          if (value === null)
            continue;
          if (property === "**") {
            const parent = _rollupPluginBabelHelpers.classPrivateFieldGet(this, _relationships).get(value);
            if (parent !== void 0 && "*" in parent) {
              delete parent["*"];
              parent["**"] = null;
              continue;
            }
            value[property] = null;
          } else {
            value[property] = {};
            _rollupPluginBabelHelpers.classPrivateFieldGet(this, _relationships).set(value[property], value);
          }
          _rollupPluginBabelHelpers.classPrivateFieldGet(this, _localZones)[i3++] = value[property];
        }
        return this;
      }
      expandMultiple(properties) {
        const root = _rollupPluginBabelHelpers.classPrivateFieldGet(this, _localZones)[0];
        if (root === null) {
          return this;
        }
        let i3 = 0;
        for (const property of properties) {
          root[property] = property === "**" ? null : {};
          if (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _localZones).length < i3) {
            _rollupPluginBabelHelpers.classPrivateFieldGet(this, _localZones).push(root[property]);
          } else {
            _rollupPluginBabelHelpers.classPrivateFieldGet(this, _localZones)[i3++] = root[property];
          }
        }
        return this;
      }
      resize() {
        return this.expand("*");
      }
      allIn() {
        return this.expand("**");
      }
    };
    function pullAll(target) {
      return Object.keys(target).reduce((obj, key) => Object.assign(obj, target[key]), {});
    }
    function _mergeZones(target, source) {
      if ("*" in source) {
        const pulled = pullAll(target);
        _mergeZones(pulled, pullAll(source));
        target["*"] = "*" in pulled ? {
          "*": pulled["*"]
        } : pulled;
      } else {
        for (const key of Object.keys(source)) {
          if (!(key in target)) {
            target[key] = source[key];
          } else if (isObject4["default"](source[key])) {
            _mergeZones(target[key], source[key]);
          }
        }
      }
    }
    function mergeZones(zones) {
      const target = zones[0];
      for (let i3 = 1; i3 < zones.length; i3++) {
        _mergeZones(target, zones[i3]);
      }
      return target;
    }
    exports["default"] = TraversalZones;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/tree/tree.js
var require_tree = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/tree/tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
    var jsep = require_jsep();
    var builders = require_builders();
    var dump = require_dump();
    var fallbackExpressions = require_fallback_expressions();
    var fnParams = require_fn_params();
    var internalScope = require_internal_scope();
    var scope = require_scope();
    var treeMethodCall = require_tree_method_call();
    var traversalZones = require_traversal_zones();
    var params = [builders.identifier("input"), builders.identifier("callbacks")];
    var NEW_SCOPE_VARIABLE_DECLARATION = builders.variableDeclaration("const", [builders.variableDeclarator(scope["default"]._, builders.newExpression(builders.identifier("Scope"), params))]);
    var _tree = /* @__PURE__ */ new WeakMap();
    var _shorthands = /* @__PURE__ */ new WeakMap();
    var _runtimeDependencies = /* @__PURE__ */ new WeakMap();
    var _program = /* @__PURE__ */ new WeakMap();
    var _body = /* @__PURE__ */ new WeakMap();
    var _traverse = /* @__PURE__ */ new WeakMap();
    var _availableShorthands = /* @__PURE__ */ new WeakMap();
    var ESTree = class {
      constructor({
        customShorthands,
        format: format2,
        npmProvider
      }) {
        _tree.set(this, {
          writable: true,
          value: builders.objectExpression([])
        });
        _shorthands.set(this, {
          writable: true,
          value: builders.objectExpression([])
        });
        _runtimeDependencies.set(this, {
          writable: true,
          value: /* @__PURE__ */ new Set(["Scope"])
        });
        _program.set(this, {
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        _body.set(this, {
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        _traverse.set(this, {
          writable: true,
          value: /* @__PURE__ */ new Set()
        });
        _availableShorthands.set(this, {
          writable: true,
          value: void 0
        });
        this.format = format2;
        this.npmProvider = npmProvider;
        this.ctx = null;
        this.traversalZones = new traversalZones["default"]();
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _availableShorthands, customShorthands);
      }
      addRuntimeDependency(specifier) {
        if (!_rollupPluginBabelHelpers.classPrivateFieldGet(this, _runtimeDependencies).has(specifier)) {
          _rollupPluginBabelHelpers.classPrivateFieldGet(this, _runtimeDependencies).add(specifier);
        }
      }
      attachFallbackExpressions(fallback, expressions) {
        this.push(fallbackExpressions["default"](fallback.attach(this), expressions), "body");
      }
      attachCustomShorthand(name) {
        if (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _availableShorthands) === null || !(name in _rollupPluginBabelHelpers.classPrivateFieldGet(this, _availableShorthands))) {
          throw new ReferenceError(`Shorthand '${name}' is not defined`);
        }
        _rollupPluginBabelHelpers.classPrivateFieldGet(this, _shorthands).properties.push(builders.objectMethod("method", builders.identifier(name), fnParams["default"], builders.blockStatement([builders.returnStatement(jsep["default"](_rollupPluginBabelHelpers.classPrivateFieldGet(this, _availableShorthands)[name]))])));
      }
      getMethodByHash(hash) {
        return _rollupPluginBabelHelpers.classPrivateFieldGet(this, _tree).properties.find((prop) => prop.key.value === hash);
      }
      push(node, placement) {
        switch (placement) {
          case "tree-method":
            _rollupPluginBabelHelpers.classPrivateFieldGet(this, _tree).properties.push(builders.objectMethod("method", builders.stringLiteral(this.ctx.id), fnParams["default"], node));
            break;
          case "program":
            if (!_rollupPluginBabelHelpers.classPrivateFieldGet(this, _program).has(node)) {
              _rollupPluginBabelHelpers.classPrivateFieldGet(this, _program).add(node);
            }
            break;
          case "body":
            if (!_rollupPluginBabelHelpers.classPrivateFieldGet(this, _body).has(node)) {
              _rollupPluginBabelHelpers.classPrivateFieldGet(this, _body).add(node);
            }
            break;
          case "traverse":
            _rollupPluginBabelHelpers.classPrivateFieldGet(this, _traverse).add(treeMethodCall["default"](node.value));
            break;
        }
      }
      pushAll(items) {
        for (const item of items) {
          this.push(...item);
        }
      }
      toString() {
        var _this$npmProvider;
        const traversalZones2 = this.traversalZones.root;
        return dump["default"](builders.program([builders.importDeclaration([..._rollupPluginBabelHelpers.classPrivateFieldGet(this, _runtimeDependencies)].map((dep) => builders.importSpecifier(builders.identifier(dep), builders.identifier(dep))), builders.stringLiteral(`${(_this$npmProvider = this.npmProvider) !== null && _this$npmProvider !== void 0 ? _this$npmProvider : ""}nimma/legacy/runtime`)), ..._rollupPluginBabelHelpers.classPrivateFieldGet(this, _program), traversalZones2, _rollupPluginBabelHelpers.classPrivateFieldGet(this, _tree).properties.length === 0 ? null : builders.variableDeclaration("const", [builders.variableDeclarator(internalScope["default"].tree, _rollupPluginBabelHelpers.classPrivateFieldGet(this, _tree))]), _rollupPluginBabelHelpers.classPrivateFieldGet(this, _shorthands).properties.length === 0 ? null : builders.variableDeclaration("const", [builders.variableDeclarator(internalScope["default"].shorthands, _rollupPluginBabelHelpers.classPrivateFieldGet(this, _shorthands))]), builders.exportDefaultDeclaration(builders.functionDeclaration(null, params, builders.blockStatement([NEW_SCOPE_VARIABLE_DECLARATION, builders.tryStatement(builders.blockStatement([..._rollupPluginBabelHelpers.classPrivateFieldGet(this, _body), _rollupPluginBabelHelpers.classPrivateFieldGet(this, _traverse).size === 0 ? null : builders.expressionStatement(builders.callExpression(scope["default"].traverse, [builders.arrowFunctionExpression([], builders.blockStatement(Array.from(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _traverse)))), traversalZones2 === null ? builders.nullLiteral() : traversalZones2.declarations[0].id]))].filter(Boolean)), null, builders.blockStatement([builders.expressionStatement(builders.callExpression(scope["default"].destroy, []))]))].filter(Boolean))))].filter(Boolean)));
      }
    };
    exports["default"] = ESTree;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/codegen/baseline/index.js
var require_baseline = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/codegen/baseline/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders();
    var index3 = require_fast_paths();
    var guards = require_guards();
    var iterator = require_iterator();
    var index$1 = require_optimizer();
    var emitCall = require_emit_call();
    var fnParams = require_fn_params();
    var internalScope = require_internal_scope();
    var scope = require_scope();
    var tree = require_tree();
    var generators = require_generators();
    var POS_VARIABLE_DECLARATION = builders.variableDeclaration("let", [builders.variableDeclarator(internalScope["default"].pos, builders.numericLiteral(0))]);
    function baseline(jsonPaths, opts) {
      const tree$1 = new tree["default"](opts);
      const hashes = /* @__PURE__ */ new Map();
      const callbacks = /* @__PURE__ */ new Map();
      traverse:
        for (const [id, nodes] of jsonPaths) {
          const iterator$1 = new iterator["default"](nodes);
          if (iterator$1.length === -1) {
            continue;
          }
          const hash = JSON.stringify(iterator$1.nodes);
          const existingHash = hashes.get(hash);
          if (existingHash !== void 0) {
            var _callbacks$get$push, _callbacks$get;
            void ((_callbacks$get$push = (_callbacks$get = callbacks.get(existingHash)) === null || _callbacks$get === void 0 ? void 0 : _callbacks$get.push(id)) !== null && _callbacks$get$push !== void 0 ? _callbacks$get$push : callbacks.set(existingHash, [id]));
            const method = tree$1.getMethodByHash(existingHash);
            let body = method.body.body;
            if (iterator$1.feedback.bailed) {
              body = body[0].expression.arguments[1].body.body;
            }
            body.push(emitCall["default"](id, iterator$1.modifiers));
            continue;
          } else {
            hashes.set(hash, id);
          }
          if (iterator$1.feedback.bailed || nodes.length > 0 && guards.isDeep(nodes[0])) {
            tree$1.traversalZones.destroy();
          }
          const ctx = {
            id,
            iterator: iterator$1
          };
          tree$1.ctx = ctx;
          for (const fastPath of index3["default"]) {
            if (fastPath(nodes, tree$1, ctx)) {
              continue traverse;
            }
          }
          const branch = iterator$1.feedback.bailed ? [] : [builders.ifStatement(builders.binaryExpression(iterator$1.feedback.fixed ? "!==" : "<", scope["default"].depth, builders.numericLiteral(iterator$1.length - 1)), builders.returnStatement())].concat(iterator$1.feedback.fixed ? [] : POS_VARIABLE_DECLARATION);
          const zone = iterator$1.feedback.bailed ? null : tree$1.traversalZones.create();
          const inverseAt = iterator$1.feedback.inverseAt;
          for (const node of iterator$1) {
            if (guards.isDeep(node) || inverseAt === iterator$1.state.absolutePos) {
              zone === null || zone === void 0 ? void 0 : zone.allIn();
            }
            let treeNode;
            switch (node.type) {
              case "MemberExpression":
                treeNode = generators.generateMemberExpression(iterator$1, node);
                zone === null || zone === void 0 ? void 0 : zone.expand(node.value);
                break;
              case "MultipleMemberExpression":
                treeNode = generators.generateMultipleMemberExpression(iterator$1, node);
                zone === null || zone === void 0 ? void 0 : zone.expandMultiple(node.value);
                break;
              case "SliceExpression":
                treeNode = generators.generateSliceExpression(iterator$1, node, tree$1);
                zone === null || zone === void 0 ? void 0 : zone.resize();
                break;
              case "ScriptFilterExpression":
                treeNode = generators.generateFilterScriptExpression(iterator$1, node, tree$1);
                zone === null || zone === void 0 ? void 0 : zone.resize();
                break;
              case "WildcardExpression":
                treeNode = generators.generateWildcardExpression(iterator$1);
                zone === null || zone === void 0 ? void 0 : zone.resize();
                if (treeNode === null) {
                  continue;
                }
                break;
            }
            if (iterator$1.feedback.bailed) {
              branch.push(builders.objectExpression([builders.objectProperty(builders.identifier("fn"), builders.arrowFunctionExpression([scope["default"]._], treeNode)), builders.objectProperty(builders.identifier("deep"), builders.booleanLiteral(node.deep))]));
            } else {
              branch.push(builders.ifStatement(treeNode, builders.returnStatement()));
            }
          }
          if (!iterator$1.feedback.fixed && !iterator$1.feedback.bailed && !iterator$1.state.inverted) {
            branch.push(builders.ifStatement(builders.binaryExpression("!==", scope["default"].depth, iterator$1.state.pos === 0 ? internalScope["default"].pos : builders.binaryExpression("+", internalScope["default"].pos, builders.numericLiteral(iterator$1.state.pos))), builders.returnStatement()));
          }
          const placement = iterator$1.feedback.bailed ? "body" : "traverse";
          if (iterator$1.feedback.bailed) {
            branch.splice(0, branch.length, builders.expressionStatement(builders.callExpression(scope["default"].bail, [builders.stringLiteral(id), builders.arrowFunctionExpression([scope["default"]._], builders.blockStatement([builders.expressionStatement(emitCall["default"](ctx.id, iterator$1.modifiers).expression)])), builders.arrayExpression([...branch])])));
          } else {
            branch.push(emitCall["default"](ctx.id, iterator$1.modifiers));
          }
          if (placement === "body") {
            tree$1.push(builders.expressionStatement(builders.callExpression(builders.memberExpression(internalScope["default"].tree, builders.stringLiteral(id), true), fnParams["default"])), placement);
          } else {
            tree$1.push(builders.stringLiteral(id), placement);
          }
          index$1["default"](branch, iterator$1);
          tree$1.push(builders.blockStatement(branch), "tree-method");
          zone === null || zone === void 0 ? void 0 : zone.attach();
        }
      return tree$1;
    }
    exports["default"] = baseline;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/codegen-functions/get.js
var require_get = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/codegen-functions/get.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isObject4 = require_is_object();
    function get4(input, path2) {
      if (path2.length === 0 || !isObject4["default"](input))
        return input;
      let value = input;
      for (const segment of path2.slice(0, path2.length - 1)) {
        value = value[segment];
        if (!isObject4["default"](value))
          return;
      }
      return value[path2[path2.length - 1]];
    }
    exports["default"] = get4;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/codegen-functions/in-bounds.js
var require_in_bounds = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/codegen-functions/in-bounds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function inBounds(value, pos, start, end, step) {
      const actualStart = start < 0 ? Math.max(0, start + value.length) : Math.min(value.length, start);
      const actualEnd = end < 0 ? Math.max(0, end + value.length) : Math.min(value.length, end);
      return pos >= actualStart && pos < actualEnd && (step === 1 || actualEnd - Math.abs(step) > 0 && (pos + start) % step === 0);
    }
    exports["default"] = inBounds;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/errors/cause-error.js
var require_cause_error = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/errors/cause-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CauseError = class extends Error {
      constructor(message, extra) {
        super(message);
        if (extra !== void 0 && "cause" in extra) {
          this.cause = extra.cause;
        }
      }
    };
    exports["default"] = CauseError;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/errors/runtime-error.js
var require_runtime_error = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/errors/runtime-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var causeError = require_cause_error();
    var RuntimeError = class extends causeError["default"] {
    };
    exports["default"] = RuntimeError;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/proxy-callbacks.js
var require_proxy_callbacks = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/proxy-callbacks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var runtimeError = require_runtime_error();
    function printPrimitive(value) {
      if (typeof value === "string" || typeof value === "number") {
        return JSON.stringify(value);
      }
      return "unknown";
    }
    function printError(e3) {
      if (e3 instanceof Error) {
        return `${e3.constructor.name}(${printPrimitive(e3.message)})`;
      }
      return printPrimitive(e3);
    }
    function proxyCallbacks(callbacks, errors) {
      const _callbacks = {};
      for (const key of Object.keys(callbacks)) {
        const fn = callbacks[key];
        _callbacks[key] = (...args) => {
          try {
            fn(...args);
          } catch (e3) {
            const message = `${fn.name || key} threw: ${printError(e3)}`;
            errors.push(new runtimeError["default"](message, {
              cause: e3
            }));
          }
        };
      }
      return _callbacks;
    }
    exports["default"] = proxyCallbacks;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/sandbox.js
var require_sandbox2 = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/sandbox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
    var isObject4 = require_is_object();
    function printSegment(path2, segment) {
      return path2 + `[${typeof segment === "string" ? `'${segment}'` : segment}]`;
    }
    function dumpPath(path2) {
      return `$${path2.reduce(printSegment, "")}`;
    }
    var _history = /* @__PURE__ */ new WeakMap();
    var _path = /* @__PURE__ */ new WeakMap();
    var _value = /* @__PURE__ */ new WeakMap();
    var _parent = /* @__PURE__ */ new WeakMap();
    var Sandbox = class _Sandbox {
      constructor(path2, root, history = null) {
        _parent.set(this, {
          get: _get_parent,
          set: void 0
        });
        _history.set(this, {
          writable: true,
          value: void 0
        });
        _path.set(this, {
          writable: true,
          value: void 0
        });
        _value.set(this, {
          writable: true,
          value: void 0
        });
        this.root = root;
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _path, path2);
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _history, history !== null && history !== void 0 ? history : [[0, root]]);
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _value, void 0);
      }
      get path() {
        return dumpPath(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _path));
      }
      get depth() {
        return _rollupPluginBabelHelpers.classPrivateFieldGet(this, _path).length - 1;
      }
      get value() {
        var _classPrivateFieldGet2;
        if (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _value) !== void 0) {
          return _rollupPluginBabelHelpers.classPrivateFieldGet(this, _value);
        }
        return (_classPrivateFieldGet2 = _rollupPluginBabelHelpers.classPrivateFieldGet(this, _value)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _rollupPluginBabelHelpers.classPrivateFieldSet(this, _value, _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history)[_rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).length - 1][1]);
      }
      get property() {
        return unwrapOrNull(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _path), this.depth);
      }
      get parentValue() {
        var _classPrivateFieldGet3;
        return (_classPrivateFieldGet3 = _rollupPluginBabelHelpers.classPrivateFieldGet(this, _parent)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3[1];
      }
      get parentProperty() {
        var _classPrivateFieldGet4;
        return _rollupPluginBabelHelpers.classPrivateFieldGet(this, _path)[(_classPrivateFieldGet4 = _rollupPluginBabelHelpers.classPrivateFieldGet(this, _parent)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4[0]];
      }
      destroy() {
        _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).length = 0;
      }
      push() {
        const root = this.property !== null && isObject4["default"](this.value) ? this.value[this.property] : null;
        _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).push([_rollupPluginBabelHelpers.classPrivateFieldGet(this, _path).length, root]);
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _value, root);
        return this;
      }
      pop() {
        const length = Math.max(0, _rollupPluginBabelHelpers.classPrivateFieldGet(this, _path).length + 1);
        while (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).length > length) {
          _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).pop();
        }
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _value, void 0);
        return this;
      }
      at(pos) {
        if (Math.abs(pos) > _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).length) {
          return null;
        }
        const actualPos = (pos < 0 ? _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).length : 0) + pos;
        const history = _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).slice(0, actualPos + 1);
        return new _Sandbox(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _path).slice(0, history[history.length - 1][0]), history[history.length - 1][1], history);
      }
    };
    function _get_parent() {
      if (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).length < 3) {
        return void 0;
      }
      return _rollupPluginBabelHelpers.classPrivateFieldGet(this, _history)[_rollupPluginBabelHelpers.classPrivateFieldGet(this, _history).length - 3];
    }
    function unwrapOrNull(collection, pos) {
      return pos >= 0 && collection.length > pos ? collection[pos] : null;
    }
    exports.Sandbox = Sandbox;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/traverse.js
var require_traverse = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isObject4 = require_is_object();
    function _traverseBody(key, curObj, scope, cb, deps) {
      const value = curObj[key];
      const pos = scope.enter(key);
      const matched = deps !== null && deps.length > 0 && !deps[0].fn(scope);
      if (deps === null || deps.length === 1 && matched) {
        cb(scope);
      }
      if (!isObject4["default"](value))
        ;
      else if (deps === null) {
        _traverse(value, scope, cb, deps);
      } else if (deps.length > 0) {
        if (matched) {
          _traverse(value, scope, cb, deps.slice(1));
        }
        if (deps[0].deep) {
          scope.exit(pos);
          scope.enter(key);
          _traverse(value, scope, cb, deps);
        }
      }
      scope.exit(pos);
    }
    function _traverse(curObj, scope, cb, deps) {
      if (Array.isArray(curObj)) {
        for (let i3 = 0; i3 < curObj.length; i3++) {
          _traverseBody(i3, curObj, scope, cb, deps);
        }
      } else {
        for (const key of Object.keys(curObj)) {
          _traverseBody(key, curObj, scope, cb, deps);
        }
      }
    }
    function traverse(cb) {
      _traverse(this.root, this, cb, null);
    }
    function bailedTraverse(cb, deps) {
      _traverse(this.value, this, cb, deps);
    }
    function zonedTraverse(cb, zones) {
      if (isSaneObject(this.root)) {
        zonesRegistry.set(this.root, zones);
        _traverse(new Proxy(this.root, traps2), this, cb, null);
      } else {
        _traverse(this.root, this, cb, null);
      }
    }
    var zonesRegistry = /* @__PURE__ */ new WeakMap();
    var traps2 = {
      get(target, prop) {
        const value = target[prop];
        if (Array.isArray(target)) {
          if (prop === "length") {
            return target.length;
          }
          const stored2 = zonesRegistry.get(target);
          if (prop in stored2 && isObject4["default"](value)) {
            zonesRegistry.set(value, stored2[prop]);
          }
          return value;
        }
        if (!isObject4["default"](value)) {
          return value;
        }
        if (!isSaneObject(value)) {
          return value;
        }
        if (Array.isArray(value)) {
          for (const item of value) {
            if (isObject4["default"](item)) {
              zonesRegistry.set(item, zonesRegistry.get(value));
            }
          }
        }
        const stored = zonesRegistry.get(value);
        return "**" in stored ? value : new Proxy(value, traps2);
      },
      ownKeys(target) {
        const stored = zonesRegistry.get(target);
        zonesRegistry.delete(target);
        if ("*" in stored) {
          const actualKeys2 = Object.keys(target);
          for (const key of actualKeys2) {
            const value = target[key];
            if (isObject4["default"](value)) {
              zonesRegistry.set(value, stored["*"]);
            }
          }
          return actualKeys2;
        }
        const actualKeys = Object.keys(stored);
        for (let i3 = 0; i3 < actualKeys.length; i3++) {
          const key = actualKeys[i3];
          if (!Object.hasOwnProperty.call(target, key)) {
            actualKeys.splice(i3, 1);
            i3--;
            continue;
          }
          const value = target[key];
          if (isObject4["default"](value)) {
            zonesRegistry.set(value, stored[key]);
          }
        }
        return actualKeys;
      }
    };
    function isSaneObject(object) {
      return !(Object.isFrozen(object) || Object.isSealed(object) || !Object.isExtensible(object));
    }
    exports.bailedTraverse = bailedTraverse;
    exports.traverse = traverse;
    exports.zonedTraverse = zonedTraverse;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/scope.js
var require_scope2 = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
    var aggregateError = require_aggregate_error();
    var proxyCallbacks = require_proxy_callbacks();
    var sandbox = require_sandbox2();
    var traverse = require_traverse();
    var _parent = /* @__PURE__ */ new WeakMap();
    var _output = /* @__PURE__ */ new WeakMap();
    var Scope = class _Scope {
      constructor(root, callbacks, parent = null) {
        _parent.set(this, {
          writable: true,
          value: void 0
        });
        _output.set(this, {
          writable: true,
          value: void 0
        });
        this.root = root;
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _parent, parent);
        this.path = [];
        this.errors = [];
        this.sandbox = new sandbox.Sandbox(this.path, root, null);
        this.callbacks = proxyCallbacks["default"](callbacks, this.errors);
        const self2 = this;
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _output, {
          path: this.path,
          get value() {
            return self2.value;
          }
        });
      }
      get depth() {
        return this.path.length - 1;
      }
      get property() {
        return this.sandbox.property;
      }
      get value() {
        return this.sandbox.value;
      }
      enter(key) {
        this.path.push(key);
        this.sandbox = this.sandbox.push();
        return this.path.length;
      }
      exit(depth) {
        const length = Math.max(0, depth - 1);
        while (this.path.length > length) {
          this.path.pop();
        }
        this.sandbox = this.sandbox.pop();
        return this.path.length;
      }
      fork(path2) {
        const newScope = new _Scope(this.root, this.callbacks, this);
        for (const segment of path2) {
          newScope.enter(segment);
          if (newScope.value === void 0) {
            return null;
          }
        }
        return newScope;
      }
      traverse(fn, zones) {
        if (zones !== null) {
          traverse.zonedTraverse.call(this, fn, zones);
        } else {
          traverse.traverse.call(this, fn);
        }
      }
      bail(id, fn, deps) {
        const scope = this.fork(this.path);
        traverse.bailedTraverse.call(scope, fn, deps);
      }
      emit(id, pos, withKeys) {
        var _this$sandbox$at;
        const fn = this.callbacks[id];
        if (pos === 0 && !withKeys) {
          return void fn(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _output));
        }
        if (pos !== 0 && pos > this.depth + 1) {
          return;
        }
        const output = pos === 0 ? _rollupPluginBabelHelpers.classPrivateFieldGet(this, _output) : {
          path: _rollupPluginBabelHelpers.classPrivateFieldGet(this, _output).path.slice(0, Math.max(0, _rollupPluginBabelHelpers.classPrivateFieldGet(this, _output).path.length - pos)),
          value: ((_this$sandbox$at = this.sandbox.at(-pos - 1)) !== null && _this$sandbox$at !== void 0 ? _this$sandbox$at : this.sandbox.at(0)).value
        };
        if (!withKeys) {
          fn(output);
        } else {
          fn({
            path: output.path,
            value: output.path.length === 0 ? void 0 : output.path[output.path.length - 1]
          });
        }
      }
      destroy() {
        this.path.length = 0;
        this.sandbox.destroy();
        this.sandbox = null;
        if (this.errors.length > 0) {
          throw new aggregateError["default"](this.errors, "Error running Nimma");
        }
      }
    };
    exports["default"] = Scope;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/index.js
var require_runtime = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var get4 = require_get();
    var inBounds = require_in_bounds();
    var isObject4 = require_is_object();
    var scope = require_scope2();
    exports.get = get4["default"];
    exports.inBounds = inBounds["default"];
    exports.isObject = isObject4["default"];
    exports.Scope = scope["default"];
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/core/utils/determine-format.js
var require_determine_format = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/core/utils/determine-format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getOutputFormat() {
      try {
        Function("a", "a?.b")({});
        return "ES2021";
      } catch {
        return "ES2018";
      }
    }
    exports["default"] = getOutputFormat;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/runtime/errors/parser-error.js
var require_parser_error = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/runtime/errors/parser-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var causeError = require_cause_error();
    var ParserError = class extends causeError["default"] {
      constructor(message, expression, extra) {
        super(message, extra);
        this.input = expression;
      }
    };
    exports["default"] = ParserError;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/parser/parser.js
var require_parser = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/parser/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function peg$subclass(child, parent) {
      function C2() {
        this.constructor = child;
      }
      C2.prototype = parent.prototype;
      child.prototype = new C2();
    }
    function peg$SyntaxError(message, expected, found, location2) {
      var self2 = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self2, peg$SyntaxError.prototype);
      }
      self2.expected = expected;
      self2.found = found;
      self2.location = location2;
      self2.name = "SyntaxError";
      return self2;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k2;
        for (k2 = 0; k2 < sources.length; k2++) {
          if (sources[k2].source === this.location.source) {
            src = sources[k2].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s2 = this.location.start;
        var loc = this.location.source + ":" + s2.line + ":" + s2.column;
        if (src) {
          var e3 = this.location.end;
          var filler = peg$padEnd("", s2.line.toString().length);
          var line = src[s2.line - 1];
          var last = s2.line === e3.line ? e3.column : line.length + 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + s2.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s2.column - 1) + peg$padEnd("", last - s2.column, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s2) {
        return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i3, j2;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i3 = 1, j2 = 1; i3 < descriptions.length; i3++) {
            if (descriptions[i3 - 1] !== descriptions[i3]) {
              descriptions[j2] = descriptions[i3];
              j2++;
            }
          }
          descriptions.length = j2;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = {
        JSONPath: peg$parseJSONPath
      };
      var peg$startRuleFunction = peg$parseJSONPath;
      var peg$c0 = "$";
      var peg$c1 = "[";
      var peg$c2 = "]";
      var peg$c4 = "..";
      var peg$c5 = "(";
      var peg$c6 = ")";
      var peg$c7 = "?(";
      var peg$c8 = ":";
      var peg$c9 = "@";
      var peg$c10 = "()";
      var peg$c11 = "~";
      var peg$c12 = "^";
      var peg$c13 = ".";
      var peg$c14 = '"';
      var peg$c15 = "'";
      var peg$c16 = "-";
      var peg$c17 = "*";
      var peg$c18 = ".length";
      var peg$r0 = /^[a-z]/;
      var peg$r1 = /^[@[]/;
      var peg$r2 = /^[$_\-]/;
      var peg$r3 = /^[^"]/;
      var peg$r4 = /^[^']/;
      var peg$r5 = /^[A-Za-z]/;
      var peg$r6 = /^[0-9]/;
      var peg$r7 = /^[ \t]/;
      var peg$r8 = /^["]/;
      var peg$r9 = /^[']/;
      var peg$r10 = /^[ $@.,_=<>!|&+~%\^*\/;\-[\]]/;
      var peg$e0 = peg$literalExpectation("$", false);
      var peg$e1 = peg$literalExpectation("[", false);
      var peg$e2 = peg$literalExpectation("]", false);
      var peg$e3 = peg$literalExpectation(",", false);
      var peg$e4 = peg$literalExpectation("..", false);
      var peg$e5 = peg$literalExpectation("(", false);
      var peg$e6 = peg$literalExpectation(")", false);
      var peg$e7 = peg$literalExpectation("?(", false);
      var peg$e8 = peg$literalExpectation(":", false);
      var peg$e9 = peg$literalExpectation("@", false);
      var peg$e10 = peg$classExpectation([["a", "z"]], false, false);
      var peg$e11 = peg$literalExpectation("()", false);
      var peg$e12 = peg$literalExpectation("~", false);
      var peg$e13 = peg$literalExpectation("^", false);
      var peg$e14 = peg$literalExpectation(".", false);
      var peg$e15 = peg$classExpectation(["@", "["], false, false);
      var peg$e16 = peg$classExpectation(["$", "_", "-"], false, false);
      var peg$e17 = peg$literalExpectation('"', false);
      var peg$e18 = peg$classExpectation(['"'], true, false);
      var peg$e19 = peg$literalExpectation("'", false);
      var peg$e20 = peg$classExpectation(["'"], true, false);
      var peg$e21 = peg$literalExpectation("-", false);
      var peg$e22 = peg$literalExpectation("*", false);
      var peg$e23 = peg$classExpectation([["A", "Z"], ["a", "z"]], false, false);
      var peg$e24 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e25 = peg$classExpectation([" ", "	"], false, false);
      var peg$e26 = peg$classExpectation(['"'], false, false);
      var peg$e27 = peg$classExpectation(["'"], false, false);
      var peg$e28 = peg$classExpectation([" ", "$", "@", ".", ",", "_", "=", "<", ">", "!", "|", "&", "+", "~", "%", "^", "*", "/", ";", "-", "[", "]"], false, false);
      var peg$e29 = peg$literalExpectation(".length", false);
      var peg$f0 = function(deep, step) {
        return {
          ...step,
          deep
        };
      };
      var peg$f1 = function(nodes, modifiers) {
        return nodes.concat(Array.isArray(modifiers) ? modifiers : modifiers === null ? [] : modifiers);
      };
      var peg$f2 = function() {
        return {
          type: "WildcardExpression"
        };
      };
      var peg$f3 = function(expression) {
        return expression;
      };
      var peg$f4 = function(value) {
        return value;
      };
      var peg$f5 = function(value) {
        return {
          type: "MultipleMemberExpression",
          value: [...new Set(value)]
        };
      };
      var peg$f6 = function() {
        return /^\$\.{2}[~^]*$/.test(input);
      };
      var peg$f7 = function() {
        return {
          type: "AllParentExpression"
        };
      };
      var peg$f8 = function(value) {
        return {
          type: "MemberExpression",
          value
        };
      };
      var peg$f9 = function(value) {
        return {
          type: "ScriptFilterExpression",
          value
        };
      };
      var peg$f10 = function(value) {
        return {
          type: "SliceExpression",
          value: value.split(":").reduce((values, val, i3) => {
            if (val !== "")
              values[i3] = Number(val);
            return values;
          }, [0, Infinity, 1])
        };
      };
      var peg$f11 = function(value) {
        return {
          type: "ScriptFilterExpression",
          value
        };
      };
      var peg$f12 = function(node) {
        return node.value;
      };
      var peg$f13 = function() {
        return {
          type: "KeyExpression"
        };
      };
      var peg$f14 = function() {
        return {
          type: "ParentExpression"
        };
      };
      var peg$f15 = function() {
        return true;
      };
      var peg$f16 = function() {
        return false;
      };
      var peg$f17 = function(value) {
        return value.length > 0 && Number.isSafeInteger(Number(value)) ? Number(value) : value;
      };
      var peg$f18 = function() {
        return text().slice(1, -1);
      };
      var peg$f19 = function() {
        return Number(text());
      };
      var peg$f20 = function(value) {
        return {
          type: "SliceExpression",
          value: [-value, Infinity, 1]
        };
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{
        line: 1,
        column: 1
      }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return {
          type: "literal",
          text: text2,
          ignoreCase
        };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts,
          inverted,
          ignoreCase
        };
      }
      function peg$endExpectation() {
        return {
          type: "end"
        };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p2;
        if (details) {
          return details;
        } else {
          p2 = pos - 1;
          while (!peg$posDetailsCache[p2]) {
            p2--;
          }
          details = peg$posDetailsCache[p2];
          details = {
            line: details.line,
            column: details.column
          };
          while (p2 < pos) {
            if (input.charCodeAt(p2) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p2++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }
      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
      }
      function peg$buildStructuredError(expected, found, location2) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location2);
      }
      function peg$parseJSONPath() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseRoot();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseAllParentExpression();
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseDescendant();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseNode();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s3 = peg$f0(s4, s5);
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseAllParentExpression();
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseDescendant();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseNode();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s3 = peg$f0(s4, s5);
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
          }
          s3 = [];
          s4 = peg$parseModifier();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseModifier();
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f1(s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseRoot() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 36) {
          s0 = peg$c0;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        return s0;
      }
      function peg$parseNode() {
        var s0, s1, s2, s3, s4;
        s0 = peg$parseMemberExpression();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseWildcard();
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s2 = peg$c1;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseWildcard();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s4 = peg$c2;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f2();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c1;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseScriptExpression();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c2;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f3(s2);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c1;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseScriptFilterExpression();
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c2;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e2);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f3(s2);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseJsonPathPlusFilterFunction();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseCustomScriptFilterExpression();
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$f3(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 91) {
                    s1 = peg$c1;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e1);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$parseMemberIdentifier();
                    if (s4 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        peg$currPos++;
                      } else {
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e3);
                        }
                      }
                      peg$savedPos = s3;
                      s3 = peg$f4(s4);
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$currPos;
                      s4 = peg$parseMemberIdentifier();
                      if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          peg$currPos++;
                        } else {
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e3);
                          }
                        }
                        peg$savedPos = s3;
                        s3 = peg$f4(s4);
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s3 = peg$c2;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e2);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s0 = peg$f5(s2);
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 91) {
                      s1 = peg$c1;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e1);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parseSliceExpression();
                      if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s3 = peg$c2;
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e2);
                          }
                        }
                        if (s3 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s0 = peg$f3(s2);
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseAllParentExpression() {
        var s0, s1, s2;
        s0 = peg$currPos;
        peg$savedPos = peg$currPos;
        s1 = peg$f6();
        if (s1) {
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c4) {
            s2 = peg$c4;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e4);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseMemberExpression() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s2 = peg$c1;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseMemberIdentifier();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s4 = peg$c2;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s1;
                s1 = peg$f4(s3);
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f8(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseScriptExpression() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseEvalExpression();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s3 = peg$c6;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f4(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseScriptFilterExpression() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c7) {
          s1 = peg$c7;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseJSScript();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s3 = peg$c6;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e6);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f9(s2);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseSliceExpression() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$parseNumber();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s5 = peg$c8;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseNumber();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c8;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseNumber();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$parseNumber();
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s5 = peg$c8;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseNumber();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f10(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseJsonPathPlusFilterFunction() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s3 = peg$c9;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e10);
                }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c10) {
              s5 = peg$c10;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseCustomScriptFilterExpression() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s3 = peg$c9;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseJsonPathPlusFilterFunction();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s2 = peg$f12(s4);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f11(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseKeyExpression() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 126) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e12);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f13();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseParentExpression() {
        var s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 94) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f14();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseModifier() {
        var s0;
        s0 = peg$parseKeyExpression();
        if (s0 === peg$FAILED) {
          s0 = peg$parseParentExpression();
        }
        return s0;
      }
      function peg$parseDescendant() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c4) {
          s1 = peg$c4;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e4);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f15();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 91) {
              s3 = peg$c1;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
              peg$currPos = s2;
              s2 = void 0;
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f15();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s1 = peg$c13;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f16();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e15);
                }
              }
              peg$silentFails--;
              if (s2 !== peg$FAILED) {
                peg$currPos = s1;
                s1 = void 0;
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f16();
              }
              s0 = s1;
            }
          }
        }
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e16);
          }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseChar();
          if (s2 === peg$FAILED) {
            s2 = peg$parseDigit();
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$r2.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseChar();
              if (s2 === peg$FAILED) {
                s2 = peg$parseDigit();
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseMemberIdentifier() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f17(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c14;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e17);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = [];
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$r3.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e18);
                }
              }
            }
            s3 = input.substring(s3, peg$currPos);
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c14;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e17);
              }
            }
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c15;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e19);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              s4 = [];
              if (peg$r4.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$r4.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e20);
                  }
                }
              }
              s3 = input.substring(s3, peg$currPos);
              if (input.charCodeAt(peg$currPos) === 39) {
                s4 = peg$c15;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e19);
                }
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f18();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseNumber() {
        var s0, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          peg$currPos++;
        } else {
          if (peg$silentFails === 0) {
            peg$fail(peg$e21);
          }
        }
        s2 = [];
        s3 = peg$parseDigit();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseDigit();
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f19();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseWildcard() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 42) {
          s0 = peg$c17;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        return s0;
      }
      function peg$parseChar() {
        var s0;
        if (peg$r5.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e23);
          }
        }
        return s0;
      }
      function peg$parseDigit() {
        var s0;
        if (peg$r6.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        return s0;
      }
      function peg$parseSpace() {
        var s0;
        if (peg$r7.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e25);
          }
        }
        return s0;
      }
      function peg$parseJSScript() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseChar();
        if (s2 === peg$FAILED) {
          s2 = peg$parseDigit();
          if (s2 === peg$FAILED) {
            s2 = peg$parseSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseJSToken();
              if (s2 === peg$FAILED) {
                s2 = peg$parseJSString();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseJSScriptElementAccess();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseJSFnCall();
                  }
                }
              }
            }
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseChar();
            if (s2 === peg$FAILED) {
              s2 = peg$parseDigit();
              if (s2 === peg$FAILED) {
                s2 = peg$parseSpace();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseJSToken();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parseJSString();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parseJSScriptElementAccess();
                      if (s2 === peg$FAILED) {
                        s2 = peg$parseJSFnCall();
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseJSScriptElementAccess() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDigit();
          if (s3 === peg$FAILED) {
            s3 = peg$parseChar();
            if (s3 === peg$FAILED) {
              s3 = peg$parseJSString();
              if (s3 === peg$FAILED) {
                s3 = peg$parseJSFnCall();
              }
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseDigit();
            if (s3 === peg$FAILED) {
              s3 = peg$parseChar();
              if (s3 === peg$FAILED) {
                s3 = peg$parseJSString();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseJSFnCall();
                }
              }
            }
          }
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c2;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseJSString() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$r8.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$r3.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e18);
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e18);
              }
            }
          }
          if (peg$r8.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (peg$r9.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$r4.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e20);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$r4.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e20);
                }
              }
            }
            if (peg$r9.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e27);
              }
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseJSToken() {
        var s0;
        if (peg$r10.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        return s0;
      }
      function peg$parseJSFnCall() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseJSString();
          if (s3 === peg$FAILED) {
            s3 = peg$parseChar();
            if (s3 === peg$FAILED) {
              s3 = peg$parseDigit();
              if (s3 === peg$FAILED) {
                s3 = peg$parseJSScriptElementAccess();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseJSToken();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseSpace();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseJSFnCall();
                    }
                  }
                }
              }
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseJSString();
            if (s3 === peg$FAILED) {
              s3 = peg$parseChar();
              if (s3 === peg$FAILED) {
                s3 = peg$parseDigit();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseJSScriptElementAccess();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseJSToken();
                    if (s3 === peg$FAILED) {
                      s3 = peg$parseSpace();
                      if (s3 === peg$FAILED) {
                        s3 = peg$parseJSFnCall();
                      }
                    }
                  }
                }
              }
            }
          }
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c6;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseEvalExpression() {
        var s0, s1, s2;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseLengthEvalExpression();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseLengthEvalExpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c18) {
          s1 = peg$c18;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e29);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseSpace();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseSpace();
          }
          if (input.charCodeAt(peg$currPos) === 45) {
            s3 = peg$c16;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseSpace();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseSpace();
            }
            s5 = peg$currPos;
            s6 = [];
            s7 = peg$parseDigit();
            if (s7 !== peg$FAILED) {
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$parseDigit();
              }
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s5 = input.substring(s5, peg$currPos);
            } else {
              s5 = s6;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f20(s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }
    exports.SyntaxError = peg$SyntaxError;
    exports.parse = peg$parse;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/parser/index.js
var require_parser2 = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/parser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var parserError = require_parser_error();
    var parser = require_parser();
    var {
      parse: parse2
    } = parser;
    function parse$1(input) {
      try {
        return parse2(input);
      } catch (e3) {
        throw new parserError["default"](e3.message, input, {
          cause: e3
        });
      }
    }
    exports["default"] = parse$1;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/core/utils/parse-expressions.js
var require_parse_expressions = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/core/utils/parse-expressions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var iterator = require_iterator();
    var index3 = require_parser2();
    var aggregateError = require_aggregate_error();
    function pickException([, ex]) {
      return ex;
    }
    function pickExpression([expression]) {
      return expression;
    }
    function parseExpressions(expressions, unsafe, hasFallback) {
      const mappedExpressions = [];
      const erroredExpressions = [];
      for (const expression of new Set(expressions)) {
        try {
          const parsed = index3["default"](expression);
          if (unsafe === false && iterator["default"].analyze(parsed).bailed) {
            throw SyntaxError("Unsafe expressions are ignored, but no fallback was specified");
          }
          mappedExpressions.push([expression, parsed]);
        } catch (e3) {
          erroredExpressions.push([expression, e3]);
        }
      }
      if (!hasFallback && erroredExpressions.length > 0) {
        throw new aggregateError["default"](erroredExpressions.map(pickException), `Error parsing ${erroredExpressions.map(pickExpression).join(", ")}`);
      }
      return {
        erroredExpressions: erroredExpressions.map(pickExpression),
        mappedExpressions
      };
    }
    exports["default"] = parseExpressions;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/core/index.js
var require_core2 = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
    var index3 = require_baseline();
    var index$1 = require_runtime();
    var determineFormat = require_determine_format();
    var parseExpressions = require_parse_expressions();
    var IMPORT_DECLARATIONS_REGEXP = /import\s*({[^}]+})\s*from\s*['"][^'"]+['"];?/;
    var _fallback = /* @__PURE__ */ new WeakMap();
    var _compiledFn = /* @__PURE__ */ new WeakMap();
    var Nimma = class {
      constructor(expressions, {
        fallback = null,
        unsafe = true,
        output = "auto",
        npmProvider = null,
        customShorthands = null
      } = {}) {
        _fallback.set(this, {
          writable: true,
          value: void 0
        });
        _compiledFn.set(this, {
          writable: true,
          value: void 0
        });
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _fallback, fallback);
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _compiledFn, null);
        const {
          erroredExpressions,
          mappedExpressions
        } = parseExpressions["default"](expressions, unsafe, fallback !== null);
        this.tree = index3["default"](mappedExpressions, {
          customShorthands,
          format: output === "auto" ? determineFormat["default"]() : output,
          npmProvider
        });
        if (erroredExpressions.length > 0) {
          this.tree.attachFallbackExpressions(fallback, erroredExpressions);
        }
        this.sourceCode = String(this.tree);
      }
      query(input, callbacks) {
        if (_rollupPluginBabelHelpers.classPrivateFieldGet(this, _compiledFn) !== null) {
          _rollupPluginBabelHelpers.classPrivateFieldGet(this, _compiledFn).call(this, input, callbacks);
          return;
        }
        const globals = "__nimma_globals__";
        const code = this.sourceCode.replace("export default function", `return function`).replace(IMPORT_DECLARATIONS_REGEXP, `const $1 = ${globals};`).replace(RegExp(IMPORT_DECLARATIONS_REGEXP.source, "g"), "");
        _rollupPluginBabelHelpers.classPrivateFieldSet(this, _compiledFn, Function(globals, ..._rollupPluginBabelHelpers.classPrivateFieldGet(this, _fallback) === null ? [] : Array.from(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _fallback).runtimeDeps.keys()), code)(index$1, ..._rollupPluginBabelHelpers.classPrivateFieldGet(this, _fallback) === null ? [] : Array.from(_rollupPluginBabelHelpers.classPrivateFieldGet(this, _fallback).runtimeDeps.values())));
        _rollupPluginBabelHelpers.classPrivateFieldGet(this, _compiledFn).call(this, input, callbacks);
      }
    };
    exports["default"] = Nimma;
  }
});

// ../../node_modules/nimma/dist/legacy/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/nimma/dist/legacy/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index3 = require_core2();
    exports.default = index3["default"];
  }
});

// ../../node_modules/nimma/node_modules/jsonpath-plus/dist/index-node-cjs.cjs
var require_index_node_cjs2 = __commonJS({
  "../../node_modules/nimma/node_modules/jsonpath-plus/dist/index-node-cjs.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vm = require("vm");
    function _interopDefaultLegacy(e3) {
      return e3 && typeof e3 === "object" && "default" in e3 ? e3 : { "default": e3 };
    }
    var vm__default = /* @__PURE__ */ _interopDefaultLegacy(vm);
    var {
      hasOwnProperty: hasOwnProp
    } = Object.prototype;
    function push(arr, item) {
      arr = arr.slice();
      arr.push(item);
      return arr;
    }
    function unshift(item, arr) {
      arr = arr.slice();
      arr.unshift(item);
      return arr;
    }
    var NewError = class extends Error {
      /**
       * @param {any} value The evaluated scalar value
       */
      constructor(value) {
        super('JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)');
        this.avoidNew = true;
        this.value = value;
        this.name = "NewError";
      }
    };
    function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
      if (!(this instanceof JSONPath)) {
        try {
          return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        } catch (e3) {
          if (!e3.avoidNew) {
            throw e3;
          }
          return e3.value;
        }
      }
      if (typeof opts === "string") {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = null;
      }
      const optObj = opts && typeof opts === "object";
      opts = opts || {};
      this.json = opts.json || obj;
      this.path = opts.path || expr;
      this.resultType = opts.resultType || "value";
      this.flatten = opts.flatten || false;
      this.wrap = hasOwnProp.call(opts, "wrap") ? opts.wrap : true;
      this.sandbox = opts.sandbox || {};
      this.preventEval = opts.preventEval || false;
      this.parent = opts.parent || null;
      this.parentProperty = opts.parentProperty || null;
      this.callback = opts.callback || callback || null;
      this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function() {
        throw new TypeError("You must supply an otherTypeCallback callback option with the @other() operator.");
      };
      if (opts.autostart !== false) {
        const args = {
          path: optObj ? opts.path : expr
        };
        if (!optObj) {
          args.json = obj;
        } else if ("json" in opts) {
          args.json = opts.json;
        }
        const ret = this.evaluate(args);
        if (!ret || typeof ret !== "object") {
          throw new NewError(ret);
        }
        return ret;
      }
    }
    JSONPath.prototype.evaluate = function(expr, json, callback, otherTypeCallback) {
      let currParent = this.parent, currParentProperty = this.parentProperty;
      let {
        flatten,
        wrap
      } = this;
      this.currResultType = this.resultType;
      this.currPreventEval = this.preventEval;
      this.currSandbox = this.sandbox;
      callback = callback || this.callback;
      this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
      json = json || this.json;
      expr = expr || this.path;
      if (expr && typeof expr === "object" && !Array.isArray(expr)) {
        if (!expr.path && expr.path !== "") {
          throw new TypeError('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
        }
        if (!hasOwnProp.call(expr, "json")) {
          throw new TypeError('You must supply a "json" property when providing an object argument to JSONPath.evaluate().');
        }
        ({
          json
        } = expr);
        flatten = hasOwnProp.call(expr, "flatten") ? expr.flatten : flatten;
        this.currResultType = hasOwnProp.call(expr, "resultType") ? expr.resultType : this.currResultType;
        this.currSandbox = hasOwnProp.call(expr, "sandbox") ? expr.sandbox : this.currSandbox;
        wrap = hasOwnProp.call(expr, "wrap") ? expr.wrap : wrap;
        this.currPreventEval = hasOwnProp.call(expr, "preventEval") ? expr.preventEval : this.currPreventEval;
        callback = hasOwnProp.call(expr, "callback") ? expr.callback : callback;
        this.currOtherTypeCallback = hasOwnProp.call(expr, "otherTypeCallback") ? expr.otherTypeCallback : this.currOtherTypeCallback;
        currParent = hasOwnProp.call(expr, "parent") ? expr.parent : currParent;
        currParentProperty = hasOwnProp.call(expr, "parentProperty") ? expr.parentProperty : currParentProperty;
        expr = expr.path;
      }
      currParent = currParent || null;
      currParentProperty = currParentProperty || null;
      if (Array.isArray(expr)) {
        expr = JSONPath.toPathString(expr);
      }
      if (!expr && expr !== "" || !json) {
        return void 0;
      }
      const exprList = JSONPath.toPathArray(expr);
      if (exprList[0] === "$" && exprList.length > 1) {
        exprList.shift();
      }
      this._hasParentSelector = null;
      const result = this._trace(exprList, json, ["$"], currParent, currParentProperty, callback).filter(function(ea) {
        return ea && !ea.isParentSelector;
      });
      if (!result.length) {
        return wrap ? [] : void 0;
      }
      if (!wrap && result.length === 1 && !result[0].hasArrExpr) {
        return this._getPreferredOutput(result[0]);
      }
      return result.reduce((rslt, ea) => {
        const valOrPath = this._getPreferredOutput(ea);
        if (flatten && Array.isArray(valOrPath)) {
          rslt = rslt.concat(valOrPath);
        } else {
          rslt.push(valOrPath);
        }
        return rslt;
      }, []);
    };
    JSONPath.prototype._getPreferredOutput = function(ea) {
      const resultType = this.currResultType;
      switch (resultType) {
        case "all": {
          const path2 = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);
          ea.pointer = JSONPath.toPointer(path2);
          ea.path = typeof ea.path === "string" ? ea.path : JSONPath.toPathString(ea.path);
          return ea;
        }
        case "value":
        case "parent":
        case "parentProperty":
          return ea[resultType];
        case "path":
          return JSONPath.toPathString(ea[resultType]);
        case "pointer":
          return JSONPath.toPointer(ea.path);
        default:
          throw new TypeError("Unknown result type");
      }
    };
    JSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {
      if (callback) {
        const preferredOutput = this._getPreferredOutput(fullRetObj);
        fullRetObj.path = typeof fullRetObj.path === "string" ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
        callback(preferredOutput, type, fullRetObj);
      }
    };
    JSONPath.prototype._trace = function(expr, val, path2, parent, parentPropName, callback, hasArrExpr, literalPriority) {
      let retObj;
      if (!expr.length) {
        retObj = {
          path: path2,
          value: val,
          parent,
          parentProperty: parentPropName,
          hasArrExpr
        };
        this._handleCallback(retObj, callback, "value");
        return retObj;
      }
      const loc = expr[0], x3 = expr.slice(1);
      const ret = [];
      function addRet(elems) {
        if (Array.isArray(elems)) {
          elems.forEach((t3) => {
            ret.push(t3);
          });
        } else {
          ret.push(elems);
        }
      }
      if ((typeof loc !== "string" || literalPriority) && val && hasOwnProp.call(val, loc)) {
        addRet(this._trace(x3, val[loc], push(path2, loc), val, loc, callback, hasArrExpr));
      } else if (loc === "*") {
        this._walk(loc, x3, val, path2, parent, parentPropName, callback, (m2, l2, _x, v2, p2, par, pr, cb) => {
          addRet(this._trace(unshift(m2, _x), v2, p2, par, pr, cb, true, true));
        });
      } else if (loc === "..") {
        addRet(this._trace(x3, val, path2, parent, parentPropName, callback, hasArrExpr));
        this._walk(loc, x3, val, path2, parent, parentPropName, callback, (m2, l2, _x, v2, p2, par, pr, cb) => {
          if (typeof v2[m2] === "object") {
            addRet(this._trace(unshift(l2, _x), v2[m2], push(p2, m2), v2, m2, cb, true));
          }
        });
      } else if (loc === "^") {
        this._hasParentSelector = true;
        return {
          path: path2.slice(0, -1),
          expr: x3,
          isParentSelector: true
        };
      } else if (loc === "~") {
        retObj = {
          path: push(path2, loc),
          value: parentPropName,
          parent,
          parentProperty: null
        };
        this._handleCallback(retObj, callback, "property");
        return retObj;
      } else if (loc === "$") {
        addRet(this._trace(x3, val, path2, null, null, callback, hasArrExpr));
      } else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(loc)) {
        addRet(this._slice(loc, x3, val, path2, parent, parentPropName, callback));
      } else if (loc.indexOf("?(") === 0) {
        if (this.currPreventEval) {
          throw new Error("Eval [?(expr)] prevented in JSONPath expression.");
        }
        this._walk(loc, x3, val, path2, parent, parentPropName, callback, (m2, l2, _x, v2, p2, par, pr, cb) => {
          if (this._eval(l2.replace(/^\?\((.*?)\)$/u, "$1"), v2[m2], m2, p2, par, pr)) {
            addRet(this._trace(unshift(m2, _x), v2, p2, par, pr, cb, true));
          }
        });
      } else if (loc[0] === "(") {
        if (this.currPreventEval) {
          throw new Error("Eval [(expr)] prevented in JSONPath expression.");
        }
        addRet(this._trace(unshift(this._eval(loc, val, path2[path2.length - 1], path2.slice(0, -1), parent, parentPropName), x3), val, path2, parent, parentPropName, callback, hasArrExpr));
      } else if (loc[0] === "@") {
        let addType = false;
        const valueType = loc.slice(1, -2);
        switch (valueType) {
          case "scalar":
            if (!val || !["object", "function"].includes(typeof val)) {
              addType = true;
            }
            break;
          case "boolean":
          case "string":
          case "undefined":
          case "function":
            if (typeof val === valueType) {
              addType = true;
            }
            break;
          case "integer":
            if (Number.isFinite(val) && !(val % 1)) {
              addType = true;
            }
            break;
          case "number":
            if (Number.isFinite(val)) {
              addType = true;
            }
            break;
          case "nonFinite":
            if (typeof val === "number" && !Number.isFinite(val)) {
              addType = true;
            }
            break;
          case "object":
            if (val && typeof val === valueType) {
              addType = true;
            }
            break;
          case "array":
            if (Array.isArray(val)) {
              addType = true;
            }
            break;
          case "other":
            addType = this.currOtherTypeCallback(val, path2, parent, parentPropName);
            break;
          case "null":
            if (val === null) {
              addType = true;
            }
            break;
          default:
            throw new TypeError("Unknown value type " + valueType);
        }
        if (addType) {
          retObj = {
            path: path2,
            value: val,
            parent,
            parentProperty: parentPropName
          };
          this._handleCallback(retObj, callback, "value");
          return retObj;
        }
      } else if (loc[0] === "`" && val && hasOwnProp.call(val, loc.slice(1))) {
        const locProp = loc.slice(1);
        addRet(this._trace(x3, val[locProp], push(path2, locProp), val, locProp, callback, hasArrExpr, true));
      } else if (loc.includes(",")) {
        const parts = loc.split(",");
        for (const part of parts) {
          addRet(this._trace(unshift(part, x3), val, path2, parent, parentPropName, callback, true));
        }
      } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {
        addRet(this._trace(x3, val[loc], push(path2, loc), val, loc, callback, hasArrExpr, true));
      }
      if (this._hasParentSelector) {
        for (let t3 = 0; t3 < ret.length; t3++) {
          const rett = ret[t3];
          if (rett && rett.isParentSelector) {
            const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);
            if (Array.isArray(tmp)) {
              ret[t3] = tmp[0];
              const tl = tmp.length;
              for (let tt = 1; tt < tl; tt++) {
                t3++;
                ret.splice(t3, 0, tmp[tt]);
              }
            } else {
              ret[t3] = tmp;
            }
          }
        }
      }
      return ret;
    };
    JSONPath.prototype._walk = function(loc, expr, val, path2, parent, parentPropName, callback, f2) {
      if (Array.isArray(val)) {
        const n3 = val.length;
        for (let i3 = 0; i3 < n3; i3++) {
          f2(i3, loc, expr, val, path2, parent, parentPropName, callback);
        }
      } else if (val && typeof val === "object") {
        Object.keys(val).forEach((m2) => {
          f2(m2, loc, expr, val, path2, parent, parentPropName, callback);
        });
      }
    };
    JSONPath.prototype._slice = function(loc, expr, val, path2, parent, parentPropName, callback) {
      if (!Array.isArray(val)) {
        return void 0;
      }
      const len = val.length, parts = loc.split(":"), step = parts[2] && Number.parseInt(parts[2]) || 1;
      let start = parts[0] && Number.parseInt(parts[0]) || 0, end = parts[1] && Number.parseInt(parts[1]) || len;
      start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
      end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
      const ret = [];
      for (let i3 = start; i3 < end; i3 += step) {
        const tmp = this._trace(unshift(i3, expr), val, path2, parent, parentPropName, callback, true);
        tmp.forEach((t3) => {
          ret.push(t3);
        });
      }
      return ret;
    };
    JSONPath.prototype._eval = function(code, _v, _vname, path2, parent, parentPropName) {
      if (code.includes("@parentProperty")) {
        this.currSandbox._$_parentProperty = parentPropName;
        code = code.replace(/@parentProperty/gu, "_$_parentProperty");
      }
      if (code.includes("@parent")) {
        this.currSandbox._$_parent = parent;
        code = code.replace(/@parent/gu, "_$_parent");
      }
      if (code.includes("@property")) {
        this.currSandbox._$_property = _vname;
        code = code.replace(/@property/gu, "_$_property");
      }
      if (code.includes("@path")) {
        this.currSandbox._$_path = JSONPath.toPathString(path2.concat([_vname]));
        code = code.replace(/@path/gu, "_$_path");
      }
      if (code.includes("@root")) {
        this.currSandbox._$_root = this.json;
        code = code.replace(/@root/gu, "_$_root");
      }
      if (/@([.\s)[])/u.test(code)) {
        this.currSandbox._$_v = _v;
        code = code.replace(/@([.\s)[])/gu, "_$_v$1");
      }
      try {
        return this.vm.runInNewContext(code, this.currSandbox);
      } catch (e3) {
        console.log(e3);
        throw new Error("jsonPath: " + e3.message + ": " + code);
      }
    };
    JSONPath.cache = {};
    JSONPath.toPathString = function(pathArr) {
      const x3 = pathArr, n3 = x3.length;
      let p2 = "$";
      for (let i3 = 1; i3 < n3; i3++) {
        if (!/^(~|\^|@.*?\(\))$/u.test(x3[i3])) {
          p2 += /^[0-9*]+$/u.test(x3[i3]) ? "[" + x3[i3] + "]" : "['" + x3[i3] + "']";
        }
      }
      return p2;
    };
    JSONPath.toPointer = function(pointer) {
      const x3 = pointer, n3 = x3.length;
      let p2 = "";
      for (let i3 = 1; i3 < n3; i3++) {
        if (!/^(~|\^|@.*?\(\))$/u.test(x3[i3])) {
          p2 += "/" + x3[i3].toString().replace(/~/gu, "~0").replace(/\//gu, "~1");
        }
      }
      return p2;
    };
    JSONPath.toPathArray = function(expr) {
      const {
        cache: cache2
      } = JSONPath;
      if (cache2[expr]) {
        return cache2[expr].concat();
      }
      const subx = [];
      const normalized = expr.replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu, ";$&;").replace(/[['](\??\(.*?\))[\]']/gu, function($0, $1) {
        return "[#" + (subx.push($1) - 1) + "]";
      }).replace(/\[['"]([^'\]]*)['"]\]/gu, function($0, prop) {
        return "['" + prop.replace(/\./gu, "%@%").replace(/~/gu, "%%@@%%") + "']";
      }).replace(/~/gu, ";~;").replace(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ";").replace(/%@%/gu, ".").replace(/%%@@%%/gu, "~").replace(/(?:;)?(\^+)(?:;)?/gu, function($0, ups) {
        return ";" + ups.split("").join(";") + ";";
      }).replace(/;;;|;;/gu, ";..;").replace(/;$|'?\]|'$/gu, "");
      const exprList = normalized.split(";").map(function(exp) {
        const match = exp.match(/#(\d+)/u);
        return !match || !match[1] ? exp : subx[match[1]];
      });
      cache2[expr] = exprList;
      return cache2[expr].concat();
    };
    JSONPath.prototype.vm = vm__default["default"];
    exports.JSONPath = JSONPath;
  }
});

// ../../node_modules/lodash.topath/index.js
var require_lodash2 = __commonJS({
  "../../node_modules/lodash.topath/index.js"(exports, module2) {
    "use strict";
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayMap(array, iteratee) {
      var index3 = -1, length = array ? array.length : 0, result = Array(length);
      while (++index3 < length) {
        result[index3] = iteratee(array[index3], index3, array);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e3) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index3 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index3 < length) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index3 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index3 < length) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index3 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index3, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      return index3 < 0 ? void 0 : data[index3][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index3 = assocIndexOf(data, key);
      if (index3 < 0) {
        data.push([key, value]);
      } else {
        data[index3][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index3 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index3 < length) {
        var entry = entries[index3];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject4(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function copyArray(source, array) {
      var index3 = -1, length = source.length;
      array || (array = Array(length));
      while (++index3 < length) {
        array[index3] = source[index3];
      }
      return array;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e3) {
        }
        try {
          return func + "";
        } catch (e3) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction3(value) {
      var tag = isObject4(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(value));
    }
    module2.exports = toPath;
  }
});

// ../../node_modules/nimma/dist/cjs/codegen/ast/builders.js
var require_builders2 = __commonJS({
  "../../node_modules/nimma/dist/cjs/codegen/ast/builders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function program(body) {
      return {
        type: "Program",
        body
      };
    }
    function blockStatement(body, directives) {
      return {
        type: "BlockStatement",
        body,
        directives
      };
    }
    function expressionStatement(expression) {
      return {
        type: "ExpressionStatement",
        expression
      };
    }
    function literal(value) {
      switch (typeof value) {
        case "number":
          return numericLiteral(value);
        case "string":
          return stringLiteral(value);
        case "boolean":
          return booleanLiteral(value);
      }
    }
    function stringLiteral(value) {
      return {
        type: "StringLiteral",
        value
      };
    }
    function booleanLiteral(value) {
      return {
        type: "BooleanLiteral",
        value
      };
    }
    function numericLiteral(value) {
      return {
        type: "NumericLiteral",
        value
      };
    }
    function nullLiteral() {
      return {
        type: "NullLiteral",
        value: null
      };
    }
    function regExpLiteral(pattern, flags = "") {
      return {
        type: "RegExpLiteral",
        pattern,
        flags
      };
    }
    function identifier(name) {
      return {
        type: "Identifier",
        name
      };
    }
    function logicalExpression(operator, left, right) {
      return {
        type: "LogicalExpression",
        operator,
        left,
        right
      };
    }
    function conditionalExpression(test, consequent, alternate) {
      return {
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      };
    }
    function ifStatement(test, consequent, alternate) {
      return {
        type: "IfStatement",
        test,
        consequent,
        alternate
      };
    }
    function binaryExpression(operator, left, right) {
      return {
        type: "BinaryExpression",
        operator,
        left,
        right
      };
    }
    function safeBinaryExpression(operator, left, right) {
      let actualRight = right;
      if (right.type === "NumericLiteral") {
        actualRight = stringLiteral(String(right.value));
      } else if (right.type === "StringLiteral" && Number.isSafeInteger(Number(right.value))) {
        actualRight = stringLiteral(String(right.value));
      }
      return {
        type: "BinaryExpression",
        operator,
        left: actualRight === right ? left : callExpression(identifier("String"), [left]),
        right: actualRight
      };
    }
    function unaryExpression(operator, argument, prefix = true) {
      return {
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      };
    }
    function memberExpression(object, property, computed = false, optional = null) {
      return {
        type: "MemberExpression",
        object,
        property,
        computed,
        optional
      };
    }
    function assignmentExpression(operator, left, right) {
      return {
        type: "AssignmentExpression",
        operator,
        left,
        right
      };
    }
    function callExpression(callee, _arguments) {
      return {
        type: "CallExpression",
        callee,
        arguments: _arguments
      };
    }
    function functionDeclaration(id, params, body) {
      return {
        type: "FunctionDeclaration",
        id,
        params,
        body
      };
    }
    function returnStatement(argument) {
      return {
        type: "ReturnStatement",
        argument
      };
    }
    function sequenceExpression(expressions) {
      return {
        type: "SequenceExpression",
        expressions
      };
    }
    function forOfStatement(left, right, body, _await) {
      return {
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      };
    }
    function arrayExpression(elements) {
      return {
        type: "ArrayExpression",
        elements
      };
    }
    function objectExpression(properties) {
      return {
        type: "ObjectExpression",
        properties
      };
    }
    function objectMethod(kind, key, params, body, computed = false, generator = false, _async = false) {
      return {
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async: _async
      };
    }
    function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
      return {
        type: "ObjectProperty",
        key,
        value,
        computed,
        shorthand,
        decorators
      };
    }
    function variableDeclaration(kind, declarations) {
      return {
        type: "VariableDeclaration",
        kind,
        declarations
      };
    }
    function variableDeclarator(id, init) {
      return {
        type: "VariableDeclarator",
        id,
        init
      };
    }
    function newExpression(callee, _arguments) {
      return {
        type: "NewExpression",
        callee,
        arguments: _arguments
      };
    }
    function importDeclaration(specifiers, source) {
      return {
        type: "ImportDeclaration",
        specifiers,
        source
      };
    }
    function importSpecifier(local, imported) {
      return {
        type: "ImportSpecifier",
        local,
        imported
      };
    }
    function exportDefaultDeclaration(declaration) {
      return {
        type: "ExportDefaultDeclaration",
        declaration
      };
    }
    function arrowFunctionExpression(params, body, _async = false) {
      return {
        type: "ArrowFunctionExpression",
        params,
        body,
        async: _async
      };
    }
    function tryStatement(block, handler = null, finalizer = null) {
      return {
        type: "TryStatement",
        block,
        handler,
        finalizer
      };
    }
    function templateElement(value, tail = false) {
      return {
        type: "TemplateElement",
        value,
        tail
      };
    }
    function templateLiteral(quasis, expressions) {
      return {
        type: "TemplateLiteral",
        quasis,
        expressions
      };
    }
    exports.arrayExpression = arrayExpression;
    exports.arrowFunctionExpression = arrowFunctionExpression;
    exports.assignmentExpression = assignmentExpression;
    exports.binaryExpression = binaryExpression;
    exports.blockStatement = blockStatement;
    exports.booleanLiteral = booleanLiteral;
    exports.callExpression = callExpression;
    exports.conditionalExpression = conditionalExpression;
    exports.exportDefaultDeclaration = exportDefaultDeclaration;
    exports.expressionStatement = expressionStatement;
    exports.forOfStatement = forOfStatement;
    exports.functionDeclaration = functionDeclaration;
    exports.identifier = identifier;
    exports.ifStatement = ifStatement;
    exports.importDeclaration = importDeclaration;
    exports.importSpecifier = importSpecifier;
    exports.literal = literal;
    exports.logicalExpression = logicalExpression;
    exports.memberExpression = memberExpression;
    exports.newExpression = newExpression;
    exports.nullLiteral = nullLiteral;
    exports.numericLiteral = numericLiteral;
    exports.objectExpression = objectExpression;
    exports.objectMethod = objectMethod;
    exports.objectProperty = objectProperty;
    exports.program = program;
    exports.regExpLiteral = regExpLiteral;
    exports.returnStatement = returnStatement;
    exports.safeBinaryExpression = safeBinaryExpression;
    exports.sequenceExpression = sequenceExpression;
    exports.stringLiteral = stringLiteral;
    exports.templateElement = templateElement;
    exports.templateLiteral = templateLiteral;
    exports.tryStatement = tryStatement;
    exports.unaryExpression = unaryExpression;
    exports.variableDeclaration = variableDeclaration;
    exports.variableDeclarator = variableDeclarator;
  }
});

// ../../node_modules/nimma/dist/cjs/codegen/fallback.js
var require_fallback = __commonJS({
  "../../node_modules/nimma/dist/cjs/codegen/fallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builders = require_builders2();
    function safeName(name) {
      return `nimma_${name}`;
    }
    function safeIdentifier(name) {
      return builders.identifier(safeName(name));
    }
    function getFunctionBody(fn) {
      const source = Reflect.apply(Function.toString, fn, []);
      const paramsDefEnd = source.indexOf(")") + 1;
      const body = source.slice(paramsDefEnd).replace(/^\s*(=>\s*)?/, "");
      const arr = source.slice(source.indexOf("("), paramsDefEnd).split(/[,\s]+/).splice(0, 3);
      return `${arr.join(", ")} => ${body}`;
    }
    var Fallback = class {
      #modules = /* @__PURE__ */ new Set();
      #deps = /* @__PURE__ */ new Map();
      #fn;
      #extraCode = "";
      runtimeDeps = /* @__PURE__ */ new Map();
      constructor(deps, fn) {
        this.#fn = fn;
        for (const [source, specifiers] of Object.entries(deps)) {
          const importSpecifiers = [];
          for (const {
            imported,
            local,
            value
          } of specifiers) {
            this.#deps.set(local, value);
            this.runtimeDeps.set(safeName(local), value);
            importSpecifiers.push(builders.importSpecifier(safeIdentifier(local), builders.identifier(imported)));
            this.#modules.add(builders.importDeclaration(importSpecifiers, builders.stringLiteral(source)));
          }
        }
      }
      get extraCode() {
        this.#extraCode || (this.#extraCode = getFunctionBody(this.#fn));
        return this.#extraCode;
      }
      attach(tree) {
        for (const mod of this.#modules) {
          tree.push(mod, "program");
        }
        const id = builders.identifier("fallback");
        const args = Array.from(this.#deps.keys());
        tree.push(builders.variableDeclaration("const", [builders.variableDeclarator(id, builders.callExpression(builders.memberExpression(builders.callExpression(builders.identifier("Function"), [builders.templateLiteral([builders.templateElement({
          raw: `return ${this.extraCode}`
        })], [])]), builders.identifier("call")), [builders.objectExpression(args.map((arg) => builders.objectProperty(builders.stringLiteral(arg), safeIdentifier(arg))))]))]), "program");
        return id;
      }
    };
    exports["default"] = Fallback;
  }
});

// ../../node_modules/nimma/dist/cjs/fallbacks/jsonpath-plus.js
var require_jsonpath_plus = __commonJS({
  "../../node_modules/nimma/dist/cjs/fallbacks/jsonpath-plus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsonpathPlus$1 = require_index_node_cjs2();
    var toPath = require_lodash2();
    var fallback = require_fallback();
    function _interopDefaultLegacy(e3) {
      return e3 && typeof e3 === "object" && "default" in e3 ? e3 : { "default": e3 };
    }
    var toPath__default = /* @__PURE__ */ _interopDefaultLegacy(toPath);
    var jsonpathPlus = new fallback["default"](
      {
        "jsonpath-plus": [{
          imported: "JSONPath",
          local: "JSONPath",
          value: jsonpathPlus$1.JSONPath
        }],
        "lodash.topath": [{
          imported: "default",
          local: "toPath",
          value: toPath__default["default"]
        }]
      },
      // this part is tested, but cannot be covered because we never get to execute the actual fn
      // what we do is we get the source code of it and construct a new fn based on that code
      /* c8 ignore start */
      function(input, path2, fn) {
        this.JSONPath({
          callback: (result) => {
            fn({
              path: this.toPath(result.path.slice(1)),
              value: result.value
            });
          },
          json: input,
          path: path2,
          resultType: "all"
        });
      }
    );
    exports["default"] = jsonpathPlus;
  }
});

// ../../node_modules/nimma/dist/cjs/fallbacks/index.js
var require_fallbacks = __commonJS({
  "../../node_modules/nimma/dist/cjs/fallbacks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsonpathPlus = require_jsonpath_plus();
    exports.jsonPathPlus = jsonpathPlus["default"];
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/runner/runner.js
var require_runner2 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/runner/runner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Runner = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var results_1 = require_results();
    var lintNode_1 = require_lintNode();
    var legacy_1 = (0, tslib_1.__importDefault)(require_cjs());
    var fallbacks_1 = require_fallbacks();
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var Runner = class {
      constructor(inventory) {
        var _a;
        this.inventory = inventory;
        this.results = [...this.inventory.diagnostics, ...(_a = this.inventory.errors) !== null && _a !== void 0 ? _a : []];
      }
      get document() {
        return this.inventory.document;
      }
      addResult(result) {
        this.results.push(result);
      }
      async run(ruleset) {
        var _a, _b;
        var _c;
        const { inventory: documentInventory } = this;
        const { rules } = ruleset;
        const formats = (_a = this.document.formats) !== null && _a !== void 0 ? _a : null;
        const runnerContext = {
          ruleset,
          documentInventory,
          results: this.results,
          promises: []
        };
        const enabledRules = Object.values(rules).filter((rule) => rule.enabled);
        const relevantRules = enabledRules.filter((rule) => rule.matchesFormat(documentInventory.formats));
        const callbacks = {
          resolved: {},
          unresolved: {}
        };
        for (const rule of relevantRules) {
          for (const given of rule.getGivenForFormats(formats)) {
            const cb = (scope) => {
              (0, lintNode_1.lintNode)(runnerContext, scope, rule);
            };
            ((_b = (_c = callbacks[rule.resolved ? "resolved" : "unresolved"])[given]) !== null && _b !== void 0 ? _b : _c[given] = []).push(cb);
          }
        }
        const resolvedJsonPaths = Object.keys(callbacks.resolved);
        const unresolvedJsonPaths = Object.keys(callbacks.unresolved);
        if (resolvedJsonPaths.length > 0) {
          execute(runnerContext.documentInventory.resolved, callbacks.resolved, resolvedJsonPaths);
        }
        if (unresolvedJsonPaths.length > 0) {
          execute(runnerContext.documentInventory.unresolved, callbacks.unresolved, unresolvedJsonPaths);
        }
        if (runnerContext.promises.length > 0) {
          await Promise.all(runnerContext.promises);
        }
      }
      getResults() {
        return (0, results_1.prepareResults)(this.results);
      }
    };
    exports.Runner = Runner;
    function execute(input, callbacks, jsonPathExpressions) {
      var _a;
      if (!(0, json_1.isPlainObject)(input) && !Array.isArray(input)) {
        for (const cb of (_a = callbacks.$) !== null && _a !== void 0 ? _a : []) {
          cb({
            path: [],
            value: input
          });
        }
        return;
      }
      const nimma = new legacy_1.default(jsonPathExpressions, {
        fallback: fallbacks_1.jsonPathPlus,
        unsafe: false,
        output: "auto",
        customShorthands: {}
      });
      nimma.query(input, Object.entries(callbacks).reduce((mapped, [key, cbs]) => {
        mapped[key] = (scope) => {
          for (const cb of cbs) {
            cb(scope);
          }
        };
        return mapped;
      }, {}));
    }
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/runner/index.js
var require_runner3 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/runner/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Runner = void 0;
    var runner_1 = require_runner2();
    Object.defineProperty(exports, "Runner", { enumerable: true, get: function() {
      return runner_1.Runner;
    } });
  }
});

// ../../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../node_modules/concat-map/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i3 = 0; i3 < xs.length; i3++) {
        var x3 = fn(xs[i3], i3);
        if (isArray(x3))
          res.push.apply(res, x3);
        else
          res.push(x3);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a3, b3, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b3 instanceof RegExp)
        b3 = maybeMatch(b3, str);
      var r3 = range(a3, b3, str);
      return r3 && {
        start: r3[0],
        end: r3[1],
        pre: str.slice(0, r3[0]),
        body: str.slice(r3[0] + a3.length, r3[1]),
        post: str.slice(r3[1] + b3.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a3, b3, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a3);
      var bi = str.indexOf(b3, ai + 1);
      var i3 = ai;
      if (ai >= 0 && bi > 0) {
        if (a3 === b3) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i3 >= 0 && !result) {
          if (i3 == ai) {
            begs.push(i3);
            ai = str.indexOf(a3, i3 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b3, i3 + 1);
          }
          i3 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/minimatch/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/minimatch/node_modules/brace-expansion/index.js"(exports, module2) {
    "use strict";
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return str.split(",");
      var pre = m2.pre;
      var body = m2.body;
      var post = m2.post;
      var p2 = pre.split(",");
      p2[p2.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p2[p2.length - 1] += postParts.shift();
        p2.push.apply(p2, postParts);
      }
      parts.push.apply(parts, p2);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i3, y) {
      return i3 <= y;
    }
    function gte(i3, y) {
      return i3 >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m2 = balanced("{", "}", str);
      if (!m2 || /\$$/.test(m2.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m2.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m2.post.match(/,.*\}/)) {
          str = m2.pre + "{" + m2.body + escClose + m2.post;
          return expand(str);
        }
        return [str];
      }
      var n3;
      if (isSequence) {
        n3 = m2.body.split(/\.\./);
      } else {
        n3 = parseCommaParts(m2.body);
        if (n3.length === 1) {
          n3 = expand(n3[0], false).map(embrace);
          if (n3.length === 1) {
            var post = m2.post.length ? expand(m2.post, false) : [""];
            return post.map(function(p2) {
              return m2.pre + n3[0] + p2;
            });
          }
        }
      }
      var pre = m2.pre;
      var post = m2.post.length ? expand(m2.post, false) : [""];
      var N2;
      if (isSequence) {
        var x3 = numeric(n3[0]);
        var y = numeric(n3[1]);
        var width = Math.max(n3[0].length, n3[1].length);
        var incr = n3.length == 3 ? Math.abs(numeric(n3[2])) : 1;
        var test = lte;
        var reverse = y < x3;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n3.some(isPadded);
        N2 = [];
        for (var i3 = x3; test(i3, y); i3 += incr) {
          var c2;
          if (isAlphaSequence) {
            c2 = String.fromCharCode(i3);
            if (c2 === "\\")
              c2 = "";
          } else {
            c2 = String(i3);
            if (pad) {
              var need = width - c2.length;
              if (need > 0) {
                var z2 = new Array(need + 1).join("0");
                if (i3 < 0)
                  c2 = "-" + z2 + c2.slice(1);
                else
                  c2 = z2 + c2;
              }
            }
          }
          N2.push(c2);
        }
      } else {
        N2 = concatMap(n3, function(el) {
          return expand(el, false);
        });
      }
      for (var j2 = 0; j2 < N2.length; j2++) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + N2[j2] + post[k2];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../node_modules/minimatch/minimatch.js"(exports, module2) {
    "use strict";
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path2 = function() {
      try {
        return require("path");
      } catch (e3) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path2.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set, c2) {
        set[c2] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter2;
    function filter2(pattern, options) {
      options = options || {};
      return function(p2, i3, list) {
        return minimatch(p2, pattern, options);
      };
    }
    function ext(a3, b3) {
      b3 = b3 || {};
      var t3 = {};
      Object.keys(a3).forEach(function(k2) {
        t3[k2] = a3[k2];
      });
      Object.keys(b3).forEach(function(k2) {
        t3[k2] = b3[k2];
      });
      return t3;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m2 = function minimatch2(p2, pattern, options) {
        return orig(p2, pattern, ext(def, options));
      };
      m2.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m2.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m2.filter = function filter3(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m2.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m2.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m2.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m2.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m2;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p2, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p2);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path2.sep !== "/") {
        pattern = pattern.split(path2.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug3() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s2, si, set2) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i3 = 0, l2 = pattern.length; i3 < l2 && pattern.charAt(i3) === "!"; i3++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re2 = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re2 += star;
              hasMagic = true;
              break;
            case "?":
              re2 += qmark;
              hasMagic = true;
              break;
            default:
              re2 += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re2);
          stateChar = false;
        }
      }
      for (var i3 = 0, len = pattern.length, c2; i3 < len && (c2 = pattern.charAt(i3)); i3++) {
        this.debug("%s	%s %s %j", pattern, i3, re2, c2);
        if (escaping && reSpecials[c2]) {
          re2 += "\\" + c2;
          escaping = false;
          continue;
        }
        switch (c2) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i3, re2, c2);
            if (inClass) {
              this.debug("  in class");
              if (c2 === "!" && i3 === classStart + 1)
                c2 = "^";
              re2 += c2;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c2;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re2 += "(";
              continue;
            }
            if (!stateChar) {
              re2 += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i3 - 1,
              reStart: re2.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re2);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re2 += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re2 += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re2.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re2 += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re2 += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re2 += "\\" + c2;
              continue;
            }
            inClass = true;
            classStart = i3;
            reClassStart = re2.length;
            re2 += c2;
            continue;
          case "]":
            if (i3 === classStart + 1 || !inClass) {
              re2 += "\\" + c2;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i3);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re2 += c2;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
              re2 += "\\";
            }
            re2 += c2;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re2.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re2, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re2);
        var t3 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re2 = re2.slice(0, pl.reStart) + t3 + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re2 += "\\\\";
      }
      var addPatternStart = false;
      switch (re2.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n3 = negativeLists.length - 1; n3 > -1; n3--) {
        var nl = negativeLists[n3];
        var nlBefore = re2.slice(0, nl.reStart);
        var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re2.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i3 = 0; i3 < openParensBefore; i3++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re2 = newRe;
      }
      if (re2 !== "" && hasMagic) {
        re2 = "(?=.)" + re2;
      }
      if (addPatternStart) {
        re2 = patternStart + re2;
      }
      if (isSub === SUBPARSE) {
        return [re2, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re2 + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re2;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re2 = set.map(function(pattern) {
        return pattern.map(function(p2) {
          return p2 === GLOBSTAR ? twoStar : typeof p2 === "string" ? regExpEscape(p2) : p2._src;
        }).join("\\/");
      }).join("|");
      re2 = "^(?:" + re2 + ")$";
      if (this.negate)
        re2 = "^(?!" + re2 + ").*$";
      try {
        this.regexp = new RegExp(re2, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm2 = new Minimatch(pattern, options);
      list = list.filter(function(f2) {
        return mm2.match(f2);
      });
      if (mm2.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f2, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f2, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f2 === "";
      if (f2 === "/" && partial)
        return true;
      var options = this.options;
      if (path2.sep !== "/") {
        f2 = f2.split(path2.sep).join("/");
      }
      f2 = f2.split(slashSplit);
      this.debug(this.pattern, "split", f2);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i3;
      for (i3 = f2.length - 1; i3 >= 0; i3--) {
        filename = f2[i3];
        if (filename)
          break;
      }
      for (i3 = 0; i3 < set.length; i3++) {
        var pattern = set[i3];
        var file = f2;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p2 = pattern[pi];
        var f2 = file[fi];
        this.debug(pattern, p2, f2);
        if (p2 === false)
          return false;
        if (p2 === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p2, f2]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p2 === "string") {
          hit = f2 === p2;
          this.debug("string match", p2, f2, hit);
        } else {
          hit = f2.match(p2);
          this.debug("pattern match", p2, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/utils/minimatch.js
var require_minimatch2 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/utils/minimatch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minimatch = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var minimatch_1 = (0, tslib_1.__importDefault)(require_minimatch());
    var DEFAULT_OPTS = { matchBase: true };
    function minimatch(source, pattern) {
      return (0, minimatch_1.default)(source, pattern, DEFAULT_OPTS);
    }
    exports.minimatch = minimatch;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/utils/severity.js
var require_severity = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/utils/severity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDiagnosticSeverity = exports.DEFAULT_SEVERITY_LEVEL = void 0;
    var types_1 = require_dist();
    exports.DEFAULT_SEVERITY_LEVEL = types_1.DiagnosticSeverity.Warning;
    var SEVERITY_MAP = {
      error: types_1.DiagnosticSeverity.Error,
      warn: types_1.DiagnosticSeverity.Warning,
      info: types_1.DiagnosticSeverity.Information,
      hint: types_1.DiagnosticSeverity.Hint,
      off: -1
    };
    function getDiagnosticSeverity(severity) {
      if (Number.isNaN(Number(severity))) {
        return SEVERITY_MAP[severity];
      }
      return Number(severity);
    }
    exports.getDiagnosticSeverity = getDiagnosticSeverity;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/formats.js
var require_formats = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Formats = void 0;
    function printFormat(format2) {
      var _a;
      return (_a = format2.displayName) !== null && _a !== void 0 ? _a : format2.name;
    }
    var Formats = class extends Set {
      toJSON() {
        return Array.from(this).map(printFormat);
      }
    };
    exports.Formats = Formats;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/utils/guards.js
var require_guards2 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/utils/guards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isScopedAliasDefinition = exports.isValidAliasTarget = exports.isSimpleAliasDefinition = void 0;
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var lodash_1 = require_lodash();
    function isSimpleAliasDefinition(alias) {
      return Array.isArray(alias);
    }
    exports.isSimpleAliasDefinition = isSimpleAliasDefinition;
    function isValidAliasTarget(target) {
      const formats = target.formats;
      if (!Array.isArray(formats) && !(formats instanceof Set)) {
        return false;
      }
      return Array.isArray(target.given) && target.given.every(lodash_1.isString);
    }
    exports.isValidAliasTarget = isValidAliasTarget;
    function isScopedAliasDefinition(alias) {
      return (0, json_1.isPlainObject)(alias) && Array.isArray(alias.targets) && alias.targets.every(isValidAliasTarget);
    }
    exports.isScopedAliasDefinition = isScopedAliasDefinition;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/alias.js
var require_alias = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/alias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveAlias = exports.resolveAliasForFormats = void 0;
    var guards_1 = require_guards2();
    var ALIAS = /^#([A-Za-z0-9_-]+)/;
    function resolveAliasForFormats({ targets }, formats) {
      if (formats === null || formats.size === 0) {
        return null;
      }
      for (let i3 = targets.length - 1; i3 >= 0; i3--) {
        const target = targets[i3];
        for (const format2 of target.formats) {
          if (formats.has(format2)) {
            return target.given;
          }
        }
      }
      return null;
    }
    exports.resolveAliasForFormats = resolveAliasForFormats;
    function resolveAlias(aliases, expression, formats) {
      return _resolveAlias(aliases, expression, formats, /* @__PURE__ */ new Set());
    }
    exports.resolveAlias = resolveAlias;
    function _resolveAlias(aliases, expression, formats, stack) {
      var _a;
      const resolvedExpressions = [];
      if (expression.startsWith("#")) {
        const alias = (_a = ALIAS.exec(expression)) === null || _a === void 0 ? void 0 : _a[1];
        if (alias === void 0 || alias === null) {
          throw new TypeError(`Alias must match /^#([A-Za-z0-9_-]+)/`);
        }
        if (stack.has(alias)) {
          const _stack = [...stack, alias];
          throw new Error(`Alias "${_stack[0]}" is circular. Resolution stack: ${_stack.join(" -> ")}`);
        }
        stack.add(alias);
        if (aliases === null || !(alias in aliases)) {
          throw new ReferenceError(`Alias "${alias}" does not exist`);
        }
        const aliasValue = aliases[alias];
        let actualAliasValue;
        if ((0, guards_1.isSimpleAliasDefinition)(aliasValue)) {
          actualAliasValue = aliasValue;
        } else if ((0, guards_1.isScopedAliasDefinition)(aliasValue)) {
          actualAliasValue = resolveAliasForFormats(aliasValue, formats);
        } else {
          actualAliasValue = null;
        }
        if (actualAliasValue !== null) {
          resolvedExpressions.push(...actualAliasValue.flatMap((item) => _resolveAlias(aliases, item + expression.slice(alias.length + 1), formats, /* @__PURE__ */ new Set([...stack]))));
        }
      } else {
        resolvedExpressions.push(expression);
      }
      return resolvedExpressions;
    }
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/rule.js
var require_rule = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/rule.js"(exports) {
    "use strict";
    var _Rule_severity;
    var _Rule_enabled;
    var _Rule_then;
    var _Rule_given;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Rule = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var lodash_1 = require_lodash();
    var path_1 = (init_index_es(), __toCommonJS(index_es_exports));
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var severity_1 = require_severity();
    var minimatch_1 = require_minimatch2();
    var formats_1 = require_formats();
    var alias_1 = require_alias();
    var Rule = class _Rule {
      constructor(name, definition, owner) {
        var _a, _b, _c, _d;
        this.name = name;
        this.definition = definition;
        this.owner = owner;
        _Rule_severity.set(this, void 0);
        _Rule_enabled.set(this, void 0);
        _Rule_then.set(this, void 0);
        _Rule_given.set(this, void 0);
        this.recommended = definition.recommended !== false;
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_enabled, this.recommended, "f");
        this.description = (_a = definition.description) !== null && _a !== void 0 ? _a : null;
        this.message = (_b = definition.message) !== null && _b !== void 0 ? _b : null;
        this.documentationUrl = (_c = definition.documentationUrl) !== null && _c !== void 0 ? _c : null;
        this.severity = definition.severity;
        this.resolved = definition.resolved !== false;
        this.formats = "formats" in definition ? new formats_1.Formats(definition.formats) : null;
        this.then = definition.then;
        this.given = definition.given;
        this.extensions = (_d = definition.extensions) !== null && _d !== void 0 ? _d : null;
      }
      get enabled() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_enabled, "f") || this.overrides !== void 0;
      }
      set enabled(enabled) {
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_enabled, enabled, "f");
      }
      static isEnabled(rule, severity) {
        return severity === "all" || severity === "recommended" && rule.recommended;
      }
      getSeverityForSource(source, path2) {
        if (this.overrides === void 0 || this.overrides.definition.size === 0) {
          return this.severity;
        }
        const relativeSource = (0, path_1.relative)((0, path_1.dirname)(this.overrides.rulesetSource), source);
        const relevantOverrides = [];
        for (const [source2, override] of this.overrides.definition.entries()) {
          if ((0, minimatch_1.minimatch)(relativeSource, source2)) {
            relevantOverrides.push(override);
          }
        }
        if (relevantOverrides.length === 0) {
          return this.severity;
        }
        let severity = this.severity;
        let closestPointer = "";
        const pointer = (0, json_1.pathToPointer)(path2);
        for (const relevantOverride of relevantOverrides) {
          for (const [overridePath, overrideSeverity] of relevantOverride.entries()) {
            if (overridePath.length >= closestPointer.length && (pointer === overridePath || pointer.startsWith(`${overridePath}/`))) {
              closestPointer = overridePath;
              severity = overrideSeverity;
            }
          }
        }
        return severity;
      }
      get severity() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_severity, "f");
      }
      set severity(severity) {
        if (severity === void 0) {
          (0, tslib_1.__classPrivateFieldSet)(this, _Rule_severity, severity_1.DEFAULT_SEVERITY_LEVEL, "f");
        } else {
          (0, tslib_1.__classPrivateFieldSet)(this, _Rule_severity, (0, severity_1.getDiagnosticSeverity)(severity), "f");
        }
      }
      get then() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_then, "f");
      }
      set then(then) {
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_then, Array.isArray(then) ? then : [then], "f");
      }
      get given() {
        return (0, tslib_1.__classPrivateFieldGet)(this, _Rule_given, "f");
      }
      set given(given) {
        const actualGiven = Array.isArray(given) ? given : [given];
        (0, tslib_1.__classPrivateFieldSet)(this, _Rule_given, this.owner.hasComplexAliases ? actualGiven : actualGiven.flatMap((expr) => (0, alias_1.resolveAlias)(this.owner.aliases, expr, null)).filter(lodash_1.isString), "f");
      }
      getGivenForFormats(formats) {
        return this.owner.hasComplexAliases ? (0, tslib_1.__classPrivateFieldGet)(this, _Rule_given, "f").flatMap((expr) => (0, alias_1.resolveAlias)(this.owner.aliases, expr, formats)) : (0, tslib_1.__classPrivateFieldGet)(this, _Rule_given, "f");
      }
      matchesFormat(formats) {
        if (this.formats === null) {
          return true;
        }
        if (formats === null) {
          return false;
        }
        for (const format2 of formats) {
          if (this.formats.has(format2)) {
            return true;
          }
        }
        return false;
      }
      clone() {
        return new _Rule(this.name, this.definition, this.owner);
      }
      toJSON() {
        return {
          name: this.name,
          recommended: this.recommended,
          enabled: this.enabled,
          description: this.description,
          message: this.message,
          documentationUrl: this.documentationUrl,
          severity: this.severity,
          resolved: this.resolved,
          formats: this.formats,
          then: this.then.map((then) => ({
            ...then,
            function: then.function.name
          })),
          given: Array.isArray(this.definition.given) ? this.definition.given : [this.definition.given],
          owner: this.owner.id,
          extensions: this.extensions
        };
      }
    };
    exports.Rule = Rule;
    _Rule_severity = /* @__PURE__ */ new WeakMap(), _Rule_enabled = /* @__PURE__ */ new WeakMap(), _Rule_then = /* @__PURE__ */ new WeakMap(), _Rule_given = /* @__PURE__ */ new WeakMap();
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/guards/isAggregateError.js
var require_isAggregateError = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/guards/isAggregateError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAggregateError = void 0;
    var lodash_1 = require_lodash();
    function isAggregateError(maybeAggregateError) {
      return (0, lodash_1.isError)(maybeAggregateError) && maybeAggregateError.constructor.name === "AggregateError";
    }
    exports.isAggregateError = isAggregateError;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/errors.js
var require_errors = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertAjvErrors = exports.RulesetValidationError = void 0;
    var isAggregateError_1 = require_isAggregateError();
    var RulesetValidationError = class extends Error {
      constructor(code, message, path2) {
        super(message);
        this.code = code;
        this.message = message;
        this.path = path2;
      }
    };
    exports.RulesetValidationError = RulesetValidationError;
    var RULE_INSTANCE_PATH = /^\/rules\/[^/]+/;
    var GENERIC_INSTANCE_PATH = /^\/(?:aliases|extends|overrides(?:\/\d+\/extends)?)/;
    function convertAjvErrors(errors) {
      const sortedErrors = [...errors].sort((errorA, errorB) => {
        const diff = errorA.instancePath.length - errorB.instancePath.length;
        return diff === 0 ? errorA.keyword === "errorMessage" && errorB.keyword !== "errorMessage" ? -1 : 0 : diff;
      }).filter((error, i3, sortedErrors2) => i3 === 0 || sortedErrors2[i3 - 1].instancePath !== error.instancePath);
      const filteredErrors = [];
      l:
        for (let i3 = 0; i3 < sortedErrors.length; i3++) {
          const error = sortedErrors[i3];
          const prevError = filteredErrors.length === 0 ? null : filteredErrors[filteredErrors.length - 1];
          if (error.keyword === "if")
            continue;
          if (GENERIC_INSTANCE_PATH.test(error.instancePath)) {
            let x3 = 1;
            while (i3 + x3 < sortedErrors.length) {
              if (sortedErrors[i3 + x3].instancePath.startsWith(error.instancePath) || !GENERIC_INSTANCE_PATH.test(sortedErrors[i3 + x3].instancePath)) {
                continue l;
              }
              x3++;
            }
          } else if (prevError === null) {
            filteredErrors.push(error);
            continue;
          } else {
            const match = RULE_INSTANCE_PATH.exec(error.instancePath);
            if (match !== null && match[0] !== match.input && match[0] === prevError.instancePath) {
              filteredErrors.pop();
            }
          }
          filteredErrors.push(error);
        }
      return filteredErrors.flatMap((error) => {
        var _a;
        if (error.keyword === "x-spectral-runtime") {
          return flatErrors(error.params.errors);
        }
        const path2 = error.instancePath.slice(1).split("/");
        return new RulesetValidationError(inferErrorCode(path2, error.keyword), (_a = error.message) !== null && _a !== void 0 ? _a : "unknown error", path2);
      });
    }
    exports.convertAjvErrors = convertAjvErrors;
    function flatErrors(error) {
      if ((0, isAggregateError_1.isAggregateError)(error)) {
        return error.errors.flatMap(flatErrors);
      }
      return error;
    }
    function inferErrorCode(path2, keyword5) {
      if (path2.length === 0) {
        return "generic-validation-error";
      }
      if (path2.length === 1 && keyword5 !== "errorMessage") {
        return "invalid-ruleset-definition";
      }
      switch (path2[0]) {
        case "rules":
          return inferErrorCodeFromRulesError(path2);
        case "parserOptions":
          return "invalid-parser-options-definition";
        case "aliases":
          return inferErrorCodeFromAliasesError(path2);
        case "extends":
          return "invalid-extend-definition";
        case "overrides":
          return inferErrorCodeFromOverrideError(path2, keyword5);
        case "formats":
          if (path2.length === 1) {
            return "invalid-ruleset-definition";
          }
          return "invalid-format";
        default:
          return "generic-validation-error";
      }
    }
    function inferErrorCodeFromRulesError(path2) {
      if (path2.length === 3 && path2[2] === "severity") {
        return "invalid-severity";
      }
      if (path2.length === 4 && path2[2] === "formats") {
        return "invalid-format";
      }
      if (path2.length === 4 && path2[2] === "given") {
        return "invalid-given-definition";
      }
      return "invalid-rule-definition";
    }
    function inferErrorCodeFromOverrideError(path2, keyword5) {
      if (path2.length >= 3) {
        return inferErrorCode(path2.slice(2), keyword5);
      }
      return "invalid-override-definition";
    }
    function inferErrorCodeFromAliasesError(path2) {
      if (path2.length === 6) {
        if (path2[4] === "given") {
          return "invalid-given-definition";
        }
        if (path2[4] === "formats") {
          return "invalid-format";
        }
      }
      return "invalid-alias-definition";
    }
  }
});

// ../../node_modules/ajv-formats/dist/formats.js
var require_formats2 = __commonJS({
  "../../node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare2) {
      return { validate, compare: compare2 };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: regex3,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
    }
    function compareTime(t1, t22) {
      if (!(t1 && t22))
        return void 0;
      const a1 = TIME.exec(t1);
      const a22 = TIME.exec(t22);
      if (!(a1 && a22))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
      t22 = a22[1] + a22[2] + a22[3] + (a22[4] || "");
      if (t1 > t22)
        return 1;
      if (t1 < t22)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t22] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t22);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex3(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e3) {
        return false;
      }
    }
  }
});

// ../../node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "../../node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require("ajv");
    var codegen_1 = require("ajv/dist/compile/codegen");
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword: keyword5, schemaCode }) => codegen_1.str`should be ${KWDs[keyword5].okStr} ${schemaCode}`,
      params: ({ keyword: keyword5, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword5].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword: keyword5, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self2.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword5}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword5].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// ../../node_modules/ajv-formats/dist/index.js
var require_dist8 = __commonJS({
  "../../node_modules/ajv-formats/dist/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats2();
    var limit_1 = require_limit();
    var codegen_1 = require("ajv/dist/compile/codegen");
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        limit_1.default(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f2 = formats[name];
      if (!f2)
        throw new Error(`Unknown format "${name}"`);
      return f2;
    };
    function addFormats(ajv, list, fs8, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
      for (const f2 of list)
        ajv.addFormat(f2, fs8[f2]);
    }
    module2.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// ../../node_modules/ajv-errors/dist/index.js
var require_dist9 = __commonJS({
  "../../node_modules/ajv-errors/dist/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ajv_1 = require("ajv");
    var codegen_1 = require("ajv/dist/compile/codegen");
    var code_1 = require("ajv/dist/compile/codegen/code");
    var validate_1 = require("ajv/dist/compile/validate");
    var errors_1 = require("ajv/dist/compile/errors");
    var names_1 = require("ajv/dist/compile/names");
    var keyword5 = "errorMessage";
    var used = new ajv_1.Name("emUsed");
    var KEYWORD_PROPERTY_PARAMS = {
      required: "missingProperty",
      dependencies: "property",
      dependentRequired: "property"
    };
    var INTERPOLATION = /\$\{[^}]+\}/;
    var INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
    var EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
    function errorMessage2(options) {
      return {
        keyword: keyword5,
        schemaType: ["string", "object"],
        post: true,
        code(cxt) {
          const { gen, data, schema, schemaValue, it } = cxt;
          if (it.createErrors === false)
            return;
          const sch = schema;
          const instancePath = codegen_1.strConcat(names_1.default.instancePath, it.errorPath);
          gen.if(ajv_1._`${names_1.default.errors} > 0`, () => {
            if (typeof sch == "object") {
              const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
              if (kwdErrors)
                processKeywordErrors(kwdErrors);
              if (kwdPropErrors)
                processKeywordPropErrors(kwdPropErrors);
              processChildErrors(childErrorsConfig(sch));
            }
            const schMessage = typeof sch == "string" ? sch : sch._;
            if (schMessage)
              processAllErrors(schMessage);
            if (!options.keepErrors)
              removeUsedErrors();
          });
          function childErrorsConfig({ properties, items }) {
            const errors = {};
            if (properties) {
              errors.props = {};
              for (const p2 in properties)
                errors.props[p2] = [];
            }
            if (items) {
              errors.items = {};
              for (let i3 = 0; i3 < items.length; i3++)
                errors.items[i3] = [];
            }
            return errors;
          }
          function keywordErrorsConfig(emSchema) {
            let propErrors;
            let errors;
            for (const k2 in emSchema) {
              if (k2 === "properties" || k2 === "items")
                continue;
              const kwdSch = emSchema[k2];
              if (typeof kwdSch == "object") {
                propErrors || (propErrors = {});
                const errMap = propErrors[k2] = {};
                for (const p2 in kwdSch)
                  errMap[p2] = [];
              } else {
                errors || (errors = {});
                errors[k2] = [];
              }
            }
            return [propErrors, errors];
          }
          function processKeywordErrors(kwdErrors) {
            const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
            const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
            const { singleError } = options;
            if (singleError) {
              const message = gen.let("message", ajv_1._`""`);
              const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
              loopErrors((key) => {
                gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
              });
              errors_1.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
            } else {
              loopErrors((key) => errors_1.reportError(cxt, {
                message: errMessage(key),
                params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
              }));
            }
            function loopErrors(body) {
              gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
            }
            function errMessage(key) {
              return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
            }
          }
          function processKeywordPropErrors(kwdPropErrors) {
            const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
            const templatesCode = [];
            for (const k2 in kwdPropErrors) {
              templatesCode.push([
                k2,
                getTemplatesCode(kwdPropErrors[k2], schema[k2])
              ]);
            }
            const templates = gen.const("templates", gen.object(...templatesCode));
            const kwdPropParams = gen.scopeValue("obj", {
              ref: KEYWORD_PROPERTY_PARAMS,
              code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
            });
            const propParam = gen.let("emPropParams");
            const paramsErrors = gen.let("emParamsErrors");
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
              gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
              gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
              gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
            }));
            gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
              gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
              gen.if(ajv_1._`${paramsErrors}.length`, () => {
                const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                errors_1.reportError(cxt, {
                  message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                  params: ajv_1._`{errors: ${paramsErrors}}`
                });
              });
            }));
          }
          function processChildErrors(childErrors) {
            const { props, items } = childErrors;
            if (!props && !items)
              return;
            const isObj = ajv_1._`typeof ${data} == "object"`;
            const isArr = ajv_1._`Array.isArray(${data})`;
            const childErrs = gen.let("emErrors");
            let childKwd;
            let childProp;
            const templates = gen.let("templates");
            if (props && items) {
              childKwd = gen.let("emChildKwd");
              gen.if(isObj);
              gen.if(isArr, () => {
                init(items, schema.items);
                gen.assign(childKwd, ajv_1.str`items`);
              }, () => {
                init(props, schema.properties);
                gen.assign(childKwd, ajv_1.str`properties`);
              });
              childProp = ajv_1._`[${childKwd}]`;
            } else if (items) {
              gen.if(isArr);
              init(items, schema.items);
              childProp = ajv_1._`.items`;
            } else if (props) {
              gen.if(codegen_1.and(isObj, codegen_1.not(isArr)));
              init(props, schema.properties);
              childProp = ajv_1._`.properties`;
            }
            gen.forOf("err", names_1.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
            gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
              errors_1.reportError(cxt, {
                message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                params: ajv_1._`{errors: ${childErrs}[${key}]}`
              });
              gen.assign(ajv_1._`${names_1.default.vErrors}[${names_1.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
            }));
            gen.endIf();
            function init(children, msgs) {
              gen.assign(childErrs, ajv_1.stringify(children));
              gen.assign(templates, getTemplatesCode(children, msgs));
            }
          }
          function processAllErrors(schMessage) {
            const errs = gen.const("emErrs", ajv_1._`[]`);
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
            gen.if(ajv_1._`${errs}.length`, () => errors_1.reportError(cxt, {
              message: templateExpr(schMessage),
              params: ajv_1._`{errors: ${errs}}`
            }));
          }
          function removeUsedErrors() {
            const errs = gen.const("emErrs", ajv_1._`[]`);
            gen.forOf("err", names_1.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
            gen.assign(names_1.default.vErrors, errs).assign(names_1.default.errors, ajv_1._`${errs}.length`);
          }
          function matchKeywordError(err, kwdErrs) {
            return codegen_1.and(
              ajv_1._`${err}.keyword !== ${keyword5}`,
              ajv_1._`!${err}.${used}`,
              ajv_1._`${err}.instancePath === ${instancePath}`,
              ajv_1._`${err}.keyword in ${kwdErrs}`,
              // TODO match the end of the string?
              ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,
              ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`
            );
          }
          function ifMatchesChildError(err, childErrs, thenBody) {
            gen.if(codegen_1.and(ajv_1._`${err}.keyword !== ${keyword5}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
              const childRegex = gen.scopeValue("pattern", {
                ref: /^\/([^/]*)(?:\/|$)/,
                code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
              });
              const matches = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
              const child = gen.const("emChild", ajv_1._`${matches} && ${matches}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
              gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
            });
          }
          function matchAnyError(err) {
            return codegen_1.and(ajv_1._`${err}.keyword !== ${keyword5}`, ajv_1._`!${err}.${used}`, codegen_1.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_1.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it.errSchemaPath}.length] === "/"`);
          }
          function getTemplatesCode(keys, msgs) {
            const templatesCode = [];
            for (const k2 in keys) {
              const msg = msgs[k2];
              if (INTERPOLATION.test(msg))
                templatesCode.push([k2, templateFunc(msg)]);
            }
            return gen.object(...templatesCode);
          }
          function templateExpr(msg) {
            if (!INTERPOLATION.test(msg))
              return ajv_1.stringify(msg);
            return new code_1._Code(code_1.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_1.getData(ptr, it)}) + "`).replace(EMPTY_STR, ""));
          }
          function templateFunc(msg) {
            return ajv_1._`function(){return ${templateExpr(msg)}}`;
          }
        },
        metaSchema: {
          anyOf: [
            { type: "string" },
            {
              type: "object",
              properties: {
                properties: { $ref: "#/$defs/stringMap" },
                items: { $ref: "#/$defs/stringList" },
                required: { $ref: "#/$defs/stringOrMap" },
                dependencies: { $ref: "#/$defs/stringOrMap" }
              },
              additionalProperties: { type: "string" }
            }
          ],
          $defs: {
            stringMap: {
              type: "object",
              additionalProperties: { type: "string" }
            },
            stringOrMap: {
              anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
            },
            stringList: { type: "array", items: { type: "string" } }
          }
        }
      };
    }
    var ajvErrors = (ajv, options = {}) => {
      if (!ajv.opts.allErrors)
        throw new Error("ajv-errors: Ajv option allErrors must be true");
      if (ajv.opts.jsPropertySyntax) {
        throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
      }
      return ajv.addKeyword(errorMessage2(options));
    };
    exports.default = ajvErrors;
    module2.exports = ajvErrors;
    module2.exports.default = ajvErrors;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/rule.schema.json
var require_rule_schema = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/rule.schema.json"(exports, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "@stoplight/spectral-core/meta/rule.schema",
      $defs: {
        Then: {
          type: "object",
          allOf: [
            {
              properties: {
                field: {
                  type: "string"
                }
              }
            },
            {
              $ref: "extensions#function"
            }
          ]
        },
        Severity: {
          $ref: "shared#severity"
        }
      },
      if: {
        type: "object"
      },
      then: {
        type: "object",
        properties: {
          description: {
            type: "string"
          },
          documentationUrl: {
            type: "string",
            format: "url",
            errorMessage: "must be a valid URL"
          },
          recommended: {
            type: "boolean"
          },
          given: {
            $ref: "shared#given"
          },
          resolved: {
            type: "boolean"
          },
          severity: {
            $ref: "#/$defs/Severity"
          },
          message: {
            type: "string"
          },
          tags: {
            items: {
              type: "string"
            },
            type: "array"
          },
          formats: {
            $ref: "shared#formats"
          },
          then: {
            if: {
              type: "array"
            },
            then: {
              type: "array",
              items: {
                $ref: "#/$defs/Then"
              }
            },
            else: {
              $ref: "#/$defs/Then"
            }
          },
          type: {
            enum: ["style", "validation"],
            type: "string",
            errorMessage: 'allowed types are "style" and "validation"'
          },
          extensions: {
            type: "object"
          }
        },
        required: ["given", "then"],
        additionalProperties: false,
        patternProperties: {
          "^x-": true
        },
        errorMessage: {
          required: 'the rule must have at least "given" and "then" properties'
        }
      },
      else: {
        oneOf: [
          {
            $ref: "shared#/$defs/HumanReadableSeverity"
          },
          {
            type: "boolean"
          }
        ]
      }
    };
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/shared.json
var require_shared = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/shared.json"(exports, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "@stoplight/spectral-core/meta/shared",
      $defs: {
        Formats: {
          $anchor: "formats",
          type: "array",
          items: {
            $ref: "extensions#format"
          },
          errorMessage: "must be an array of formats"
        },
        DiagnosticSeverity: {
          enum: [-1, 0, 1, 2, 3]
        },
        HumanReadableSeverity: {
          enum: ["error", "warn", "info", "hint", "off"]
        },
        Severity: {
          $anchor: "severity",
          oneOf: [
            {
              $ref: "#/$defs/DiagnosticSeverity"
            },
            {
              $ref: "#/$defs/HumanReadableSeverity"
            }
          ],
          errorMessage: 'the value has to be one of: 0, 1, 2, 3 or "error", "warn", "info", "hint", "off"'
        },
        Given: {
          $anchor: "given",
          if: {
            type: "array"
          },
          then: {
            $anchor: "arrayish-given",
            type: "array",
            items: {
              $ref: "path-expression"
            },
            minItems: 1,
            errorMessage: {
              minItems: "must be a non-empty array of expressions"
            }
          },
          else: {
            $ref: "path-expression"
          }
        },
        PathExpression: {
          $id: "path-expression",
          if: {
            type: "string"
          },
          then: {
            type: "string",
            if: {
              pattern: "^#"
            },
            then: {
              "x-spectral-runtime": "alias"
            },
            else: {
              pattern: "^\\$",
              errorMessage: "must be a valid JSON Path expression or a reference to the existing Alias optionally paired with a JSON Path expression subset"
            }
          },
          else: {
            not: {},
            errorMessage: "must be a valid JSON Path expression or a reference to the existing Alias optionally paired with a JSON Path expression subset"
          }
        }
      }
    };
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/ruleset.schema.json
var require_ruleset_schema = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/ruleset.schema.json"(exports, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "@stoplight/spectral-core/meta/ruleset.schema",
      type: "object",
      additionalProperties: false,
      properties: {
        documentationUrl: {
          type: "string",
          format: "url",
          errorMessage: "must be a valid URL"
        },
        description: {
          type: "string"
        },
        rules: {
          type: "object",
          additionalProperties: {
            $ref: "rule.schema#"
          }
        },
        functions: {
          $ref: "extensions#functions"
        },
        functionsDir: {
          $ref: "extensions#functionsDir"
        },
        formats: {
          $ref: "shared#formats"
        },
        extends: {
          $ref: "extensions#extends"
        },
        parserOptions: {
          type: "object",
          properties: {
            duplicateKeys: {
              $ref: "shared#severity"
            },
            incompatibleValues: {
              $ref: "shared#severity"
            }
          },
          additionalProperties: false
        },
        overrides: {
          type: "array",
          minItems: 1,
          items: {
            if: {
              type: "object",
              properties: {
                files: {
                  type: "array",
                  minItems: 1,
                  items: {
                    type: "string",
                    minLength: 1,
                    pattern: "^[^#]+#"
                  },
                  errorMessage: "must be an non-empty array of glob patterns"
                }
              },
              required: ["files"]
            },
            then: {
              type: "object",
              properties: {
                files: true,
                rules: {
                  type: "object",
                  additionalProperties: {
                    $ref: "shared#severity"
                  },
                  errorMessage: {
                    enum: "must be a valid severity level"
                  }
                }
              },
              required: ["rules"],
              additionalProperties: false,
              errorMessage: {
                required: "must contain rules when JSON Pointers are defined",
                additionalProperties: "must not override any other property than rules when JSON Pointers are defined"
              }
            },
            else: {
              allOf: [
                {
                  type: "object",
                  properties: {
                    files: {
                      type: "array",
                      minItems: 1,
                      items: {
                        type: "string",
                        pattern: "[^#]",
                        minLength: 1
                      },
                      errorMessage: "must be an non-empty array of glob patterns"
                    }
                  },
                  required: ["files"],
                  errorMessage: {
                    type: 'must be an override, i.e. { "files": ["v2/**/*.json"], "rules": {} }'
                  }
                },
                {
                  type: "object",
                  properties: {
                    formats: {
                      $ref: "shared#formats"
                    },
                    extends: {
                      $ref: "#/properties/extends"
                    },
                    rules: {
                      $ref: "#/properties/rules"
                    },
                    parserOptions: {
                      $ref: "#/properties/parserOptions"
                    },
                    aliases: {
                      $ref: "#/properties/aliases"
                    }
                  },
                  anyOf: [
                    {
                      required: ["extends"]
                    },
                    {
                      required: ["rules"]
                    }
                  ]
                }
              ]
            }
          },
          errorMessage: {
            minItems: "must not be empty"
          }
        },
        aliases: {
          type: "object",
          propertyNames: {
            pattern: "^[A-Za-z][A-Za-z0-9_-]*$",
            errorMessage: {
              pattern: "to avoid confusion the name must match /^[A-Za-z][A-Za-z0-9_-]*$/ regular expression",
              minLength: "the name of an alias must not be empty"
            }
          },
          additionalProperties: {
            if: {
              type: "object"
            },
            then: {
              type: "object",
              properties: {
                description: {
                  type: "string"
                },
                targets: {
                  type: "array",
                  minItems: 1,
                  items: {
                    type: "object",
                    properties: {
                      formats: {
                        $ref: "shared#formats"
                      },
                      given: {
                        $ref: "shared#arrayish-given"
                      }
                    },
                    required: ["formats", "given"],
                    errorMessage: "a valid target must contain given and non-empty formats"
                  },
                  errorMessage: {
                    minItems: "targets must have at least a single alias definition"
                  }
                }
              },
              required: ["targets"],
              errorMessage: {
                required: "targets must be present and have at least a single alias definition"
              }
            },
            else: {
              $ref: "shared#arrayish-given"
            }
          }
        }
      },
      patternProperties: {
        "^x-": true
      },
      anyOf: [
        {
          required: ["extends"]
        },
        {
          required: ["rules"]
        },
        {
          required: ["overrides"]
        }
      ]
    };
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/js-extensions.json
var require_js_extensions = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/js-extensions.json"(exports, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "@stoplight/spectral-core/meta/extensions",
      $defs: {
        Extends: {
          $anchor: "extends",
          oneOf: [
            {
              $id: "ruleset",
              $ref: "ruleset.schema#",
              errorMessage: "must be a valid ruleset"
            },
            {
              type: "array",
              items: {
                anyOf: [
                  {
                    $ref: "ruleset"
                  },
                  {
                    type: "array",
                    minItems: 2,
                    additionalItems: false,
                    items: [
                      {
                        $ref: "ruleset"
                      },
                      {
                        type: "string",
                        enum: ["off", "recommended", "all"],
                        errorMessage: 'allowed types are "off", "recommended" and "all"'
                      }
                    ]
                  }
                ]
              }
            }
          ],
          errorMessage: "must be a valid ruleset"
        },
        Format: {
          $anchor: "format",
          "x-spectral-runtime": "format",
          errorMessage: "must be a valid format"
        },
        Function: {
          $anchor: "function",
          "x-spectral-runtime": "ruleset-function",
          type: "object",
          properties: {
            function: true
          },
          required: ["function"]
        },
        Functions: {
          $anchor: "functions",
          not: {}
        },
        FunctionsDir: {
          $anchor: "functionsDir",
          not: {}
        }
      }
    };
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/json-extensions.json
var require_json_extensions = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/meta/json-extensions.json"(exports, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "@stoplight/spectral-core/meta/extensions",
      $defs: {
        Extends: {
          $anchor: "extends",
          oneOf: [
            {
              type: "string"
            },
            {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    type: "array",
                    minItems: 2,
                    additionalItems: false,
                    items: [
                      {
                        type: "string"
                      },
                      {
                        enum: ["all", "recommended", "off"],
                        errorMessage: 'allowed types are "off", "recommended" and "all"'
                      }
                    ]
                  }
                ]
              }
            }
          ]
        },
        Format: {
          $anchor: "format",
          type: "string",
          errorMessage: "must be a valid format"
        },
        Functions: {
          $anchor: "functions",
          type: "array",
          items: {
            type: "string"
          }
        },
        FunctionsDir: {
          $anchor: "functionsDir",
          type: "string"
        },
        Function: {
          $anchor: "function",
          type: "object",
          properties: {
            function: {
              type: "string"
            }
          },
          required: ["function"]
        }
      }
    };
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a3, b3) {
      var arr = [];
      for (var i3 = 0; i3 < a3.length; i3 += 1) {
        arr[i3] = a3[i3];
      }
      for (var j2 = 0; j2 < b3.length; j2 += 1) {
        arr[j2 + a3.length] = b3[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i3 = offset || 0, j2 = 0; i3 < arrLike.length; i3 += 1, j2 += 1) {
        arr[j2] = arrLike[i3];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i3 = 0; i3 < arr.length; i3 += 1) {
        str += arr[i3];
        if (i3 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i3 = 0; i3 < boundLength; i3++) {
        boundArgs[i3] = "$" + i3;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/object-keys/isArguments.js"(exports, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../../node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "../../node_modules/object-keys/implementation.js"(exports, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o3) {
        var ctor = o3.constructor;
        return ctor && ctor.prototype === o3;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k2 in window) {
          try {
            if (!excludedKeys["$" + k2] && has.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
              try {
                equalsConstructorPrototype(window[k2]);
              } catch (e3) {
                return true;
              }
            }
          } catch (e3) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o3) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o3);
        }
        try {
          return equalsConstructorPrototype(o3);
        } catch (e3) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject4 = object !== null && typeof object === "object";
        var isFunction3 = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString3 = isObject4 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject4 && !isFunction3 && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction3;
        if (isString3 && object.length > 0 && !has.call(object, 0)) {
          for (var i3 = 0; i3 < object.length; ++i3) {
            theKeys.push(String(i3));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j2 = 0; j2 < object.length; ++j2) {
            theKeys.push(String(j2));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k2 = 0; k2 < dontEnums.length; ++k2) {
            if (!(skipConstructor && dontEnums[k2] === "constructor") && has.call(object, dontEnums[k2])) {
              theKeys.push(dontEnums[k2]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// ../../node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "../../node_modules/object-keys/index.js"(exports, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o3) {
      return origKeys(o3);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../../node_modules/has-proto/index.js"(exports, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e3) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e3) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x3) {
      return x3.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e3) {
        errorProto = getProto(getProto(e3));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i3 = 1, isOwn = true; i3 < parts.length; i3 += 1) {
        var part = parts[i3];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i3 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/has-property-descriptors/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e3) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e3) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e3) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// ../../node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../../node_modules/define-data-property/index.js"(exports, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = false;
      }
    }
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// ../../node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../../node_modules/define-properties/index.js"(exports, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction3 = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction3(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i3 = 0; i3 < props.length; i3 += 1) {
        defineProperty(object, props[i3], map[props[i3]], predicates[props[i3]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// ../../node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "../../node_modules/functions-have-names/index.js"(exports, module2) {
    "use strict";
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f2() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e3) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f2() {
      }.bind().name !== "";
    };
    module2.exports = functionsHaveNames;
  }
});

// ../../node_modules/set-function-name/index.js
var require_set_function_name = __commonJS({
  "../../node_modules/set-function-name/index.js"(exports, module2) {
    "use strict";
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $TypeError = TypeError;
    module2.exports = function setFunctionName(fn, name) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      if (!loose || functionsHaveConfigurableNames) {
        if (hasDescriptors) {
          define2(fn, "name", name, true, true);
        } else {
          define2(fn, "name", name);
        }
      }
      return fn;
    };
  }
});

// ../../node_modules/es-abstract/2023/IsPropertyKey.js
var require_IsPropertyKey = __commonJS({
  "../../node_modules/es-abstract/2023/IsPropertyKey.js"(exports, module2) {
    "use strict";
    module2.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// ../../node_modules/es-abstract/helpers/isPropertyDescriptor.js
var require_isPropertyDescriptor = __commonJS({
  "../../node_modules/es-abstract/helpers/isPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var hasOwn = require_hasown();
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function IsPropertyDescriptor(ES, Desc) {
      if (ES.Type(Desc) !== "Object") {
        return false;
      }
      var allowed = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Get]]": true,
        "[[Set]]": true,
        "[[Value]]": true,
        "[[Writable]]": true
      };
      for (var key in Desc) {
        if (hasOwn(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});

// ../../node_modules/es-abstract/5/Type.js
var require_Type = __commonJS({
  "../../node_modules/es-abstract/5/Type.js"(exports, module2) {
    "use strict";
    module2.exports = function Type(x3) {
      if (x3 === null) {
        return "Null";
      }
      if (typeof x3 === "undefined") {
        return "Undefined";
      }
      if (typeof x3 === "function" || typeof x3 === "object") {
        return "Object";
      }
      if (typeof x3 === "number") {
        return "Number";
      }
      if (typeof x3 === "boolean") {
        return "Boolean";
      }
      if (typeof x3 === "string") {
        return "String";
      }
    };
  }
});

// ../../node_modules/es-abstract/2023/Type.js
var require_Type2 = __commonJS({
  "../../node_modules/es-abstract/2023/Type.js"(exports, module2) {
    "use strict";
    var ES5Type = require_Type();
    module2.exports = function Type(x3) {
      if (typeof x3 === "symbol") {
        return "Symbol";
      }
      if (typeof x3 === "bigint") {
        return "BigInt";
      }
      return ES5Type(x3);
    };
  }
});

// ../../node_modules/es-abstract/helpers/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/es-abstract/helpers/isNaN.js"(exports, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a3) {
      return a3 !== a3;
    };
  }
});

// ../../node_modules/es-abstract/helpers/isFinite.js
var require_isFinite = __commonJS({
  "../../node_modules/es-abstract/helpers/isFinite.js"(exports, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function(x3) {
      return (typeof x3 === "number" || typeof x3 === "bigint") && !$isNaN(x3) && x3 !== Infinity && x3 !== -Infinity;
    };
  }
});

// ../../node_modules/es-abstract/helpers/isInteger.js
var require_isInteger = __commonJS({
  "../../node_modules/es-abstract/helpers/isInteger.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $abs = GetIntrinsic("%Math.abs%");
    var $floor = GetIntrinsic("%Math.floor%");
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module2.exports = function isInteger(argument) {
      if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var absValue = $abs(argument);
      return $floor(absValue) === absValue;
    };
  }
});

// ../../node_modules/es-abstract/helpers/isMatchRecord.js
var require_isMatchRecord = __commonJS({
  "../../node_modules/es-abstract/helpers/isMatchRecord.js"(exports, module2) {
    "use strict";
    var hasOwn = require_hasown();
    module2.exports = function isMatchRecord(record) {
      return hasOwn(record, "[[StartIndex]]") && hasOwn(record, "[[EndIndex]]") && record["[[StartIndex]]"] >= 0 && record["[[EndIndex]]"] >= record["[[StartIndex]]"] && String(parseInt(record["[[StartIndex]]"], 10)) === String(record["[[StartIndex]]"]) && String(parseInt(record["[[EndIndex]]"], 10)) === String(record["[[EndIndex]]"]);
    };
  }
});

// ../../node_modules/es-abstract/helpers/assertRecord.js
var require_assertRecord = __commonJS({
  "../../node_modules/es-abstract/helpers/assertRecord.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var hasOwn = require_hasown();
    var isInteger = require_isInteger();
    var isMatchRecord = require_isMatchRecord();
    var predicates = {
      // https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type
      "Property Descriptor": function isPropertyDescriptor(Desc) {
        var allowed = {
          "[[Configurable]]": true,
          "[[Enumerable]]": true,
          "[[Get]]": true,
          "[[Set]]": true,
          "[[Value]]": true,
          "[[Writable]]": true
        };
        if (!Desc) {
          return false;
        }
        for (var key in Desc) {
          if (hasOwn(Desc, key) && !allowed[key]) {
            return false;
          }
        }
        var isData = hasOwn(Desc, "[[Value]]");
        var IsAccessor = hasOwn(Desc, "[[Get]]") || hasOwn(Desc, "[[Set]]");
        if (isData && IsAccessor) {
          throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
        }
        return true;
      },
      // https://262.ecma-international.org/13.0/#sec-match-records
      "Match Record": isMatchRecord,
      "Iterator Record": function isIteratorRecord(value) {
        return hasOwn(value, "[[Iterator]]") && hasOwn(value, "[[NextMethod]]") && hasOwn(value, "[[Done]]");
      },
      "PromiseCapability Record": function isPromiseCapabilityRecord(value) {
        return !!value && hasOwn(value, "[[Resolve]]") && typeof value["[[Resolve]]"] === "function" && hasOwn(value, "[[Reject]]") && typeof value["[[Reject]]"] === "function" && hasOwn(value, "[[Promise]]") && value["[[Promise]]"] && typeof value["[[Promise]]"].then === "function";
      },
      "AsyncGeneratorRequest Record": function isAsyncGeneratorRequestRecord(value) {
        return !!value && hasOwn(value, "[[Completion]]") && hasOwn(value, "[[Capability]]") && predicates["PromiseCapability Record"](value["[[Capability]]"]);
      },
      "RegExp Record": function isRegExpRecord(value) {
        return value && hasOwn(value, "[[IgnoreCase]]") && typeof value["[[IgnoreCase]]"] === "boolean" && hasOwn(value, "[[Multiline]]") && typeof value["[[Multiline]]"] === "boolean" && hasOwn(value, "[[DotAll]]") && typeof value["[[DotAll]]"] === "boolean" && hasOwn(value, "[[Unicode]]") && typeof value["[[Unicode]]"] === "boolean" && hasOwn(value, "[[CapturingGroupsCount]]") && typeof value["[[CapturingGroupsCount]]"] === "number" && isInteger(value["[[CapturingGroupsCount]]"]) && value["[[CapturingGroupsCount]]"] >= 0;
      }
    };
    module2.exports = function assertRecord(Type, recordType, argumentName, value) {
      var predicate = predicates[recordType];
      if (typeof predicate !== "function") {
        throw new $SyntaxError("unknown record type: " + recordType);
      }
      if (Type(value) !== "Object" || !predicate(value)) {
        throw new $TypeError(argumentName + " must be a " + recordType);
      }
    };
  }
});

// ../../node_modules/es-abstract/2023/IsAccessorDescriptor.js
var require_IsAccessorDescriptor = __commonJS({
  "../../node_modules/es-abstract/2023/IsAccessorDescriptor.js"(exports, module2) {
    "use strict";
    var hasOwn = require_hasown();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!hasOwn(Desc, "[[Get]]") && !hasOwn(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/es-abstract/2023/IsDataDescriptor.js
var require_IsDataDescriptor = __commonJS({
  "../../node_modules/es-abstract/2023/IsDataDescriptor.js"(exports, module2) {
    "use strict";
    var hasOwn = require_hasown();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!hasOwn(Desc, "[[Value]]") && !hasOwn(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS({
  "../../node_modules/es-abstract/helpers/isPrimitive.js"(exports, module2) {
    "use strict";
    module2.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// ../../node_modules/es-abstract/2023/IsExtensible.js
var require_IsExtensible = __commonJS({
  "../../node_modules/es-abstract/2023/IsExtensible.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $preventExtensions = GetIntrinsic("%Object.preventExtensions%", true);
    var $isExtensible = GetIntrinsic("%Object.isExtensible%", true);
    var isPrimitive = require_isPrimitive();
    module2.exports = $preventExtensions ? function IsExtensible(obj) {
      return !isPrimitive(obj) && $isExtensible(obj);
    } : function IsExtensible(obj) {
      return !isPrimitive(obj);
    };
  }
});

// ../../node_modules/es-abstract/2023/ToBoolean.js
var require_ToBoolean = __commonJS({
  "../../node_modules/es-abstract/2023/ToBoolean.js"(exports, module2) {
    "use strict";
    module2.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// ../../node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "../../node_modules/is-callable/index.js"(exports, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_2) {
        if (_2 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e3) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e3) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e3) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e3) {
        if (e3 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// ../../node_modules/es-abstract/2023/IsCallable.js
var require_IsCallable = __commonJS({
  "../../node_modules/es-abstract/2023/IsCallable.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_callable();
  }
});

// ../../node_modules/es-abstract/2023/ToPropertyDescriptor.js
var require_ToPropertyDescriptor = __commonJS({
  "../../node_modules/es-abstract/2023/ToPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var hasOwn = require_hasown();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type2();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable();
    module2.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (hasOwn(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (hasOwn(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (hasOwn(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (hasOwn(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (hasOwn(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (hasOwn(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((hasOwn(desc, "[[Get]]") || hasOwn(desc, "[[Set]]")) && (hasOwn(desc, "[[Value]]") || hasOwn(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// ../../node_modules/es-abstract/2023/SameValue.js
var require_SameValue = __commonJS({
  "../../node_modules/es-abstract/2023/SameValue.js"(exports, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function SameValue(x3, y) {
      if (x3 === y) {
        if (x3 === 0) {
          return 1 / x3 === 1 / y;
        }
        return true;
      }
      return $isNaN(x3) && $isNaN(y);
    };
  }
});

// ../../node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../../node_modules/set-function-length/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(fn, "length", length, true, true);
        } else {
          define2(fn, "length", length);
        }
      }
      return fn;
    };
  }
});

// ../../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/call-bind/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../node_modules/call-bind/callBound.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// ../../node_modules/es-abstract/helpers/IsArray.js
var require_IsArray = __commonJS({
  "../../node_modules/es-abstract/helpers/IsArray.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module2.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});

// ../../node_modules/es-abstract/helpers/DefineOwnProperty.js
var require_DefineOwnProperty = __commonJS({
  "../../node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors() && GetIntrinsic("%Object.defineProperty%", true);
    var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
    var isArray = hasArrayLengthDefineBug && require_IsArray();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module2.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O2, P2, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P2 in O2 && $isEnumerable(O2, P2) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V2 = desc["[[Value]]"];
        O2[P2] = V2;
        return SameValue(O2[P2], V2);
      }
      if (hasArrayLengthDefineBug && P2 === "length" && "[[Value]]" in desc && isArray(O2) && O2.length !== desc["[[Value]]"]) {
        O2.length = desc["[[Value]]"];
        return O2.length === desc["[[Value]]"];
      }
      $defineProperty(O2, P2, FromPropertyDescriptor(desc));
      return true;
    };
  }
});

// ../../node_modules/es-abstract/helpers/isFullyPopulatedPropertyDescriptor.js
var require_isFullyPopulatedPropertyDescriptor = __commonJS({
  "../../node_modules/es-abstract/helpers/isFullyPopulatedPropertyDescriptor.js"(exports, module2) {
    "use strict";
    module2.exports = function isFullyPopulatedPropertyDescriptor(ES, Desc) {
      return !!Desc && typeof Desc === "object" && "[[Enumerable]]" in Desc && "[[Configurable]]" in Desc && (ES.IsAccessorDescriptor(Desc) || ES.IsDataDescriptor(Desc));
    };
  }
});

// ../../node_modules/es-abstract/helpers/fromPropertyDescriptor.js
var require_fromPropertyDescriptor = __commonJS({
  "../../node_modules/es-abstract/helpers/fromPropertyDescriptor.js"(exports, module2) {
    "use strict";
    module2.exports = function fromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = !!Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = !!Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = !!Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});

// ../../node_modules/es-abstract/2023/FromPropertyDescriptor.js
var require_FromPropertyDescriptor = __commonJS({
  "../../node_modules/es-abstract/2023/FromPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var assertRecord = require_assertRecord();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    var Type = require_Type2();
    module2.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined") {
        assertRecord(Type, "Property Descriptor", "Desc", Desc);
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});

// ../../node_modules/es-abstract/2023/IsGenericDescriptor.js
var require_IsGenericDescriptor = __commonJS({
  "../../node_modules/es-abstract/2023/IsGenericDescriptor.js"(exports, module2) {
    "use strict";
    var assertRecord = require_assertRecord();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var Type = require_Type2();
    module2.exports = function IsGenericDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
        return true;
      }
      return false;
    };
  }
});

// ../../node_modules/es-abstract/2023/ValidateAndApplyPropertyDescriptor.js
var require_ValidateAndApplyPropertyDescriptor = __commonJS({
  "../../node_modules/es-abstract/2023/ValidateAndApplyPropertyDescriptor.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var DefineOwnProperty = require_DefineOwnProperty();
    var isFullyPopulatedPropertyDescriptor = require_isFullyPopulatedPropertyDescriptor();
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsGenericDescriptor = require_IsGenericDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module2.exports = function ValidateAndApplyPropertyDescriptor(O2, P2, extensible, Desc, current) {
      var oType = Type(O2);
      if (oType !== "Undefined" && oType !== "Object") {
        throw new $TypeError("Assertion failed: O must be undefined or an Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (Type(extensible) !== "Boolean") {
        throw new $TypeError("Assertion failed: extensible must be a Boolean");
      }
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (Type(current) !== "Undefined" && !isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, current)) {
        throw new $TypeError("Assertion failed: current must be a Property Descriptor, or undefined");
      }
      if (Type(current) === "Undefined") {
        if (!extensible) {
          return false;
        }
        if (oType === "Undefined") {
          return true;
        }
        if (IsAccessorDescriptor(Desc)) {
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O2,
            P2,
            Desc
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O2,
          P2,
          {
            "[[Configurable]]": !!Desc["[[Configurable]]"],
            "[[Enumerable]]": !!Desc["[[Enumerable]]"],
            "[[Value]]": Desc["[[Value]]"],
            "[[Writable]]": !!Desc["[[Writable]]"]
          }
        );
      }
      if (!isFullyPopulatedPropertyDescriptor({
        IsAccessorDescriptor,
        IsDataDescriptor
      }, current)) {
        throw new $TypeError("`current`, when present, must be a fully populated and valid Property Descriptor");
      }
      if (!current["[[Configurable]]"]) {
        if ("[[Configurable]]" in Desc && Desc["[[Configurable]]"]) {
          return false;
        }
        if ("[[Enumerable]]" in Desc && !SameValue(Desc["[[Enumerable]]"], current["[[Enumerable]]"])) {
          return false;
        }
        if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
          return false;
        }
        if (IsAccessorDescriptor(current)) {
          if ("[[Get]]" in Desc && !SameValue(Desc["[[Get]]"], current["[[Get]]"])) {
            return false;
          }
          if ("[[Set]]" in Desc && !SameValue(Desc["[[Set]]"], current["[[Set]]"])) {
            return false;
          }
        } else if (!current["[[Writable]]"]) {
          if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
            return false;
          }
          if ("[[Value]]" in Desc && !SameValue(Desc["[[Value]]"], current["[[Value]]"])) {
            return false;
          }
        }
      }
      if (oType !== "Undefined") {
        var configurable;
        var enumerable;
        if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O2,
            P2,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Get]]": ("[[Get]]" in Desc ? Desc : current)["[[Get]]"],
              "[[Set]]": ("[[Set]]" in Desc ? Desc : current)["[[Set]]"]
            }
          );
        } else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O2,
            P2,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Value]]": ("[[Value]]" in Desc ? Desc : current)["[[Value]]"],
              "[[Writable]]": !!("[[Writable]]" in Desc ? Desc : current)["[[Writable]]"]
            }
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O2,
          P2,
          Desc
        );
      }
      return true;
    };
  }
});

// ../../node_modules/es-abstract/2023/OrdinaryDefineOwnProperty.js
var require_OrdinaryDefineOwnProperty = __commonJS({
  "../../node_modules/es-abstract/2023/OrdinaryDefineOwnProperty.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = require_gopd();
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsExtensible = require_IsExtensible();
    var IsPropertyKey = require_IsPropertyKey();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var ValidateAndApplyPropertyDescriptor = require_ValidateAndApplyPropertyDescriptor();
    module2.exports = function OrdinaryDefineOwnProperty(O2, P2, Desc) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (!$gOPD) {
        if (IsAccessorDescriptor(Desc)) {
          throw new $SyntaxError("This environment does not support accessor property descriptors.");
        }
        var creatingNormalDataProperty = !(P2 in O2) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
        var settingExistingDataProperty = P2 in O2 && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
        if (creatingNormalDataProperty || settingExistingDataProperty) {
          O2[P2] = Desc["[[Value]]"];
          return SameValue(O2[P2], Desc["[[Value]]"]);
        }
        throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
      }
      var desc = $gOPD(O2, P2);
      var current = desc && ToPropertyDescriptor(desc);
      var extensible = IsExtensible(O2);
      return ValidateAndApplyPropertyDescriptor(O2, P2, extensible, Desc, current);
    };
  }
});

// ../../node_modules/es-abstract/2023/CreateDataProperty.js
var require_CreateDataProperty = __commonJS({
  "../../node_modules/es-abstract/2023/CreateDataProperty.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var OrdinaryDefineOwnProperty = require_OrdinaryDefineOwnProperty();
    var Type = require_Type2();
    module2.exports = function CreateDataProperty(O2, P2, V2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V2,
        "[[Writable]]": true
      };
      return OrdinaryDefineOwnProperty(O2, P2, newDesc);
    };
  }
});

// ../../node_modules/es-abstract/2023/CreateDataPropertyOrThrow.js
var require_CreateDataPropertyOrThrow = __commonJS({
  "../../node_modules/es-abstract/2023/CreateDataPropertyOrThrow.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var CreateDataProperty = require_CreateDataProperty();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module2.exports = function CreateDataPropertyOrThrow(O2, P2, V2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var success = CreateDataProperty(O2, P2, V2);
      if (!success) {
        throw new $TypeError("unable to create data property");
      }
    };
  }
});

// ../../node_modules/es-abstract/2023/CreateMethodProperty.js
var require_CreateMethodProperty = __commonJS({
  "../../node_modules/es-abstract/2023/CreateMethodProperty.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module2.exports = function CreateMethodProperty(O2, P2, V2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": false,
        "[[Value]]": V2,
        "[[Writable]]": true
      };
      return DefineOwnProperty(
        IsDataDescriptor,
        SameValue,
        FromPropertyDescriptor,
        O2,
        P2,
        newDesc
      );
    };
  }
});

// ../../node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "../../node_modules/object-inspect/util.inspect.js"(exports, module2) {
    "use strict";
    module2.exports = require("util").inspect;
  }
});

// ../../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/object-inspect/index.js"(exports, module2) {
    "use strict";
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag2 = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
      return O2.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i3 = 0; i3 < attrs.length; i3++) {
          s2 += " " + attrs[i3].name + "=" + wrapQuotes(quote(attrs[i3].value), "double", opts);
        }
        s2 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s2 += "...";
        }
        s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s2;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString3(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag2 && Object(obj) === obj && toStringTag2 in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s2, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s2 + quoteChar;
    }
    function quote(s2) {
      return $replace.call(String(s2), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag2 || !(typeof obj === "object" && toStringTag2 in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag2 || !(typeof obj === "object" && toStringTag2 in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag2 || !(typeof obj === "object" && toStringTag2 in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag2 || !(typeof obj === "object" && toStringTag2 in obj));
    }
    function isString3(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag2 || !(typeof obj === "object" && toStringTag2 in obj));
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag2 || !(typeof obj === "object" && toStringTag2 in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag2 || !(typeof obj === "object" && toStringTag2 in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f2) {
      if (f2.name) {
        return f2.name;
      }
      var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
      if (m2) {
        return m2[1];
      }
      return null;
    }
    function indexOf(xs, x3) {
      if (xs.indexOf) {
        return xs.indexOf(x3);
      }
      for (var i3 = 0, l2 = xs.length; i3 < l2; i3++) {
        if (xs[i3] === x3) {
          return i3;
        }
      }
      return -1;
    }
    function isMap(x3) {
      if (!mapSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        mapSize.call(x3);
        try {
          setSize.call(x3);
        } catch (s2) {
          return true;
        }
        return x3 instanceof Map;
      } catch (e3) {
      }
      return false;
    }
    function isWeakMap(x3) {
      if (!weakMapHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x3, weakMapHas);
        try {
          weakSetHas.call(x3, weakSetHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakMap;
      } catch (e3) {
      }
      return false;
    }
    function isWeakRef(x3) {
      if (!weakRefDeref || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x3);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isSet(x3) {
      if (!setSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        setSize.call(x3);
        try {
          mapSize.call(x3);
        } catch (m2) {
          return true;
        }
        return x3 instanceof Set;
      } catch (e3) {
      }
      return false;
    }
    function isWeakSet(x3) {
      if (!weakSetHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x3, weakSetHas);
        try {
          weakMapHas.call(x3, weakMapHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakSet;
      } catch (e3) {
      }
      return false;
    }
    function isElement(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x3 instanceof HTMLElement) {
        return true;
      }
      return typeof x3.nodeName === "string" && typeof x3.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s2, "single", opts);
    }
    function lowbyte(c2) {
      var n3 = c2.charCodeAt(0);
      var x3 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n3];
      if (x3) {
        return "\\" + x3;
      }
      return "\\x" + (n3 < 16 ? "0" : "") + $toUpperCase.call(n3.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i3 = 0; i3 < xs.length; i3++) {
        if (indexOf(xs[i3], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i3 = 0; i3 < obj.length; i3++) {
          xs[i3] = has(obj, i3) ? inspect(obj[i3], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k2 = 0; k2 < syms.length; k2++) {
          symMap["$" + syms[k2]] = syms[k2];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j2 = 0; j2 < syms.length; j2++) {
          if (isEnumerable.call(obj, syms[j2])) {
            xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../../node_modules/es-abstract/helpers/isLeadingSurrogate.js
var require_isLeadingSurrogate = __commonJS({
  "../../node_modules/es-abstract/helpers/isLeadingSurrogate.js"(exports, module2) {
    "use strict";
    module2.exports = function isLeadingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 55296 && charCode <= 56319;
    };
  }
});

// ../../node_modules/es-abstract/helpers/isTrailingSurrogate.js
var require_isTrailingSurrogate = __commonJS({
  "../../node_modules/es-abstract/helpers/isTrailingSurrogate.js"(exports, module2) {
    "use strict";
    module2.exports = function isTrailingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 56320 && charCode <= 57343;
    };
  }
});

// ../../node_modules/es-abstract/2023/UTF16SurrogatePairToCodePoint.js
var require_UTF16SurrogatePairToCodePoint = __commonJS({
  "../../node_modules/es-abstract/2023/UTF16SurrogatePairToCodePoint.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $fromCharCode = GetIntrinsic("%String.fromCharCode%");
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    module2.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
      if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
        throw new $TypeError("Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code");
      }
      return $fromCharCode(lead) + $fromCharCode(trail);
    };
  }
});

// ../../node_modules/es-abstract/2023/CodePointAt.js
var require_CodePointAt = __commonJS({
  "../../node_modules/es-abstract/2023/CodePointAt.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var callBound = require_callBound();
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    var Type = require_Type2();
    var UTF16SurrogatePairToCodePoint = require_UTF16SurrogatePairToCodePoint();
    var $charAt = callBound("String.prototype.charAt");
    var $charCodeAt = callBound("String.prototype.charCodeAt");
    module2.exports = function CodePointAt(string, position) {
      if (Type(string) !== "String") {
        throw new $TypeError("Assertion failed: `string` must be a String");
      }
      var size = string.length;
      if (position < 0 || position >= size) {
        throw new $TypeError("Assertion failed: `position` must be >= 0, and < the length of `string`");
      }
      var first = $charCodeAt(string, position);
      var cp = $charAt(string, position);
      var firstIsLeading = isLeadingSurrogate(first);
      var firstIsTrailing = isTrailingSurrogate(first);
      if (!firstIsLeading && !firstIsTrailing) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": false
        };
      }
      if (firstIsTrailing || position + 1 === size) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      var second = $charCodeAt(string, position + 1);
      if (!isTrailingSurrogate(second)) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      return {
        "[[CodePoint]]": UTF16SurrogatePairToCodePoint(first, second),
        "[[CodeUnitCount]]": 2,
        "[[IsUnpairedSurrogate]]": false
      };
    };
  }
});

// ../../node_modules/es-abstract/helpers/maxSafeInteger.js
var require_maxSafeInteger = __commonJS({
  "../../node_modules/es-abstract/helpers/maxSafeInteger.js"(exports, module2) {
    "use strict";
    module2.exports = Number.MAX_SAFE_INTEGER || 9007199254740991;
  }
});

// ../../node_modules/es-abstract/2023/AdvanceStringIndex.js
var require_AdvanceStringIndex = __commonJS({
  "../../node_modules/es-abstract/2023/AdvanceStringIndex.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var CodePointAt = require_CodePointAt();
    var Type = require_Type2();
    var isInteger = require_isInteger();
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function AdvanceStringIndex(S2, index3, unicode) {
      if (Type(S2) !== "String") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      if (!isInteger(index3) || index3 < 0 || index3 > MAX_SAFE_INTEGER) {
        throw new $TypeError("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
      }
      if (Type(unicode) !== "Boolean") {
        throw new $TypeError("Assertion failed: `unicode` must be a Boolean");
      }
      if (!unicode) {
        return index3 + 1;
      }
      var length = S2.length;
      if (index3 + 1 >= length) {
        return index3 + 1;
      }
      var cp = CodePointAt(S2, index3);
      return index3 + cp["[[CodeUnitCount]]"];
    };
  }
});

// ../../node_modules/es-abstract/2023/CreateIterResultObject.js
var require_CreateIterResultObject = __commonJS({
  "../../node_modules/es-abstract/2023/CreateIterResultObject.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type2();
    module2.exports = function CreateIterResultObject(value, done) {
      if (Type(done) !== "Boolean") {
        throw new $TypeError("Assertion failed: Type(done) is not Boolean");
      }
      return {
        value,
        done
      };
    };
  }
});

// ../../node_modules/es-abstract/2023/Get.js
var require_Get = __commonJS({
  "../../node_modules/es-abstract/2023/Get.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module2.exports = function Get(O2, P2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P2));
      }
      return O2[P2];
    };
  }
});

// ../../node_modules/es-abstract/2023/IteratorComplete.js
var require_IteratorComplete = __commonJS({
  "../../node_modules/es-abstract/2023/IteratorComplete.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Get = require_Get();
    var ToBoolean = require_ToBoolean();
    var Type = require_Type2();
    module2.exports = function IteratorComplete(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return ToBoolean(Get(iterResult, "done"));
    };
  }
});

// ../../node_modules/es-abstract/2023/IteratorValue.js
var require_IteratorValue = __commonJS({
  "../../node_modules/es-abstract/2023/IteratorValue.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Get = require_Get();
    var Type = require_Type2();
    module2.exports = function IteratorValue(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return Get(iterResult, "value");
    };
  }
});

// ../../node_modules/es-abstract/2023/PromiseResolve.js
var require_PromiseResolve = __commonJS({
  "../../node_modules/es-abstract/2023/PromiseResolve.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $resolve = GetIntrinsic("%Promise.resolve%", true);
    var $PromiseResolve = $resolve && callBind($resolve);
    module2.exports = function PromiseResolve(C2, x3) {
      if (!$PromiseResolve) {
        throw new SyntaxError("This environment does not support Promises.");
      }
      return $PromiseResolve(C2, x3);
    };
  }
});

// ../../node_modules/es-abstract/2023/AsyncFromSyncIteratorContinuation.js
var require_AsyncFromSyncIteratorContinuation = __commonJS({
  "../../node_modules/es-abstract/2023/AsyncFromSyncIteratorContinuation.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var $Promise = GetIntrinsic("%Promise%", true);
    var callBound = require_callBound();
    var CreateIterResultObject = require_CreateIterResultObject();
    var IteratorComplete = require_IteratorComplete();
    var IteratorValue = require_IteratorValue();
    var PromiseResolve = require_PromiseResolve();
    var Type = require_Type2();
    var $then = callBound("Promise.prototype.then", true);
    module2.exports = function AsyncFromSyncIteratorContinuation(result) {
      if (Type(result) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (arguments.length > 1) {
        throw new $SyntaxError("although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation");
      }
      if (!$Promise) {
        throw new $SyntaxError("This environment does not support Promises.");
      }
      return new Promise(function(resolve3) {
        var done = IteratorComplete(result);
        var value = IteratorValue(result);
        var valueWrapper = PromiseResolve($Promise, value);
        var onFulfilled = function(value2) {
          return CreateIterResultObject(value2, done);
        };
        resolve3($then(valueWrapper, onFulfilled));
      });
    };
  }
});

// ../../node_modules/es-abstract/2023/IsArray.js
var require_IsArray2 = __commonJS({
  "../../node_modules/es-abstract/2023/IsArray.js"(exports, module2) {
    "use strict";
    module2.exports = require_IsArray();
  }
});

// ../../node_modules/es-abstract/2023/Call.js
var require_Call = __commonJS({
  "../../node_modules/es-abstract/2023/Call.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsArray = require_IsArray2();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("Function.prototype.apply");
    module2.exports = function Call(F2, V2) {
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      return $apply(F2, V2, argumentsList);
    };
  }
});

// ../../node_modules/es-abstract/2023/GetV.js
var require_GetV = __commonJS({
  "../../node_modules/es-abstract/2023/GetV.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    module2.exports = function GetV(V2, P2) {
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P2));
      }
      return V2[P2];
    };
  }
});

// ../../node_modules/es-abstract/2023/GetMethod.js
var require_GetMethod = __commonJS({
  "../../node_modules/es-abstract/2023/GetMethod.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var GetV = require_GetV();
    var IsCallable = require_IsCallable();
    var IsPropertyKey = require_IsPropertyKey();
    var inspect = require_object_inspect();
    module2.exports = function GetMethod(O2, P2) {
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var func = GetV(O2, P2);
      if (func == null) {
        return void 0;
      }
      if (!IsCallable(func)) {
        throw new $TypeError(inspect(P2) + " is not a function: " + inspect(func));
      }
      return func;
    };
  }
});

// ../../node_modules/es-abstract/2023/IteratorNext.js
var require_IteratorNext = __commonJS({
  "../../node_modules/es-abstract/2023/IteratorNext.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Call = require_Call();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IteratorNext(iteratorRecord) {
      assertRecord(Type, "Iterator Record", "iteratorRecord", iteratorRecord);
      var result;
      if (arguments.length < 2) {
        result = Call(iteratorRecord["[[NextMethod]]"], iteratorRecord["[[Iterator]]"]);
      } else {
        result = Call(iteratorRecord["[[NextMethod]]"], iteratorRecord["[[Iterator]]"], [arguments[1]]);
      }
      if (Type(result) !== "Object") {
        throw new $TypeError("iterator next must return an object");
      }
      return result;
    };
  }
});

// ../../node_modules/es-abstract/helpers/forEach.js
var require_forEach = __commonJS({
  "../../node_modules/es-abstract/helpers/forEach.js"(exports, module2) {
    "use strict";
    module2.exports = function forEach(array, callback) {
      for (var i3 = 0; i3 < array.length; i3 += 1) {
        callback(array[i3], i3, array);
      }
    };
  }
});

// ../../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/side-channel/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../../node_modules/internal-slot/index.js
var require_internal_slot = __commonJS({
  "../../node_modules/internal-slot/index.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var hasOwn = require_hasown();
    var channel = require_side_channel()();
    var $TypeError = GetIntrinsic("%TypeError%");
    var SLOT = {
      assert: function(O2, slot) {
        if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O2);
        if (!SLOT.has(O2, slot)) {
          throw new $TypeError("`" + slot + "` is not present on `O`");
        }
      },
      get: function(O2, slot) {
        if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O2);
        return slots && slots["$" + slot];
      },
      has: function(O2, slot) {
        if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O2);
        return !!slots && hasOwn(slots, "$" + slot);
      },
      set: function(O2, slot, V2) {
        if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O2);
        if (!slots) {
          slots = {};
          channel.set(O2, slots);
        }
        slots["$" + slot] = V2;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module2.exports = SLOT;
  }
});

// ../../node_modules/es-abstract/2023/OrdinaryObjectCreate.js
var require_OrdinaryObjectCreate = __commonJS({
  "../../node_modules/es-abstract/2023/OrdinaryObjectCreate.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $ObjectCreate = GetIntrinsic("%Object.create%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var IsArray = require_IsArray2();
    var Type = require_Type2();
    var forEach = require_forEach();
    var SLOT = require_internal_slot();
    var hasProto = require_has_proto()();
    module2.exports = function OrdinaryObjectCreate(proto) {
      if (proto !== null && Type(proto) !== "Object") {
        throw new $TypeError("Assertion failed: `proto` must be null or an object");
      }
      var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
      if (!IsArray(additionalInternalSlotsList)) {
        throw new $TypeError("Assertion failed: `additionalInternalSlotsList` must be an Array");
      }
      var O2;
      if ($ObjectCreate) {
        O2 = $ObjectCreate(proto);
      } else if (hasProto) {
        O2 = { __proto__: proto };
      } else {
        if (proto === null) {
          throw new $SyntaxError("native Object.create support is required to create null objects");
        }
        var T2 = function T3() {
        };
        T2.prototype = proto;
        O2 = new T2();
      }
      if (additionalInternalSlotsList.length > 0) {
        forEach(additionalInternalSlotsList, function(slot) {
          SLOT.set(O2, slot, void 0);
        });
      }
      return O2;
    };
  }
});

// ../../node_modules/es-abstract/2023/CreateAsyncFromSyncIterator.js
var require_CreateAsyncFromSyncIterator = __commonJS({
  "../../node_modules/es-abstract/2023/CreateAsyncFromSyncIterator.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var AsyncFromSyncIteratorContinuation = require_AsyncFromSyncIteratorContinuation();
    var Call = require_Call();
    var CreateIterResultObject = require_CreateIterResultObject();
    var Get = require_Get();
    var GetMethod = require_GetMethod();
    var IteratorNext = require_IteratorNext();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    var assertRecord = require_assertRecord();
    var $AsyncFromSyncIteratorPrototype = GetIntrinsic("%AsyncFromSyncIteratorPrototype%", true) || {
      next: function next(value) {
        var O2 = this;
        SLOT.assert(O2, "[[SyncIteratorRecord]]");
        var argsLength = arguments.length;
        return new Promise(function(resolve3) {
          var syncIteratorRecord = SLOT.get(O2, "[[SyncIteratorRecord]]");
          var result;
          if (argsLength > 0) {
            result = IteratorNext(syncIteratorRecord, value);
          } else {
            result = IteratorNext(syncIteratorRecord);
          }
          resolve3(AsyncFromSyncIteratorContinuation(result));
        });
      },
      "return": function() {
        var O2 = this;
        SLOT.assert(O2, "[[SyncIteratorRecord]]");
        var valueIsPresent = arguments.length > 0;
        var value = valueIsPresent ? arguments[0] : void 0;
        return new Promise(function(resolve3, reject) {
          var syncIterator = SLOT.get(O2, "[[SyncIteratorRecord]]")["[[Iterator]]"];
          var iteratorReturn = GetMethod(syncIterator, "return");
          if (typeof iteratorReturn === "undefined") {
            var iterResult = CreateIterResultObject(value, true);
            Call(resolve3, void 0, [iterResult]);
            return;
          }
          var result;
          if (valueIsPresent) {
            result = Call(iteratorReturn, syncIterator, [value]);
          } else {
            result = Call(iteratorReturn, syncIterator);
          }
          if (Type(result) !== "Object") {
            Call(reject, void 0, [new $TypeError("Iterator `return` method returned a non-object value.")]);
            return;
          }
          resolve3(AsyncFromSyncIteratorContinuation(result));
        });
      },
      "throw": function() {
        var O2 = this;
        SLOT.assert(O2, "[[SyncIteratorRecord]]");
        var valueIsPresent = arguments.length > 0;
        var value = valueIsPresent ? arguments[0] : void 0;
        return new Promise(function(resolve3, reject) {
          var syncIterator = SLOT.get(O2, "[[SyncIteratorRecord]]")["[[Iterator]]"];
          var throwMethod = GetMethod(syncIterator, "throw");
          if (typeof throwMethod === "undefined") {
            Call(reject, void 0, [value]);
            return;
          }
          var result;
          if (valueIsPresent) {
            result = Call(throwMethod, syncIterator, [value]);
          } else {
            result = Call(throwMethod, syncIterator);
          }
          if (Type(result) !== "Object") {
            Call(reject, void 0, [new $TypeError("Iterator `throw` method returned a non-object value.")]);
            return;
          }
          resolve3(AsyncFromSyncIteratorContinuation(
            result
            /* , promiseCapability */
          ));
        });
      }
    };
    module2.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
      assertRecord(Type, "Iterator Record", "syncIteratorRecord", syncIteratorRecord);
      var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);
      SLOT.set(asyncIterator, "[[SyncIteratorRecord]]", syncIteratorRecord);
      var nextMethod = Get(asyncIterator, "next");
      return {
        // steps 3-4
        "[[Iterator]]": asyncIterator,
        "[[NextMethod]]": nextMethod,
        "[[Done]]": false
      };
    };
  }
});

// ../../node_modules/es-abstract/2023/GetIteratorFromMethod.js
var require_GetIteratorFromMethod = __commonJS({
  "../../node_modules/es-abstract/2023/GetIteratorFromMethod.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Call = require_Call();
    var GetV = require_GetV();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module2.exports = function GetIteratorFromMethod(obj, method) {
      if (!IsCallable(method)) {
        throw new $TypeError("method must be a function");
      }
      var iterator = Call(method, obj);
      if (Type(iterator) !== "Object") {
        throw new $TypeError("iterator must return an object");
      }
      var nextMethod = GetV(iterator, "next");
      return {
        // steps 4-5
        "[[Iterator]]": iterator,
        "[[NextMethod]]": nextMethod,
        "[[Done]]": false
      };
    };
  }
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/has-tostringtag/shams.js"(exports, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/is-string/index.js
var require_is_string = __commonJS({
  "../../node_modules/is-string/index.js"(exports, module2) {
    "use strict";
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e3) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isString3(value) {
      if (typeof value === "string") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    };
  }
});

// ../../node_modules/es-abstract/helpers/getIteratorMethod.js
var require_getIteratorMethod = __commonJS({
  "../../node_modules/es-abstract/helpers/getIteratorMethod.js"(exports, module2) {
    "use strict";
    var hasSymbols = require_has_symbols()();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var isString3 = require_is_string();
    var $iterator = GetIntrinsic("%Symbol.iterator%", true);
    var $stringSlice = callBound("String.prototype.slice");
    var $String = GetIntrinsic("%String%");
    module2.exports = function getIteratorMethod(ES, iterable) {
      var usingIterator;
      if (hasSymbols) {
        usingIterator = ES.GetMethod(iterable, $iterator);
      } else if (ES.IsArray(iterable)) {
        usingIterator = function() {
          var i3 = -1;
          var arr = this;
          return {
            next: function() {
              i3 += 1;
              return {
                done: i3 >= arr.length,
                value: arr[i3]
              };
            }
          };
        };
      } else if (isString3(iterable)) {
        usingIterator = function() {
          var i3 = 0;
          return {
            next: function() {
              var nextIndex = ES.AdvanceStringIndex($String(iterable), i3, true);
              var value = $stringSlice(iterable, i3, nextIndex);
              i3 = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        };
      }
      return usingIterator;
    };
  }
});

// ../../node_modules/es-abstract/2023/GetIterator.js
var require_GetIterator = __commonJS({
  "../../node_modules/es-abstract/2023/GetIterator.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $asyncIterator = GetIntrinsic("%Symbol.asyncIterator%", true);
    var inspect = require_object_inspect();
    var hasSymbols = require_has_symbols()();
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var CreateAsyncFromSyncIterator = require_CreateAsyncFromSyncIterator();
    var GetIteratorFromMethod = require_GetIteratorFromMethod();
    var GetMethod = require_GetMethod();
    var IsArray = require_IsArray2();
    var getIteratorMethod = require_getIteratorMethod();
    module2.exports = function GetIterator(obj, kind) {
      if (kind !== "sync" && kind !== "async") {
        throw new $TypeError("Assertion failed: `kind` must be one of 'sync' or 'async', got " + inspect(kind));
      }
      var method;
      if (kind === "async") {
        if (hasSymbols && $asyncIterator) {
          method = GetMethod(obj, $asyncIterator);
        }
      }
      if (typeof method === "undefined") {
        var syncMethod = getIteratorMethod(
          {
            AdvanceStringIndex,
            GetMethod,
            IsArray
          },
          obj
        );
        if (kind === "async") {
          if (typeof syncMethod === "undefined") {
            throw new $TypeError("iterator method is `undefined`");
          }
          var syncIteratorRecord = GetIteratorFromMethod(obj, syncMethod);
          return CreateAsyncFromSyncIterator(syncIteratorRecord);
        }
        method = syncMethod;
      }
      if (typeof method === "undefined") {
        throw new $TypeError("iterator method is `undefined`");
      }
      return GetIteratorFromMethod(obj, method);
    };
  }
});

// ../../node_modules/es-abstract/2023/IteratorStep.js
var require_IteratorStep = __commonJS({
  "../../node_modules/es-abstract/2023/IteratorStep.js"(exports, module2) {
    "use strict";
    var IteratorComplete = require_IteratorComplete();
    var IteratorNext = require_IteratorNext();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IteratorStep(iteratorRecord) {
      assertRecord(Type, "Iterator Record", "iteratorRecord", iteratorRecord);
      var result = IteratorNext(iteratorRecord);
      var done = IteratorComplete(result);
      return done === true ? false : result;
    };
  }
});

// ../../node_modules/es-abstract/2023/IteratorToList.js
var require_IteratorToList = __commonJS({
  "../../node_modules/es-abstract/2023/IteratorToList.js"(exports, module2) {
    "use strict";
    var callBound = require_callBound();
    var $arrayPush = callBound("Array.prototype.push");
    var IteratorStep = require_IteratorStep();
    var IteratorValue = require_IteratorValue();
    var Type = require_Type2();
    var assertRecord = require_assertRecord();
    module2.exports = function IteratorToList(iteratorRecord) {
      assertRecord(Type, "Iterator Record", "iteratorRecord", iteratorRecord);
      var values = [];
      var next = true;
      while (next) {
        next = IteratorStep(iteratorRecord);
        if (next) {
          var nextValue = IteratorValue(next);
          $arrayPush(values, nextValue);
        }
      }
      return values;
    };
  }
});

// ../../node_modules/es-abstract/helpers/setProto.js
var require_setProto = __commonJS({
  "../../node_modules/es-abstract/helpers/setProto.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var originalSetProto = GetIntrinsic("%Object.setPrototypeOf%", true);
    var hasProto = require_has_proto()();
    module2.exports = originalSetProto || (hasProto ? function(O2, proto) {
      O2.__proto__ = proto;
      return O2;
    } : null);
  }
});

// ../../node_modules/es-abstract/helpers/getProto.js
var require_getProto = __commonJS({
  "../../node_modules/es-abstract/helpers/getProto.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var originalGetProto = GetIntrinsic("%Object.getPrototypeOf%", true);
    var hasProto = require_has_proto()();
    module2.exports = originalGetProto || (hasProto ? function(O2) {
      return O2.__proto__;
    } : null);
  }
});

// ../../node_modules/es-abstract/2023/OrdinaryGetPrototypeOf.js
var require_OrdinaryGetPrototypeOf = __commonJS({
  "../../node_modules/es-abstract/2023/OrdinaryGetPrototypeOf.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $getProto = require_getProto();
    var Type = require_Type2();
    module2.exports = function OrdinaryGetPrototypeOf(O2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!$getProto) {
        throw new $TypeError("This environment does not support fetching prototypes.");
      }
      return $getProto(O2);
    };
  }
});

// ../../node_modules/es-abstract/2023/OrdinarySetPrototypeOf.js
var require_OrdinarySetPrototypeOf = __commonJS({
  "../../node_modules/es-abstract/2023/OrdinarySetPrototypeOf.js"(exports, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $setProto = require_setProto();
    var OrdinaryGetPrototypeOf = require_OrdinaryGetPrototypeOf();
    var Type = require_Type2();
    module2.exports = function OrdinarySetPrototypeOf(O2, V2) {
      if (Type(V2) !== "Object" && Type(V2) !== "Null") {
        throw new $TypeError("Assertion failed: V must be Object or Null");
      }
      try {
        $setProto(O2, V2);
      } catch (e3) {
        return false;
      }
      return OrdinaryGetPrototypeOf(O2) === V2;
    };
  }
});

// ../../node_modules/es-aggregate-error/implementation.js
var require_implementation3 = __commonJS({
  "../../node_modules/es-aggregate-error/implementation.js"(exports, module2) {
    "use strict";
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow();
    var CreateMethodProperty = require_CreateMethodProperty();
    var GetIterator = require_GetIterator();
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var IteratorToList = require_IteratorToList();
    var OrdinarySetPrototypeOf = require_OrdinarySetPrototypeOf();
    var GetIntrinsic = require_get_intrinsic();
    var $Error = GetIntrinsic("%Error%");
    function AggregateError2(errors, message) {
      var error = new $Error(message);
      OrdinarySetPrototypeOf(error, proto);
      delete error.constructor;
      var errorsList = IteratorToList(GetIterator(errors, "sync"));
      CreateDataPropertyOrThrow(error, "errors", errorsList);
      return error;
    }
    if (hasPropertyDescriptors) {
      Object.defineProperty(AggregateError2, "prototype", { writable: false });
    }
    var proto = AggregateError2.prototype;
    if (!CreateMethodProperty(proto, "constructor", AggregateError2) || !CreateMethodProperty(proto, "message", "") || !CreateMethodProperty(proto, "name", "AggregateError")) {
      throw new $Error("unable to install AggregateError.prototype properties; please report this!");
    }
    OrdinarySetPrototypeOf(AggregateError2.prototype, Error.prototype);
    module2.exports = AggregateError2;
  }
});

// ../../node_modules/es-aggregate-error/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/es-aggregate-error/polyfill.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      return typeof AggregateError === "function" ? AggregateError : implementation;
    };
  }
});

// ../../node_modules/globalthis/implementation.js
var require_implementation4 = __commonJS({
  "../../node_modules/globalthis/implementation.js"(exports, module2) {
    "use strict";
    module2.exports = global;
  }
});

// ../../node_modules/globalthis/polyfill.js
var require_polyfill2 = __commonJS({
  "../../node_modules/globalthis/polyfill.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation4();
    module2.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// ../../node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "../../node_modules/globalthis/shim.js"(exports, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill2();
    module2.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define2.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// ../../node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "../../node_modules/globalthis/index.js"(exports, module2) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = getGlobal;
  }
});

// ../../node_modules/es-aggregate-error/shim.js
var require_shim2 = __commonJS({
  "../../node_modules/es-aggregate-error/shim.js"(exports, module2) {
    "use strict";
    var define2 = require_define_properties();
    var globalThis2 = require_globalthis()();
    var getPolyfill = require_polyfill();
    module2.exports = function shimAggregateError() {
      var polyfill = getPolyfill();
      define2(
        globalThis2,
        { AggregateError: polyfill },
        {
          AggregateError: function testAggregateError() {
            return globalThis2.AggregateError !== polyfill;
          }
        }
      );
      return polyfill;
    };
  }
});

// ../../node_modules/es-aggregate-error/index.js
var require_es_aggregate_error = __commonJS({
  "../../node_modules/es-aggregate-error/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    var define2 = require_define_properties();
    var setFunctionName = require_set_function_name();
    var defineDataProperty = require_define_data_property();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim2();
    var polyfill = getPolyfill();
    var bound = setFunctionName(bind.call(polyfill), polyfill.name, true);
    defineDataProperty(bound, "prototype", polyfill.prototype, true, true, true, true);
    define2(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/validators/common/error.js
var require_error = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/validators/common/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toParsedPath = exports.wrapError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var lodash_1 = require_lodash();
    var es_aggregate_error_1 = (0, tslib_1.__importDefault)(require_es_aggregate_error());
    var errors_1 = require_errors();
    var isAggregateError_1 = require_isAggregateError();
    function toRulesetValidationError(ex) {
      if (ex instanceof errors_1.RulesetValidationError) {
        ex.path.unshift(...this);
        return ex;
      }
      return new errors_1.RulesetValidationError("generic-validation-error", (0, lodash_1.isError)(ex) ? ex.message : String(ex), [...this]);
    }
    function wrapError(ex, path2) {
      const parsedPath = toParsedPath(path2);
      if ((0, isAggregateError_1.isAggregateError)(ex)) {
        return new es_aggregate_error_1.default(ex.errors.map(toRulesetValidationError, parsedPath));
      }
      return toRulesetValidationError.call(parsedPath, ex);
    }
    exports.wrapError = wrapError;
    function toParsedPath(path2) {
      return path2.slice(1).split("/");
    }
    exports.toParsedPath = toParsedPath;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/validators/alias.js
var require_alias2 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/validators/alias.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAlias = void 0;
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var lodash_1 = require_lodash();
    var alias_1 = require_alias();
    var formats_1 = require_formats();
    var error_1 = require_error();
    var errors_1 = require_errors();
    function getOverrides(overrides, key) {
      if (!Array.isArray(overrides))
        return null;
      const index3 = Number(key);
      if (Number.isNaN(index3))
        return null;
      if (index3 < 0 && index3 >= overrides.length)
        return null;
      const actualOverrides = overrides[index3];
      return (0, json_1.isPlainObject)(actualOverrides) && (0, json_1.isPlainObject)(actualOverrides.aliases) ? actualOverrides.aliases : null;
    }
    function validateAlias(ruleset, alias, path2) {
      const parsedPath = (0, error_1.toParsedPath)(path2);
      try {
        const formats = (0, lodash_1.get)(ruleset, [...parsedPath.slice(0, parsedPath.indexOf("rules") + 2), "formats"]);
        const aliases = parsedPath[0] === "overrides" ? {
          ...ruleset.aliases,
          ...getOverrides(ruleset.overrides, parsedPath[1])
        } : ruleset.aliases;
        (0, alias_1.resolveAlias)(aliases !== null && aliases !== void 0 ? aliases : null, alias, Array.isArray(formats) ? new formats_1.Formats(formats) : null);
      } catch (ex) {
        if (ex instanceof ReferenceError) {
          return new errors_1.RulesetValidationError("undefined-alias", ex.message, parsedPath);
        }
        return (0, error_1.wrapError)(ex, path2);
      }
    }
    exports.validateAlias = validateAlias;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/validators/function.js
var require_function = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/validators/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateFunction = void 0;
    var error_1 = require_error();
    var errors_1 = require_errors();
    function assertRulesetFunction(maybeRulesetFunction) {
      if (typeof maybeRulesetFunction !== "function") {
        throw ReferenceError("Function is not defined");
      }
    }
    function validateFunction(fn, opts, path2) {
      try {
        assertRulesetFunction(fn);
        if (!("validator" in fn))
          return;
        const validator = fn.validator.bind(fn);
        validator(opts);
      } catch (ex) {
        if (ex instanceof ReferenceError) {
          return new errors_1.RulesetValidationError("undefined-function", ex.message, [...(0, error_1.toParsedPath)(path2), "function"]);
        }
        return (0, error_1.wrapError)(ex, path2);
      }
    }
    exports.validateFunction = validateFunction;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/ajv.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createValidator = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ajv_1 = (0, tslib_1.__importStar)(require("ajv"));
    var names_1 = (0, tslib_1.__importDefault)(require("ajv/dist/compile/names"));
    var ajv_formats_1 = (0, tslib_1.__importDefault)(require_dist8());
    var ajv_errors_1 = (0, tslib_1.__importDefault)(require_dist9());
    var ruleSchema = (0, tslib_1.__importStar)(require_rule_schema());
    var shared = (0, tslib_1.__importStar)(require_shared());
    var rulesetSchema = (0, tslib_1.__importStar)(require_ruleset_schema());
    var jsExtensions = (0, tslib_1.__importStar)(require_js_extensions());
    var jsonExtensions = (0, tslib_1.__importStar)(require_json_extensions());
    var alias_1 = require_alias2();
    var function_1 = require_function();
    var validators = {
      js: null,
      json: null
    };
    function createValidator(format2) {
      const existingValidator = validators[format2];
      if (existingValidator !== null) {
        return existingValidator;
      }
      const ajv = new ajv_1.default({
        allErrors: true,
        strict: true,
        strictRequired: false,
        keywords: ["$anchor"],
        schemas: [ruleSchema, shared],
        passContext: true
      });
      (0, ajv_formats_1.default)(ajv);
      (0, ajv_errors_1.default)(ajv);
      ajv.addKeyword({
        keyword: "x-spectral-runtime",
        schemaType: "string",
        error: {
          message(cxt) {
            var _a;
            return (0, ajv_1._)`${((_a = cxt.params) === null || _a === void 0 ? void 0 : _a.message) !== void 0 ? cxt.params.message : ""}`;
          },
          params(cxt) {
            var _a;
            return (0, ajv_1._)`{ errors: ${((_a = cxt.params) === null || _a === void 0 ? void 0 : _a.errors) !== void 0 && cxt.params.errors} || [] }`;
          }
        },
        code(cxt) {
          const { data } = cxt;
          switch (cxt.schema) {
            case "format":
              cxt.fail((0, ajv_1._)`typeof ${data} !== "function"`);
              break;
            case "ruleset-function": {
              const fn = cxt.gen.const("spectralFunction", (0, ajv_1._)`this.validateFunction(${data}.function, ${data}.functionOptions === void 0 ? null : ${data}.functionOptions, ${names_1.default.instancePath})`);
              cxt.gen.if((0, ajv_1._)`${fn} !== void 0`);
              cxt.error(false, { errors: fn });
              cxt.gen.endIf();
              break;
            }
            case "alias": {
              const alias = cxt.gen.const("spectralAlias", (0, ajv_1._)`this.validateAlias(${names_1.default.rootData}, ${data}, ${names_1.default.instancePath})`);
              cxt.gen.if((0, ajv_1._)`${alias} !== void 0`);
              cxt.error(false, { errors: alias });
              cxt.gen.endIf();
              break;
            }
          }
        }
      });
      if (format2 === "js") {
        ajv.addSchema(jsExtensions);
      } else {
        ajv.addSchema(jsonExtensions);
      }
      const validator = new Proxy(ajv.compile(rulesetSchema), {
        apply(target, thisArg, args) {
          return Reflect.apply(target, { validateAlias: alias_1.validateAlias, validateFunction: function_1.validateFunction }, args);
        }
      });
      validators[format2] = validator;
      return validator;
    }
    exports.createValidator = createValidator;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/assertions.js
var require_assertions = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/assertions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertValidRule = exports.assertValidRuleset = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var ajv_1 = require_ajv();
    var errors_1 = require_errors();
    var es_aggregate_error_1 = (0, tslib_1.__importDefault)(require_es_aggregate_error());
    function assertValidRuleset(ruleset, format2 = "js") {
      var _a;
      if (!(0, json_1.isPlainObject)(ruleset)) {
        throw new errors_1.RulesetValidationError("invalid-ruleset-definition", "Provided ruleset is not an object", []);
      }
      if (!("rules" in ruleset) && !("extends" in ruleset) && !("overrides" in ruleset)) {
        throw new errors_1.RulesetValidationError("invalid-ruleset-definition", "Ruleset must have rules or extends or overrides defined", []);
      }
      const validate = (0, ajv_1.createValidator)(format2);
      if (!validate(ruleset)) {
        throw new es_aggregate_error_1.default((0, errors_1.convertAjvErrors)((_a = validate.errors) !== null && _a !== void 0 ? _a : []));
      }
    }
    exports.assertValidRuleset = assertValidRuleset;
    function isRuleDefinition(rule) {
      return typeof rule === "object" && rule !== null && !Array.isArray(rule) && ("given" in rule || "then" in rule);
    }
    function assertValidRule(rule, name) {
      if (!isRuleDefinition(rule)) {
        throw new errors_1.RulesetValidationError("invalid-rule-definition", "Rule definition expected", ["rules", name]);
      }
    }
    exports.assertValidRule = assertValidRule;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/index.js
var require_validation = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertValidRuleset = exports.RulesetValidationError = void 0;
    var errors_1 = require_errors();
    Object.defineProperty(exports, "RulesetValidationError", { enumerable: true, get: function() {
      return errors_1.RulesetValidationError;
    } });
    var assertions_1 = require_assertions();
    Object.defineProperty(exports, "assertValidRuleset", { enumerable: true, get: function() {
      return assertions_1.assertValidRuleset;
    } });
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/mergers/rules.js
var require_rules = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/mergers/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeRule = void 0;
    var assertions_1 = require_assertions();
    var rule_1 = require_rule();
    function assertExistingRule(maybeRule, name) {
      if (maybeRule === void 0) {
        throw new ReferenceError(`Cannot extend non-existing rule: "${name}"`);
      }
    }
    function mergeRule(existingRule, name, rule, ruleset) {
      switch (typeof rule) {
        case "boolean":
          assertExistingRule(existingRule, name);
          existingRule.enabled = rule;
          break;
        case "string":
        case "number":
          assertExistingRule(existingRule, name);
          existingRule.severity = rule;
          if (rule === "off") {
            existingRule.enabled = false;
          } else if (!existingRule.enabled) {
            existingRule.enabled = true;
          }
          break;
        case "object":
          if (existingRule !== void 0) {
            Object.assign(existingRule, rule, {
              enabled: true,
              owner: existingRule.owner
            });
          } else {
            (0, assertions_1.assertValidRule)(rule, name);
            return new rule_1.Rule(name, rule, ruleset);
          }
          break;
        default:
          throw new Error("Invalid value");
      }
      return existingRule;
    }
    exports.mergeRule = mergeRule;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/mergers/rulesets.js
var require_rulesets = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/mergers/rulesets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeRulesets = void 0;
    function getExtension2(extension) {
      return Array.isArray(extension) ? extension[0] : extension;
    }
    function getExtensions(extensions) {
      return (Array.isArray(extensions) ? extensions : [extensions]).map(getExtension2);
    }
    function mergeRulesets(left, right, isOverride) {
      const ruleset = {
        ...left,
        ...right
      };
      if ("extends" in ruleset && "extends" in ruleset) {
        const rightExtensions = getExtensions(ruleset.extends);
        ruleset.extends = [
          ...(Array.isArray(ruleset.extends) ? ruleset.extends : [ruleset.extends]).filter((ext) => !rightExtensions.includes(getExtension2(ext))),
          ...Array.isArray(ruleset.extends) ? ruleset.extends : [ruleset.extends]
        ];
      }
      if ("aliases" in left && "aliases" in right) {
        ruleset.aliases = {
          ...left.aliases,
          ...right.aliases
        };
      }
      if (!("rules" in left) || !("rules" in right))
        return ruleset;
      if (isOverride) {
        ruleset.rules = {
          ...left.rules,
          ...right.rules
        };
      } else {
        const r3 = ruleset;
        if (!("extends" in r3)) {
          r3.extends = left;
        } else if (Array.isArray(r3.extends)) {
          r3.extends = [...r3.extends, left];
        } else {
          r3.extends = [r3.extends, left];
        }
      }
      return ruleset;
    }
    exports.mergeRulesets = mergeRulesets;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/ruleset.js
var require_ruleset = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/ruleset.js"(exports) {
    "use strict";
    var _Ruleset_instances;
    var _Ruleset_context;
    var _Ruleset_getRules;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ruleset = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var path_1 = (init_index_es(), __toCommonJS(index_es_exports));
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var minimatch_1 = require_minimatch2();
    var rule_1 = require_rule();
    var index_1 = require_validation();
    var rules_1 = require_rules();
    var __1 = require_dist10();
    var rulesets_1 = require_rulesets();
    var formats_1 = require_formats();
    var guards_1 = require_guards2();
    var STACK_SYMBOL = Symbol("@stoplight/spectral/ruleset/#stack");
    var EXPLICIT_SEVERITY = Symbol("@stoplight/spectral/ruleset/#explicit-severity");
    var DEFAULT_RULESET_FILE = /^\.?spectral\.(ya?ml|json|m?js)$/;
    var SEED = 1;
    var Ruleset = class _Ruleset {
      constructor(maybeDefinition, context) {
        var _a;
        this.maybeDefinition = maybeDefinition;
        _Ruleset_instances.add(this);
        this.id = SEED++;
        this.formats = new formats_1.Formats();
        _Ruleset_context.set(this, void 0);
        let definition;
        if ((0, json_1.isPlainObject)(maybeDefinition) && "extends" in maybeDefinition) {
          const { extends: _2, ...def } = maybeDefinition;
          (0, index_1.assertValidRuleset)({ extends: [], ...def }, "js");
          definition = maybeDefinition;
        } else {
          (0, index_1.assertValidRuleset)(maybeDefinition, "js");
          definition = maybeDefinition;
        }
        this.definition = definition;
        (0, tslib_1.__classPrivateFieldSet)(this, _Ruleset_context, {
          severity: "recommended",
          ...context
        }, "f");
        let hasComplexAliases = false;
        this.aliases = definition.aliases === void 0 ? null : Object.fromEntries(Object.entries(definition.aliases).map((alias) => {
          const [name, value] = alias;
          if ((0, guards_1.isSimpleAliasDefinition)(value)) {
            return alias;
          }
          hasComplexAliases = true;
          const targets = value.targets.map((target) => ({
            formats: new formats_1.Formats(target.formats),
            given: target.given
          }));
          return [name, { ...value, targets }];
        }));
        this.hasComplexAliases = hasComplexAliases;
        const stack = (_a = context === null || context === void 0 ? void 0 : context[STACK_SYMBOL]) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Map();
        stack.set(this.definition, this);
        this.extends = "extends" in definition ? (Array.isArray(definition.extends) ? definition.extends : [definition.extends]).reduce((extensions, extension) => {
          let actualExtension;
          let severity = "recommended";
          const explicitSeverity = Array.isArray(extension);
          if (explicitSeverity) {
            [actualExtension, severity] = extension;
          } else {
            actualExtension = extension;
          }
          const existingInstance = stack.get(actualExtension);
          if (existingInstance !== void 0) {
            return extensions;
          }
          extensions.push(new _Ruleset(actualExtension, {
            severity,
            [STACK_SYMBOL]: stack,
            [EXPLICIT_SEVERITY]: explicitSeverity
          }));
          return extensions;
        }, []) : null;
        if (stack.size === 1 && definition.overrides) {
          this.overrides = definition.overrides;
        } else {
          this.overrides = null;
        }
        stack.delete(this.definition);
        if (Array.isArray(this.definition.formats)) {
          for (const format2 of this.definition.formats) {
            this.formats.add(format2);
          }
        }
        if (Array.isArray(this.extends)) {
          for (const { formats } of this.extends) {
            for (const format2 of formats) {
              this.formats.add(format2);
            }
          }
        }
        this.rules = (0, tslib_1.__classPrivateFieldGet)(this, _Ruleset_instances, "m", _Ruleset_getRules).call(this);
      }
      get source() {
        var _a;
        return (_a = (0, tslib_1.__classPrivateFieldGet)(this, _Ruleset_context, "f").source) !== null && _a !== void 0 ? _a : null;
      }
      fromSource(source) {
        if (this.overrides === null) {
          return this;
        }
        const { source: rulesetSource } = this;
        if (source === null) {
          throw new Error("Document must have some source assigned. If you use Spectral programmatically make sure to pass the source to Document");
        }
        if (rulesetSource === null) {
          throw new Error("Ruleset must have some source assigned. If you use Spectral programmatically make sure to pass the source to Ruleset");
        }
        const relativeSource = (0, path_1.relative)((0, path_1.dirname)(rulesetSource), source);
        const pointerOverrides = {};
        const overrides = this.overrides.flatMap(({ files, ...ruleset2 }) => {
          var _a, _b;
          const filteredFiles = [];
          for (const pattern of files) {
            const actualPattern = (_a = (0, json_1.extractSourceFromRef)(pattern)) !== null && _a !== void 0 ? _a : pattern;
            if (!(0, minimatch_1.minimatch)(relativeSource, actualPattern))
              continue;
            const pointer = (0, json_1.extractPointerFromRef)(pattern);
            if (actualPattern === pattern) {
              filteredFiles.push(pattern);
            } else if (!("rules" in ruleset2) || pointer === null) {
              throw new Error("Unknown error. The ruleset is presumably invalid.");
            } else {
              for (const [ruleName, rule] of Object.entries(ruleset2.rules)) {
                if (typeof rule === "object" || typeof rule === "boolean") {
                  throw new Error("Unknown error. The ruleset is presumably invalid.");
                }
                const { definition: rulePointerOverrides } = (_b = pointerOverrides[ruleName]) !== null && _b !== void 0 ? _b : pointerOverrides[ruleName] = {
                  rulesetSource,
                  definition: /* @__PURE__ */ new Map()
                };
                const severity = (0, __1.getDiagnosticSeverity)(rule);
                let sourceRulePointerOverrides = rulePointerOverrides.get(actualPattern);
                if (sourceRulePointerOverrides === void 0) {
                  sourceRulePointerOverrides = /* @__PURE__ */ new Map();
                  rulePointerOverrides.set(actualPattern, sourceRulePointerOverrides);
                }
                sourceRulePointerOverrides.set(pointer, severity);
              }
            }
          }
          return filteredFiles.length === 0 ? [] : ruleset2;
        });
        const { overrides: _2, ...definition } = this.definition;
        if (overrides.length === 0 && Object.keys(pointerOverrides).length === 0) {
          return this;
        }
        const mergedOverrides = overrides.length === 0 ? null : overrides.length > 1 ? overrides.slice(1).reduce((left, right) => (0, rulesets_1.mergeRulesets)(left, right, true), overrides[0]) : overrides[0];
        const ruleset = new _Ruleset(mergedOverrides === null ? definition : (0, rulesets_1.mergeRulesets)(definition, mergedOverrides, false), {
          severity: "recommended",
          source: rulesetSource
        });
        for (const [ruleName, rulePointerOverrides] of Object.entries(pointerOverrides)) {
          if (ruleName in ruleset.rules) {
            ruleset.rules[ruleName].overrides = rulePointerOverrides;
          }
        }
        return ruleset;
      }
      get parserOptions() {
        return { ...__1.DEFAULT_PARSER_OPTIONS, ...this.definition.parserOptions };
      }
      static isDefaultRulesetFile(uri) {
        return DEFAULT_RULESET_FILE.test(uri);
      }
      toJSON() {
        return {
          id: this.id,
          extends: this.extends,
          source: this.source,
          aliases: this.aliases,
          formats: this.formats.size === 0 ? null : this.formats,
          rules: this.rules,
          overrides: this.overrides,
          parserOptions: this.parserOptions
        };
      }
    };
    exports.Ruleset = Ruleset;
    _Ruleset_context = /* @__PURE__ */ new WeakMap(), _Ruleset_instances = /* @__PURE__ */ new WeakSet(), _Ruleset_getRules = function _Ruleset_getRules2() {
      const rules = {};
      if (this.extends !== null && this.extends.length > 0) {
        for (const extendedRuleset of this.extends) {
          if (extendedRuleset === this)
            continue;
          for (const rule of Object.values(extendedRuleset.rules)) {
            rules[rule.name] = rule;
            if ((0, tslib_1.__classPrivateFieldGet)(this, _Ruleset_context, "f")[STACK_SYMBOL] !== void 0 && (0, tslib_1.__classPrivateFieldGet)(this, _Ruleset_context, "f")[EXPLICIT_SEVERITY] === true) {
              rule.enabled = rule_1.Rule.isEnabled(rule, (0, tslib_1.__classPrivateFieldGet)(this, _Ruleset_context, "f").severity);
            }
          }
        }
      }
      if ("rules" in this.definition) {
        for (const [name, definition] of Object.entries(this.definition.rules)) {
          const rule = (0, rules_1.mergeRule)(rules[name], name, definition, this);
          rules[name] = rule;
          if (rule.owner === this) {
            rule.enabled = rule_1.Rule.isEnabled(rule, (0, tslib_1.__classPrivateFieldGet)(this, _Ruleset_context, "f").severity);
          }
          if (rule.formats !== null) {
            for (const format2 of rule.formats) {
              this.formats.add(format2);
            }
          } else if (rule.owner !== this) {
            rule.formats = rule.owner.definition.formats === void 0 ? null : new formats_1.Formats(rule.owner.definition.formats);
          } else if (this.definition.formats !== void 0) {
            rule.formats = new formats_1.Formats(this.definition.formats);
          }
          if (this.definition.documentationUrl !== void 0 && rule.documentationUrl === null) {
            rule.documentationUrl = `${this.definition.documentationUrl}#${name}`;
          }
        }
      }
      return rules;
    };
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/utils/generateDocumentWideResult.js
var require_generateDocumentWideResult = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/utils/generateDocumentWideResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateDocumentWideResult = void 0;
    var document_1 = require_document();
    var generateDocumentWideResult = (document2, message, severity, code) => {
      var _a;
      return {
        range: (_a = document2.getRangeForJsonPath([], true)) !== null && _a !== void 0 ? _a : document_1.Document.DEFAULT_RANGE,
        message,
        code,
        severity,
        ...document2.source !== null ? { source: document2.source } : null,
        path: []
      };
    };
    exports.generateDocumentWideResult = generateDocumentWideResult;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/function.js
var require_function2 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRulesetFunction = exports.RulesetFunctionValidationError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ajv_1 = (0, tslib_1.__importDefault)(require("ajv"));
    var ajv_formats_1 = (0, tslib_1.__importDefault)(require_dist8());
    var ajv_errors_1 = (0, tslib_1.__importDefault)(require_dist9());
    var spectral_runtime_1 = require_dist5();
    var index_1 = require_validation();
    var lodash_1 = require_lodash();
    var AggregateError2 = require_es_aggregate_error();
    var ajv = new ajv_1.default({ allErrors: true, allowUnionTypes: true, strict: true, keywords: ["x-internal"] });
    (0, ajv_errors_1.default)(ajv);
    (0, ajv_formats_1.default)(ajv);
    var RulesetFunctionValidationError = class _RulesetFunctionValidationError extends index_1.RulesetValidationError {
      constructor(fn, error) {
        super("invalid-function-options", _RulesetFunctionValidationError.printMessage(fn, error), _RulesetFunctionValidationError.getPath(error));
      }
      static getPath(error) {
        const path2 = [
          "functionOptions",
          ...error.instancePath === "" ? [] : error.instancePath.slice(1).split("/")
        ];
        switch (error.keyword) {
          case "additionalProperties": {
            const additionalProperty = error.params.additionalProperty;
            path2.push(additionalProperty);
            break;
          }
        }
        return path2;
      }
      static printMessage(fn, error) {
        var _a;
        switch (error.keyword) {
          case "type": {
            const path2 = (0, spectral_runtime_1.printPath)(error.instancePath.slice(1).split("/"), spectral_runtime_1.PrintStyle.Dot);
            const values = Array.isArray(error.params.type) ? error.params.type.join(", ") : String(error.params.type);
            return `"${fn}" function and its "${path2}" option accepts only the following types: ${values}`;
          }
          case "required": {
            const missingProperty = error.params.missingProperty;
            const missingPropertyPath = error.instancePath === "" ? missingProperty : (0, spectral_runtime_1.printPath)([...error.instancePath.slice(1).split("/"), missingProperty], spectral_runtime_1.PrintStyle.Dot);
            return `"${fn}" function is missing "${missingPropertyPath}" option`;
          }
          case "additionalProperties": {
            const additionalProperty = error.params.additionalProperty;
            const additionalPropertyPath = error.instancePath === "" ? additionalProperty : (0, spectral_runtime_1.printPath)([...error.instancePath.slice(1).split("/"), additionalProperty], spectral_runtime_1.PrintStyle.Dot);
            return `"${fn}" function does not support "${additionalPropertyPath}" option`;
          }
          case "enum": {
            const path2 = (0, spectral_runtime_1.printPath)(error.instancePath.slice(1).split("/"), spectral_runtime_1.PrintStyle.Dot);
            const values = error.params.allowedValues.map(spectral_runtime_1.printValue).join(", ");
            return `"${fn}" function and its "${path2}" option accepts only the following values: ${values}`;
          }
          default:
            return (_a = error.message) !== null && _a !== void 0 ? _a : "unknown error";
        }
      }
    };
    exports.RulesetFunctionValidationError = RulesetFunctionValidationError;
    var DEFAULT_OPTIONS_VALIDATOR = (o3) => o3 === null;
    function createRulesetFunction({ input, errorOnInvalidInput = false, options }, fn) {
      const validateOptions = options === null ? DEFAULT_OPTIONS_VALIDATOR : ajv.compile(options);
      const validateInput = input !== null ? ajv.compile(input) : input;
      const wrappedFn = function(input2, options2, ...args) {
        var _a, _b, _c;
        if ((validateInput === null || validateInput === void 0 ? void 0 : validateInput(input2)) === false) {
          if (errorOnInvalidInput) {
            return [
              {
                message: (_c = (_b = (_a = validateInput.errors) === null || _a === void 0 ? void 0 : _a.find((error) => error.keyword === "errorMessage")) === null || _b === void 0 ? void 0 : _b.message) !== null && _c !== void 0 ? _c : "invalid input"
              }
            ];
          }
          return;
        }
        wrappedFn.validator(options2);
        return fn(input2, options2, ...args);
      };
      Reflect.defineProperty(wrappedFn, "name", { value: fn.name });
      const validOpts = /* @__PURE__ */ new WeakSet();
      wrappedFn.validator = function(o3) {
        if ((0, lodash_1.isObject)(o3) && validOpts.has(o3))
          return;
        if (validateOptions(o3)) {
          if ((0, lodash_1.isObject)(o3))
            validOpts.add(o3);
          return;
        }
        if (options === null) {
          throw new index_1.RulesetValidationError("invalid-function-options", `"${fn.name || "<unknown>"}" function does not accept any options`, ["functionOptions"]);
        } else if ("errors" in validateOptions && Array.isArray(validateOptions.errors) && validateOptions.errors.length > 0) {
          throw new AggregateError2(validateOptions.errors.map((error) => new RulesetFunctionValidationError(fn.name || "<unknown>", error)));
        } else {
          throw new index_1.RulesetValidationError("invalid-function-options", `"functionOptions" of "${fn.name || "<unknown>"}" function must be valid`, ["functionOptions"]);
        }
      };
      Reflect.defineProperty(wrappedFn, "schemas", {
        enumerable: false,
        value: {
          input,
          options
        }
      });
      return wrappedFn;
    }
    exports.createRulesetFunction = createRulesetFunction;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/ruleset/index.js
var require_ruleset2 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/ruleset/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Rule = exports.Formats = exports.Ruleset = exports.createRulesetFunction = exports.getDiagnosticSeverity = exports.RulesetValidationError = exports.assertValidRuleset = void 0;
    var index_1 = require_validation();
    Object.defineProperty(exports, "assertValidRuleset", { enumerable: true, get: function() {
      return index_1.assertValidRuleset;
    } });
    Object.defineProperty(exports, "RulesetValidationError", { enumerable: true, get: function() {
      return index_1.RulesetValidationError;
    } });
    var severity_1 = require_severity();
    Object.defineProperty(exports, "getDiagnosticSeverity", { enumerable: true, get: function() {
      return severity_1.getDiagnosticSeverity;
    } });
    var function_1 = require_function2();
    Object.defineProperty(exports, "createRulesetFunction", { enumerable: true, get: function() {
      return function_1.createRulesetFunction;
    } });
    var ruleset_1 = require_ruleset();
    Object.defineProperty(exports, "Ruleset", { enumerable: true, get: function() {
      return ruleset_1.Ruleset;
    } });
    var formats_1 = require_formats();
    Object.defineProperty(exports, "Formats", { enumerable: true, get: function() {
      return formats_1.Formats;
    } });
    var rule_1 = require_rule();
    Object.defineProperty(exports, "Rule", { enumerable: true, get: function() {
      return rule_1.Rule;
    } });
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/types/spectral.js
var require_spectral = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/types/spectral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/types/function.js
var require_function3 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/types/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/types/index.js
var require_types4 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    (0, tslib_1.__exportStar)(require_spectral(), exports);
    (0, tslib_1.__exportStar)(require_function3(), exports);
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/spectral.js
var require_spectral2 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/spectral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Spectral = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var json_1 = (init_index_es2(), __toCommonJS(index_es_exports2));
    var types_1 = require_dist();
    var Parsers = (0, tslib_1.__importStar)(require_dist3());
    var spectral_ref_resolver_1 = require_dist6();
    var document_1 = require_document();
    var documentInventory_1 = require_documentInventory();
    var runner_1 = require_runner3();
    var ruleset_1 = require_ruleset();
    var generateDocumentWideResult_1 = require_generateDocumentWideResult();
    var ruleset_2 = require_ruleset2();
    (0, tslib_1.__exportStar)(require_types4(), exports);
    var Spectral2 = class {
      constructor(opts) {
        this.opts = opts;
        if ((opts === null || opts === void 0 ? void 0 : opts.resolver) !== void 0) {
          this._resolver = opts.resolver;
        } else {
          this._resolver = (0, spectral_ref_resolver_1.createHttpAndFileResolver)();
        }
      }
      parseDocument(target) {
        return target instanceof document_1.Document ? target : (0, document_1.isParsedResult)(target) ? new document_1.ParsedDocument(target) : new document_1.Document(typeof target === "string" ? target : (0, json_1.stringify)(target, void 0, 2), Parsers.Yaml);
      }
      async runWithResolved(target, opts = {}) {
        if (this.ruleset === void 0) {
          throw new Error("No ruleset has been defined. Have you called setRuleset()?");
        }
        const document2 = this.parseDocument(target);
        const ruleset = this.ruleset.fromSource(document2.source);
        const inventory = new documentInventory_1.DocumentInventory(document2, this._resolver);
        await inventory.resolve();
        const runner = new runner_1.Runner(inventory);
        runner.results.push(...this._filterParserErrors(document2.diagnostics, ruleset.parserOptions));
        if (document2.formats === void 0) {
          const foundFormats = [...ruleset.formats].filter((format2) => format2(inventory.resolved, document2.source));
          if (foundFormats.length === 0 && opts.ignoreUnknownFormat !== true) {
            document2.formats = null;
            if (ruleset.formats.size > 0) {
              runner.addResult(this._generateUnrecognizedFormatError(document2, Array.from(ruleset.formats)));
            }
          } else {
            document2.formats = new Set(foundFormats);
          }
        }
        await runner.run(ruleset);
        const results = runner.getResults();
        return {
          resolved: inventory.resolved,
          results
        };
      }
      async run(target, opts = {}) {
        return (await this.runWithResolved(target, opts)).results;
      }
      setRuleset(ruleset) {
        this.ruleset = ruleset instanceof ruleset_1.Ruleset ? ruleset : new ruleset_1.Ruleset(ruleset);
      }
      _generateUnrecognizedFormatError(document2, formats) {
        return (0, generateDocumentWideResult_1.generateDocumentWideResult)(document2, `The provided document does not match any of the registered formats [${formats.map((fn) => {
          var _a;
          return (_a = fn.displayName) !== null && _a !== void 0 ? _a : fn.name;
        }).join(", ")}]`, types_1.DiagnosticSeverity.Warning, "unrecognized-format");
      }
      _filterParserErrors(diagnostics, parserOptions) {
        return diagnostics.reduce((diagnostics2, diagnostic) => {
          if (diagnostic.code !== "parser")
            return diagnostics2;
          let severity;
          if (diagnostic.message.startsWith("Mapping key must be a string scalar rather than")) {
            severity = (0, ruleset_2.getDiagnosticSeverity)(parserOptions.incompatibleValues);
          } else if (diagnostic.message.startsWith("Duplicate key")) {
            severity = (0, ruleset_2.getDiagnosticSeverity)(parserOptions.duplicateKeys);
          } else {
            diagnostics2.push(diagnostic);
            return diagnostics2;
          }
          if (severity !== -1) {
            diagnostics2.push(diagnostic);
            diagnostic.severity = severity;
          }
          return diagnostics2;
        }, []);
      }
    };
    exports.Spectral = Spectral2;
  }
});

// ../../node_modules/@stoplight/spectral-core/dist/index.js
var require_dist10 = __commonJS({
  "../../node_modules/@stoplight/spectral-core/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsedDocument = exports.Document = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    (0, tslib_1.__exportStar)(require_consts(), exports);
    (0, tslib_1.__exportStar)(require_spectral2(), exports);
    var document_1 = require_document();
    Object.defineProperty(exports, "Document", { enumerable: true, get: function() {
      return document_1.Document;
    } });
    Object.defineProperty(exports, "ParsedDocument", { enumerable: true, get: function() {
      return document_1.ParsedDocument;
    } });
    (0, tslib_1.__exportStar)(require_ruleset2(), exports);
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BODY_TYPE_NAME: () => BODY_TYPE_NAME,
  GetterPropType: () => GetterPropType,
  LogLevels: () => LogLevels,
  OutputClient: () => OutputClient,
  OutputMockType: () => OutputMockType,
  OutputMode: () => OutputMode,
  RefComponentSuffix: () => RefComponentSuffix,
  SchemaType: () => SchemaType,
  URL_REGEX: () => URL_REGEX,
  VERBS_WITH_BODY: () => VERBS_WITH_BODY,
  Verbs: () => Verbs,
  _filteredVerbs: () => _filteredVerbs,
  addDependency: () => addDependency,
  asyncReduce: () => asyncReduce,
  camel: () => camel,
  combineSchemas: () => combineSchemas,
  compareVersions: () => compareVersions,
  count: () => count,
  createDebugger: () => createDebugger,
  createLogger: () => createLogger,
  createSuccessMessage: () => createSuccessMessage,
  dynamicImport: () => dynamicImport,
  errorMessage: () => errorMessage,
  escape: () => escape2,
  generalJSTypes: () => generalJSTypes,
  generalJSTypesWithArray: () => generalJSTypesWithArray,
  generateAxiosOptions: () => generateAxiosOptions,
  generateBodyMutatorConfig: () => generateBodyMutatorConfig,
  generateBodyOptions: () => generateBodyOptions,
  generateComponentDefinition: () => generateComponentDefinition,
  generateDependencyImports: () => generateDependencyImports,
  generateFormDataAndUrlEncodedFunction: () => generateFormDataAndUrlEncodedFunction,
  generateImports: () => generateImports,
  generateModelInline: () => generateModelInline,
  generateModelsInline: () => generateModelsInline,
  generateMutator: () => generateMutator,
  generateMutatorConfig: () => generateMutatorConfig,
  generateMutatorImports: () => generateMutatorImports,
  generateMutatorRequestOptions: () => generateMutatorRequestOptions,
  generateOptions: () => generateOptions,
  generateParameterDefinition: () => generateParameterDefinition,
  generateQueryParamsAxiosConfig: () => generateQueryParamsAxiosConfig,
  generateSchemasDefinition: () => generateSchemasDefinition,
  generateTarget: () => generateTarget,
  generateTargetForTags: () => generateTargetForTags,
  generateVerbImports: () => generateVerbImports,
  generateVerbsOptions: () => generateVerbsOptions,
  getArray: () => getArray,
  getBody: () => getBody,
  getEnum: () => getEnum,
  getEnumImplementation: () => getEnumImplementation,
  getExtension: () => getExtension,
  getFileInfo: () => getFileInfo,
  getKey: () => getKey,
  getMockFileExtensionByTypeName: () => getMockFileExtensionByTypeName,
  getNumberWord: () => getNumberWord,
  getObject: () => getObject,
  getOperationId: () => getOperationId,
  getOrvalGeneratedTypes: () => getOrvalGeneratedTypes,
  getParameters: () => getParameters,
  getParams: () => getParams,
  getParamsInPath: () => getParamsInPath,
  getProps: () => getProps,
  getQueryParams: () => getQueryParams,
  getRefInfo: () => getRefInfo,
  getResReqTypes: () => getResReqTypes,
  getResponse: () => getResponse,
  getRoute: () => getRoute,
  getRouteAsArray: () => getRouteAsArray,
  getScalar: () => getScalar,
  ibmOpenapiValidator: () => ibmOpenapiValidator,
  ibmOpenapiValidatorErrors: () => ibmOpenapiValidatorErrors,
  ibmOpenapiValidatorWarnings: () => ibmOpenapiValidatorWarnings,
  isBoolean: () => isBoolean,
  isDirectory: () => isDirectory,
  isFunction: () => isFunction2,
  isModule: () => isModule,
  isNull: () => isNull,
  isNumber: () => isNumber,
  isNumeric: () => isNumeric,
  isObject: () => isObject,
  isReference: () => isReference,
  isRootKey: () => isRootKey,
  isSchema: () => isSchema,
  isString: () => isString2,
  isSyntheticDefaultImportsAllow: () => isSyntheticDefaultImportsAllow,
  isUndefined: () => isUndefined,
  isUrl: () => isUrl,
  isVerb: () => isVerb,
  jsDoc: () => jsDoc,
  jsStringEscape: () => jsStringEscape,
  kebab: () => kebab,
  loadFile: () => loadFile,
  log: () => log,
  mergeDeep: () => mergeDeep,
  mismatchArgsMessage: () => mismatchArgsMessage,
  openApiConverter: () => openApiConverter,
  pascal: () => pascal,
  removeFiles: () => removeFiles,
  resolveDiscriminators: () => resolveDiscriminators,
  resolveExampleRefs: () => resolveExampleRefs,
  resolveObject: () => resolveObject,
  resolveRef: () => resolveRef,
  resolveValue: () => resolveValue,
  sanitize: () => sanitize,
  snake: () => snake,
  sortByPriority: () => sortByPriority,
  startMessage: () => startMessage,
  stringify: () => stringify,
  toObjectString: () => toObjectString,
  upath: () => path_exports,
  upper: () => upper,
  writeModelInline: () => writeModelInline,
  writeModelsInline: () => writeModelsInline,
  writeSchema: () => writeSchema,
  writeSchemas: () => writeSchemas,
  writeSingleMode: () => writeSingleMode,
  writeSplitMode: () => writeSplitMode,
  writeSplitTagsMode: () => writeSplitTagsMode,
  writeTagsMode: () => writeTagsMode
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var OutputClient = {
  ANGULAR: "angular",
  AXIOS: "axios",
  AXIOS_FUNCTIONS: "axios-functions",
  REACT_QUERY: "react-query",
  SVELTE_QUERY: "svelte-query",
  VUE_QUERY: "vue-query",
  SWR: "swr",
  ZOD: "zod"
};
var OutputMode = {
  SINGLE: "single",
  SPLIT: "split",
  TAGS: "tags",
  TAGS_SPLIT: "tags-split"
};
var OutputMockType = {
  MSW: "msw"
};
var Verbs = {
  POST: "post",
  PUT: "put",
  GET: "get",
  PATCH: "patch",
  DELETE: "delete",
  HEAD: "head"
};
var GetterPropType = {
  PARAM: "param",
  NAMED_PATH_PARAMS: "namedPathParams",
  BODY: "body",
  QUERY_PARAM: "queryParam",
  HEADER: "header"
};
var SchemaType = {
  integer: "integer",
  number: "number",
  string: "string",
  boolean: "boolean",
  object: "object",
  null: "null",
  array: "array",
  enum: "enum",
  unknown: "unknown"
};

// src/constants.ts
var generalJSTypes = [
  "number",
  "string",
  "null",
  "unknown",
  "undefined",
  "object",
  "blob"
];
var generalJSTypesWithArray = generalJSTypes.reduce(
  (acc, type) => {
    acc.push(type, `Array<${type}>`, `${type}[]`);
    return acc;
  },
  []
);
var VERBS_WITH_BODY = [
  Verbs.POST,
  Verbs.PUT,
  Verbs.PATCH,
  Verbs.DELETE
];
var URL_REGEX = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+$/;

// src/generators/component-definition.ts
var import_lodash7 = __toESM(require("lodash.isempty"));

// src/getters/enum.ts
var import_esutils2 = require("esutils");

// src/utils/path.ts
var path_exports = {};
__export(path_exports, {
  basename: () => basename2,
  dirname: () => dirname2,
  extname: () => extname2,
  getSchemaFileName: () => getSchemaFileName,
  getSpecName: () => getSpecName,
  isAbsolute: () => isAbsolute2,
  join: () => join2,
  joinSafe: () => joinSafe,
  normalizeSafe: () => normalizeSafe,
  relativeSafe: () => relativeSafe,
  resolve: () => resolve2,
  separator: () => separator
});
var import_path3 = __toESM(require("path"));

// src/utils/extension.ts
var getExtension = (path2) => path2.toLowerCase().includes(".yaml") || path2.toLowerCase().includes(".yml") ? "yaml" : "json";

// src/utils/file.ts
var import_chalk2 = __toESM(require("chalk"));
var import_esbuild = require("esbuild");
var import_fs = __toESM(require("fs"));
var import_globby = __toESM(require("globby"));
var import_micromatch = __toESM(require("micromatch"));
var import_path = require("path");

// src/utils/debug.ts
var import_debug = __toESM(require("debug"));
var filter = process.env.ORVAL_DEBUG_FILTER;
var DEBUG = process.env.DEBUG;
function createDebugger(ns, options = {}) {
  const log2 = (0, import_debug.default)(ns);
  const { onlyWhenFocused } = options;
  const focus = typeof onlyWhenFocused === "string" ? onlyWhenFocused : ns;
  return (msg, ...args) => {
    if (filter && !msg.includes(filter)) {
      return;
    }
    if (onlyWhenFocused && !DEBUG?.includes(focus)) {
      return;
    }
    log2(msg, ...args);
  };
}

// src/utils/logger.ts
var import_chalk = __toESM(require("chalk"));
var import_readline = __toESM(require("readline"));
var log = console.log;
var startMessage = ({
  name,
  version,
  description
}) => log(
  `\u{1F37B} Start ${import_chalk.default.cyan.bold(name)} ${import_chalk.default.green(`v${version}`)}${description ? ` - ${description}` : ""}`
);
var errorMessage = (err) => log(import_chalk.default.red(err));
var mismatchArgsMessage = (mismatchArgs) => log(
  import_chalk.default.yellow(
    `${mismatchArgs.join(", ")} ${mismatchArgs.length === 1 ? "is" : "are"} not defined in your configuration!`
  )
);
var createSuccessMessage = (backend) => log(
  `\u{1F389} ${backend ? `${import_chalk.default.green(backend)} - ` : ""}Your OpenAPI spec has been converted into ready to use orval!`
);
var ibmOpenapiValidatorWarnings = (warnings) => {
  log(import_chalk.default.yellow("(!) Warnings"));
  warnings.forEach(
    (i3) => log(import_chalk.default.yellow(`Message : ${i3.message}
Path    : ${i3.path}`))
  );
};
var ibmOpenapiValidatorErrors = (errors) => {
  log(import_chalk.default.red("(!) Errors"));
  errors.forEach(
    (i3) => log(import_chalk.default.red(`Message : ${i3.message}
Path    : ${i3.path}`))
  );
};
var LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
var lastType;
var lastMsg;
var sameCount = 0;
function clearScreen() {
  const repeatCount = process.stdout.rows - 2;
  const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  console.log(blank);
  import_readline.default.cursorTo(process.stdout, 0, 0);
  import_readline.default.clearScreenDown(process.stdout);
}
function createLogger(level = "info", options = {}) {
  const { prefix = "[vite]", allowClearScreen = true } = options;
  const thresh = LogLevels[level];
  const clear = allowClearScreen && process.stdout.isTTY && !process.env.CI ? clearScreen : () => {
  };
  function output(type, msg, options2 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      const format2 = () => {
        if (options2.timestamp) {
          const tag = type === "info" ? import_chalk.default.cyan.bold(prefix) : type === "warn" ? import_chalk.default.yellow.bold(prefix) : import_chalk.default.red.bold(prefix);
          return `${import_chalk.default.dim((/* @__PURE__ */ new Date()).toLocaleTimeString())} ${tag} ${msg}`;
        } else {
          return msg;
        }
      };
      if (type === lastType && msg === lastMsg) {
        sameCount++;
        clear();
        console[method](format2(), import_chalk.default.yellow(`(x${sameCount + 1})`));
      } else {
        sameCount = 0;
        lastMsg = msg;
        lastType = type;
        if (options2.clear) {
          clear();
        }
        console[method](format2());
      }
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  const logger = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger.hasWarned = true;
      output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg))
        return;
      logger.hasWarned = true;
      output("warn", msg, opts);
      warnedMessages.add(msg);
    },
    error(msg, opts) {
      logger.hasWarned = true;
      output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear();
      }
    }
  };
  return logger;
}

// src/utils/file.ts
var getFileInfo = (target = "", {
  backupFilename = "filename",
  extension = ".ts"
} = {}) => {
  const isDir = isDirectory(target);
  const path2 = isDir ? (0, import_path.join)(target, backupFilename + extension) : target;
  const pathWithoutExtension = path2.replace(/\.[^/.]+$/, "");
  const dir = (0, import_path.dirname)(path2);
  const filename = (0, import_path.basename)(
    path2,
    extension[0] !== "." ? `.${extension}` : extension
  );
  return {
    path: path2,
    pathWithoutExtension,
    extension,
    isDirectory: isDir,
    dirname: dir,
    filename
  };
};
var debug2 = createDebugger("orval:file-load");
var cache = /* @__PURE__ */ new Map();
async function loadFile(filePath, options) {
  const {
    root = process.cwd(),
    isDefault = true,
    defaultFileName,
    logLevel,
    alias,
    tsconfig,
    load = true
  } = options ?? {};
  const start = Date.now();
  let resolvedPath;
  let isTS = false;
  let isMjs = false;
  if (filePath) {
    resolvedPath = (0, import_path.resolve)(filePath);
    isTS = filePath.endsWith(".ts");
  } else if (defaultFileName) {
    const jsFile = (0, import_path.resolve)(root, `${defaultFileName}.js`);
    if (import_fs.default.existsSync(jsFile)) {
      resolvedPath = jsFile;
    }
    if (!resolvedPath) {
      const mjsFile = (0, import_path.resolve)(root, `${defaultFileName}.mjs`);
      if (import_fs.default.existsSync(mjsFile)) {
        resolvedPath = mjsFile;
        isMjs = true;
      }
    }
    if (!resolvedPath) {
      const tsFile = (0, import_path.resolve)(root, `${defaultFileName}.ts`);
      if (import_fs.default.existsSync(tsFile)) {
        resolvedPath = tsFile;
        isTS = true;
      }
    }
  }
  if (!resolvedPath) {
    if (filePath) {
      createLogger(logLevel).error(import_chalk2.default.red(`File not found => ${filePath}`));
    } else if (defaultFileName) {
      createLogger(logLevel).error(
        import_chalk2.default.red(`File not found => ${defaultFileName}.{js,mjs,ts}`)
      );
    } else {
      createLogger(logLevel).error(import_chalk2.default.red(`File not found`));
    }
    process.exit(1);
  }
  const normalizeResolvedPath = normalizeSafe(resolvedPath);
  const cachedData = cache.get(resolvedPath);
  if (cachedData) {
    return {
      path: normalizeResolvedPath,
      ...cachedData,
      cached: true
    };
  }
  try {
    let file;
    if (!file && !isTS && !isMjs) {
      try {
        delete require.cache[require.resolve(resolvedPath)];
        file = require(resolvedPath);
        debug2(`cjs loaded in ${Date.now() - start}ms`);
      } catch (e3) {
        const ignored = new RegExp(
          [
            `Cannot use import statement`,
            `Must use import to load ES Module`,
            // #1635, #2050 some Node 12.x versions don't have esm detection
            // so it throws normal syntax errors when encountering esm syntax
            `Unexpected token`,
            `Unexpected identifier`
          ].join("|")
        );
        if (!ignored.test(e3.message)) {
          throw e3;
        }
      }
    }
    if (!file) {
      const { code } = await bundleFile(
        resolvedPath,
        isMjs,
        root || (0, import_path.dirname)(normalizeResolvedPath),
        alias,
        tsconfig?.compilerOptions
      );
      if (load) {
        file = await loadFromBundledFile(resolvedPath, code, isDefault);
      } else {
        file = code;
      }
      debug2(`bundled file loaded in ${Date.now() - start}ms`);
    }
    cache.set(resolvedPath, { file });
    return {
      path: normalizeResolvedPath,
      file
    };
  } catch (error) {
    cache.set(resolvedPath, { error });
    return {
      path: normalizeResolvedPath,
      error
    };
  }
}
async function bundleFile(fileName, mjs = false, workspace, alias, compilerOptions) {
  const result = await (0, import_esbuild.build)({
    absWorkingDir: process.cwd(),
    entryPoints: [fileName],
    outfile: "out.js",
    write: false,
    platform: "node",
    bundle: true,
    format: mjs ? "esm" : "cjs",
    sourcemap: "inline",
    metafile: true,
    target: compilerOptions?.target || "es6",
    minify: false,
    minifyIdentifiers: false,
    minifySyntax: false,
    minifyWhitespace: false,
    treeShaking: false,
    keepNames: false,
    plugins: [
      ...alias || compilerOptions?.paths ? [
        {
          name: "aliasing",
          setup(build2) {
            build2.onResolve(
              { filter: /^[\w@][^:]/ },
              async ({ path: id }) => {
                if (alias) {
                  const matchKeys = Object.keys(alias);
                  const match = matchKeys.find(
                    (key) => id.startsWith(key) || import_micromatch.default.isMatch(id, matchKeys)
                  );
                  if (match) {
                    const find2 = import_micromatch.default.scan(match);
                    const replacement2 = import_micromatch.default.scan(alias[match]);
                    const base = (0, import_path.resolve)(workspace, replacement2.base);
                    const newPath = find2.base ? id.replace(find2.base, base) : joinSafe(base, id);
                    const ext = (0, import_path.extname)(newPath);
                    const aliased = ext ? newPath : `${newPath}.ts`;
                    if (!import_fs.default.existsSync(aliased)) {
                      return;
                    }
                    return {
                      path: aliased
                    };
                  }
                }
                if (compilerOptions?.paths) {
                  const matchKeys = Object.keys(compilerOptions?.paths);
                  const match = matchKeys.find(
                    (key) => id.startsWith(key) || import_micromatch.default.isMatch(id, matchKeys)
                  );
                  if (match) {
                    const find2 = import_micromatch.default.scan(match);
                    const replacement2 = import_micromatch.default.scan(
                      compilerOptions?.paths[match][0]
                    );
                    const base = (0, import_path.resolve)(workspace, replacement2.base);
                    const newPath = find2.base ? id.replace(find2.base, base) : joinSafe(base, id);
                    const ext = (0, import_path.extname)(newPath);
                    const aliased = ext ? newPath : `${newPath}.ts`;
                    if (!import_fs.default.existsSync(aliased)) {
                      return;
                    }
                    return {
                      path: aliased
                    };
                  }
                }
              }
            );
          }
        }
      ] : [],
      {
        name: "externalize-deps",
        setup(build2) {
          build2.onResolve({ filter: /.*/ }, (args) => {
            const id = args.path;
            if (id[0] !== "." && !(0, import_path.isAbsolute)(id)) {
              return {
                external: true
              };
            }
          });
        }
      },
      {
        name: "replace-import-meta",
        setup(build2) {
          build2.onLoad({ filter: /\.[jt]s$/ }, async (args) => {
            const contents = await import_fs.default.promises.readFile(args.path, "utf8");
            return {
              loader: args.path.endsWith(".ts") ? "ts" : "js",
              contents: contents.replace(
                /\bimport\.meta\.url\b/g,
                JSON.stringify(`file://${args.path}`)
              ).replace(/\b__dirname\b/g, JSON.stringify((0, import_path.dirname)(args.path))).replace(/\b__filename\b/g, JSON.stringify(args.path))
            };
          });
        }
      }
    ]
  });
  const { text } = result.outputFiles[0];
  return {
    code: text,
    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
  };
}
async function loadFromBundledFile(fileName, bundledCode, isDefault) {
  const extension = (0, import_path.extname)(fileName);
  const defaultLoader = require.extensions[extension];
  require.extensions[extension] = (module2, filename) => {
    if (filename === fileName) {
      module2._compile(bundledCode, filename);
    } else {
      defaultLoader(module2, filename);
    }
  };
  delete require.cache[require.resolve(fileName)];
  const raw = require(fileName);
  const file = isDefault && raw.__esModule ? raw.default : raw;
  require.extensions[extension] = defaultLoader;
  return file;
}
async function removeFiles(patterns, dir) {
  const files = await (0, import_globby.default)(patterns, {
    cwd: dir,
    absolute: true
  });
  await Promise.all(files.map((file) => import_fs.default.promises.unlink(file)));
}

// src/utils/path.ts
var path = {};
var isFunction = (val) => typeof val == "function";
var isString = (val) => {
  if (typeof val === "string") {
    return true;
  }
  if (typeof val === "object" && val !== null) {
    return Object.toString.call(val) == "[object String]";
  }
  return false;
};
Object.entries(import_path3.default).forEach(([propName, propValue]) => {
  if (isFunction(propValue)) {
    path[propName] = /* @__PURE__ */ ((propName2) => {
      return (...args) => {
        args = args.map((p2) => {
          if (isString(p2)) {
            return toUnix(p2);
          } else {
            return p2;
          }
        });
        const result = import_path3.default[propName2](...args);
        if (isString(result)) {
          return toUnix(result);
        } else {
          return result;
        }
      };
    })(propName);
  } else {
    path[propName] = propValue;
  }
});
var { join: join2, resolve: resolve2, extname: extname2, dirname: dirname2, basename: basename2, isAbsolute: isAbsolute2 } = path;
var relativeSafe = (from, to) => {
  const normalizedRelativePath = path.relative(from, to);
  const relativePath = normalizeSafe(`.${separator}${normalizedRelativePath}`);
  return relativePath;
};
var getSpecName = (specKey, target) => {
  if (isUrl(specKey)) {
    const url = new URL(target);
    return specKey.replace(url.origin, "").replace(getFileInfo(url.pathname).dirname, "").replace(`.${getExtension(specKey)}`, "");
  }
  return "/" + path.normalize(path.relative(getFileInfo(target).dirname, specKey)).split("../").join("").replace(`.${getExtension(specKey)}`, "");
};
var getSchemaFileName = (path2) => {
  return path2.replace(`.${getExtension(path2)}`, "").slice(path2.lastIndexOf("/") + 1);
};
var separator = "/";
var toUnix = function(value) {
  value = value.replace(/\\/g, "/");
  value = value.replace(/(?<!^)\/+/g, "/");
  return value;
};
var normalizeSafe = (value) => {
  let result;
  value = toUnix(value);
  result = path.normalize(value);
  if (value.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
    result = "./" + result;
  } else if (value.startsWith("//") && !result.startsWith("//")) {
    if (value.startsWith("//./")) {
      result = "//." + result;
    } else {
      result = "/" + result;
    }
  }
  return result;
};
var joinSafe = function(...values) {
  let result = path.join(...values);
  if (values.length > 0) {
    const firstValue = toUnix(values[0]);
    if (firstValue.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
      result = "./" + result;
    } else if (firstValue.startsWith("//") && !result.startsWith("//")) {
      if (firstValue.startsWith("//./")) {
        result = "//." + result;
      } else {
        result = "/" + result;
      }
    }
  }
  return result;
};

// src/utils/assertion.ts
var isReference = (property) => {
  return Boolean(property?.$ref);
};
var isDirectory = (path2) => {
  return !extname2(path2);
};
function isObject(x3) {
  return Object.prototype.toString.call(x3) === "[object Object]";
}
function isModule(x3) {
  return Object.prototype.toString.call(x3) === "[object Module]";
}
function isString2(x3) {
  return typeof x3 === "string";
}
function isNumber(x3) {
  return typeof x3 === "number";
}
function isNumeric(x3) {
  return /^-?\d+$/.test(x3);
}
function isBoolean(x3) {
  return typeof x3 === "boolean";
}
function isFunction2(x3) {
  return typeof x3 === "function";
}
function isUndefined(x3) {
  return typeof x3 === "undefined";
}
function isNull(x3) {
  return typeof x3 === null;
}
function isSchema(x3) {
  if (!isObject(x3)) {
    return false;
  }
  if (isString2(x3.type) && Object.values(SchemaType).includes(x3.type)) {
    return true;
  }
  const combine = x3.allOf || x3.anyOf || x3.oneOf;
  if (Array.isArray(combine)) {
    return true;
  }
  if (isObject(x3.properties)) {
    return true;
  }
  return false;
}
var isVerb = (verb) => Object.values(Verbs).includes(verb);
var isRootKey = (specKey, target) => {
  return specKey === target;
};
var isUrl = (str) => {
  let givenURL;
  try {
    givenURL = new URL(str);
  } catch (error) {
    return false;
  }
  return givenURL.protocol === "http:" || givenURL.protocol === "https:";
};

// src/utils/async-reduce.ts
async function asyncReduce(array, reducer, initValue) {
  let accumulate = typeof initValue === "object" ? Object.create(initValue) : initValue;
  for (const item of array) {
    accumulate = await reducer(accumulate, item);
  }
  return accumulate;
}

// src/utils/case.ts
var unicodes = function(s2, prefix) {
  prefix = prefix || "";
  return s2.replace(/(^|-)/g, "$1\\u" + prefix).replace(/,/g, "\\u" + prefix);
};
var symbols = unicodes("20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7", "00");
var lowers = "a-z" + unicodes("DF-F6,F8-FF", "00");
var uppers = "A-Z" + unicodes("C0-D6,D8-DE", "00");
var impropers = "A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\.?|Via";
var regexps = {
  capitalize: new RegExp("(^|[" + symbols + "])([" + lowers + "])", "g"),
  pascal: new RegExp("(^|[" + symbols + "])+([" + lowers + uppers + "])", "g"),
  fill: new RegExp("[" + symbols + "]+(.|$)", "g"),
  sentence: new RegExp(
    '(^\\s*|[\\?\\!\\.]+"?\\s+"?|,\\s+")([' + lowers + "])",
    "g"
  ),
  improper: new RegExp("\\b(" + impropers + ")\\b", "g"),
  relax: new RegExp(
    "([^" + uppers + "])([" + uppers + "]*)([" + uppers + "])(?=[^" + uppers + "]|$)",
    "g"
  ),
  upper: new RegExp("^[^" + lowers + "]+$"),
  hole: /[^\s]\s[^\s]/,
  apostrophe: /'/g,
  room: new RegExp("[" + symbols + "]")
};
var deapostrophe = (s2) => {
  return s2.replace(regexps.apostrophe, "");
};
var up = String.prototype.toUpperCase;
var low = String.prototype.toLowerCase;
var fill = (s2, fillWith, isDeapostrophe = false) => {
  s2 = s2.replace(regexps.fill, function(m2, next) {
    return next ? fillWith + next : "";
  });
  if (isDeapostrophe) {
    s2 = deapostrophe(s2);
  }
  return s2;
};
var decap = (s2, char = 0) => {
  return low.call(s2.charAt(char)) + s2.slice(char + 1);
};
var relax = (m2, before, acronym, caps) => {
  return before + " " + (acronym ? acronym + " " : "") + caps;
};
var prep = (s2, isFill = false, isPascal = false, isUpper = false) => {
  s2 = s2 == null ? "" : s2 + "";
  if (!isUpper && regexps.upper.test(s2)) {
    s2 = low.call(s2);
  }
  if (!isFill && !regexps.hole.test(s2)) {
    var holey = fill(s2, " ");
    if (regexps.hole.test(holey)) {
      s2 = holey;
    }
  }
  if (!isPascal && !regexps.room.test(s2)) {
    s2 = s2.replace(regexps.relax, relax);
  }
  return s2;
};
var lower = (s2, fillWith, isDeapostrophe) => {
  return fill(low.call(prep(s2, !!fillWith)), fillWith, isDeapostrophe);
};
var pascalMemory = {};
var pascal = (s2) => {
  if (pascalMemory[s2]) {
    return pascalMemory[s2];
  }
  const isStartWithUnderscore = s2?.startsWith("_");
  if (regexps.upper.test(s2)) {
    s2 = low.call(s2);
  }
  const pascalString = (s2?.match(/[a-zA-Z0-9]+/g) || []).map((w2) => w2.charAt(0).toUpperCase() + w2.slice(1)).join("");
  const pascalWithUnderscore = isStartWithUnderscore ? `_${pascalString}` : pascalString;
  pascalMemory[s2] = pascalWithUnderscore;
  return pascalWithUnderscore;
};
var camel = (s2) => {
  const isStartWithUnderscore = s2?.startsWith("_");
  const camelString = decap(pascal(s2), isStartWithUnderscore ? 1 : 0);
  return isStartWithUnderscore ? `_${camelString}` : camelString;
};
var snake = (s2) => {
  return lower(s2, "_", true);
};
var kebab = (s2) => {
  return lower(s2, "-", true);
};
var upper = (s2, fillWith, isDeapostrophe) => {
  return fill(
    up.call(prep(s2, !!fillWith, false, true)),
    fillWith,
    isDeapostrophe
  );
};

// src/utils/compare-version.ts
var import_compare_versions = require("compare-versions");
var compareVersions = (firstVersion, secondVersions, operator = ">=") => {
  if (firstVersion === "latest" || firstVersion === "*") {
    return true;
  }
  return (0, import_compare_versions.compare)(
    firstVersion.replace(/(\s(.*))/, ""),
    secondVersions,
    operator
  );
};

// src/utils/doc.ts
var search = "\\*/";
var replacement = "*\\/";
var regex = new RegExp(search, "g");
function jsDoc({
  description,
  deprecated,
  summary
}, tryOneLine = false) {
  const lines = (Array.isArray(description) ? description.filter((d2) => !d2.includes("eslint-disable")) : [description || ""]).map((line) => line.replace(regex, replacement));
  const count2 = [description, deprecated, summary].reduce(
    (acc, it) => it ? acc + 1 : acc,
    0
  );
  if (!count2) {
    return "";
  }
  const oneLine = count2 === 1 && tryOneLine;
  const eslintDisable = Array.isArray(description) ? description.find((d2) => d2.includes("eslint-disable"))?.replace(regex, replacement) : void 0;
  let doc = `${eslintDisable ? `/* ${eslintDisable} */
` : ""}/**`;
  if (description) {
    if (!oneLine) {
      doc += `
${tryOneLine ? "  " : ""} *`;
    }
    doc += ` ${lines.join("\n * ")}`;
  }
  if (deprecated) {
    if (!oneLine) {
      doc += `
${tryOneLine ? "  " : ""} *`;
    }
    doc += " @deprecated";
  }
  if (summary) {
    if (!oneLine) {
      doc += `
${tryOneLine ? "  " : ""} *`;
    }
    doc += ` @summary ${summary.replace(regex, replacement)}`;
  }
  doc += !oneLine ? `
 ${tryOneLine ? "  " : ""}` : " ";
  doc += "*/\n";
  return doc;
}

// src/utils/dynamic-import.ts
var dynamicImport = async (toImport, from = process.cwd(), takeDefault = true) => {
  if (!toImport) {
    return toImport;
  }
  try {
    if (isString2(toImport)) {
      const path2 = resolve2(from, toImport);
      const data = await import(path2);
      if (takeDefault && (isObject(data) || isModule(data)) && data.default) {
        return data.default;
      }
      return data;
    }
    return Promise.resolve(toImport);
  } catch (error) {
    throw `Oups... \u{1F37B}. Path: ${toImport} => ${error}`;
  }
};

// src/utils/fileExtensions.ts
var getMockFileExtensionByTypeName = (mock) => {
  if (isFunction2(mock)) {
    return "msw";
  }
  switch (mock.type) {
    default:
      return "msw";
  }
};

// src/utils/merge-deep.ts
var isObject2 = (obj) => obj && typeof obj === "object";
function mergeDeep(source, target) {
  if (!isObject2(target) || !isObject2(source)) {
    return source;
  }
  return Object.entries(target).reduce((acc, [key, value]) => {
    const sourceValue = acc[key];
    if (Array.isArray(sourceValue) && Array.isArray(value)) {
      acc[key] = [...sourceValue, ...value];
    } else if (isObject2(sourceValue) && isObject2(value)) {
      acc[key] = mergeDeep(sourceValue, value);
    } else {
      acc[key] = value;
    }
    return acc;
  }, Object.assign({}, source));
}

// src/utils/occurrence.ts
var count = (str = "", key) => {
  if (!str) {
    return 0;
  }
  return (str.match(new RegExp(key, "g")) ?? []).length;
};

// src/utils/open-api-converter.ts
var import_chalk3 = __toESM(require("chalk"));
var import_swagger2openapi = __toESM(require("swagger2openapi"));
var openApiConverter = async (schema, options = {}, specKey) => {
  try {
    return new Promise((resolve3) => {
      if (!schema.openapi && schema.swagger === "2.0") {
        import_swagger2openapi.default.convertObj(schema, options, (err, value) => {
          if (err) {
            log(import_chalk3.default.yellow(`${specKey}
=> ${err}`));
            resolve3(schema);
          } else {
            resolve3(value.openapi);
          }
        });
      } else {
        resolve3(schema);
      }
    });
  } catch (e3) {
    throw `Oups... \u{1F37B}.
Path: ${specKey}
Parsing Error: ${e3}`;
  }
};

// src/utils/sort.ts
var sortByPriority = (arr) => arr.sort((a3, b3) => {
  if (a3.default) {
    return 1;
  }
  if (b3.default) {
    return -1;
  }
  if (a3.required && b3.required) {
    return 0;
  }
  if (a3.required) {
    return -1;
  }
  if (b3.required) {
    return 1;
  }
  return 0;
});

// src/utils/string.ts
var import_esutils = require("esutils");
var import_lodash = __toESM(require("lodash.get"));
var stringify = (data) => {
  if (isUndefined(data) || isNull(data)) {
    return;
  }
  if (isString2(data)) {
    return `'${data}'`;
  }
  if (isNumber(data) || isBoolean(data) || isFunction2(data)) {
    return `${data}`;
  }
  if (Array.isArray(data)) {
    return `[${data.map(stringify).join(", ")}]`;
  }
  return Object.entries(data).reduce((acc, [key, value], index3, arr) => {
    const strValue = stringify(value);
    if (arr.length === 1) {
      return `{ ${key}: ${strValue}, }`;
    }
    if (!index3) {
      return `{ ${key}: ${strValue}, `;
    }
    if (arr.length - 1 === index3) {
      return acc + `${key}: ${strValue}, }`;
    }
    return acc + `${key}: ${strValue}, `;
  }, "");
};
var sanitize = (value, options) => {
  const {
    whitespace = "",
    underscore = "",
    dot = "",
    dash = "",
    es5keyword = false,
    es5IdentifierName = false,
    special = false
  } = options ?? {};
  let newValue = value;
  if (special !== true) {
    newValue = newValue.replace(
      /[!"`'#%&,:;<>=@{}~\$\(\)\*\+\/\\\?\[\]\^\|]/g,
      ""
    );
  }
  if (whitespace !== true) {
    newValue = newValue.replace(/[\s]/g, whitespace);
  }
  if (underscore !== true) {
    newValue = newValue.replace(/['_']/g, underscore);
  }
  if (dot !== true) {
    newValue = newValue.replace(/[.]/g, dot);
  }
  if (dash !== true) {
    newValue = newValue.replace(/[-]/g, dash);
  }
  if (es5keyword) {
    newValue = import_esutils.keyword.isKeywordES5(newValue, true) ? `_${newValue}` : newValue;
  }
  if (es5IdentifierName) {
    if (newValue.match(/^[0-9]/)) {
      newValue = `N${newValue}`;
    } else {
      newValue = import_esutils.keyword.isIdentifierNameES5(newValue) ? newValue : `_${newValue}`;
    }
  }
  return newValue;
};
var toObjectString = (props, path2) => {
  if (!props.length) {
    return "";
  }
  const arrayOfString = path2 ? props.map((prop) => (0, import_lodash.default)(prop, path2)) : props;
  return arrayOfString.join(",\n    ") + ",";
};
var NUMBERS = {
  "0": "zero",
  "1": "one",
  "2": "two",
  "3": "three",
  "4": "four",
  "5": "five",
  "6": "six",
  "7": "seven",
  "8": "eight",
  "9": "nine"
};
var getNumberWord = (num) => {
  const arrayOfNumber = num.toString().split("");
  return arrayOfNumber.reduce((acc, n3) => acc + NUMBERS[n3], "");
};
var escape2 = (str, char = "'") => str?.replace(char, `\\${char}`);
var jsStringEscape = (input) => input.replace(/["'\\\n\r\u2028\u2029]/g, (character) => {
  switch (character) {
    case '"':
    case "'":
    case "\\":
      return "\\" + character;
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return "";
  }
});

// src/utils/tsconfig.ts
var isSyntheticDefaultImportsAllow = (config) => {
  if (!config) {
    return true;
  }
  return !!(config?.compilerOptions?.allowSyntheticDefaultImports ?? config?.compilerOptions?.esModuleInterop);
};

// src/utils/validator.ts
var ibmOpenapiRuleset = require("@ibm-cloud/openapi-ruleset");
var { Spectral } = require_dist10();
var ibmOpenapiValidator = async (specs) => {
  const spectral = new Spectral();
  spectral.setRuleset(ibmOpenapiRuleset);
  const { errors, warnings } = await spectral.run(specs);
  if (warnings.length) {
    ibmOpenapiValidatorWarnings(warnings);
  }
  if (errors.length) {
    ibmOpenapiValidatorErrors(errors);
  }
};

// src/getters/enum.ts
var getEnum = (value, enumName, names, useNativeEnums) => {
  const enumValue = useNativeEnums ? getNativeEnum(value, enumName, names) : getTypeConstEnum(value, enumName, names);
  return enumValue;
};
var getTypeConstEnum = (value, enumName, names) => {
  let enumValue = `export type ${enumName} = typeof ${enumName}[keyof typeof ${enumName}]`;
  if (value.endsWith(" | null")) {
    value = value.replace(" | null", "");
    enumValue += " | null";
  }
  enumValue += ";\n";
  const implementation = getEnumImplementation(value, names);
  enumValue += `

`;
  enumValue += "// eslint-disable-next-line @typescript-eslint/no-redeclare\n";
  enumValue += `export const ${enumName} = {
${implementation}} as const;
`;
  return enumValue;
};
var getEnumImplementation = (value, names) => {
  if (value === "")
    return "";
  return [...new Set(value.split(" | "))].reduce((acc, val, index3) => {
    const name = names?.[index3];
    if (name) {
      return acc + `  ${import_esutils2.keyword.isIdentifierNameES5(name) ? name : `'${name}'`}: ${val},
`;
    }
    let key = val.startsWith("'") ? val.slice(1, -1) : val;
    const isNumber2 = isNumeric(key);
    if (isNumber2) {
      key = toNumberKey(key);
    }
    if (key.length > 1) {
      key = sanitize(key, {
        whitespace: "_",
        underscore: true,
        dash: true,
        special: true
      });
    }
    return acc + `  ${import_esutils2.keyword.isIdentifierNameES5(key) ? key : `'${key}'`}: ${val},
`;
  }, "");
};
var getNativeEnum = (value, enumName, names) => {
  const enumItems = getNativeEnumItems(value, names);
  const enumValue = `export enum ${enumName} {
${enumItems}
}`;
  return enumValue;
};
var getNativeEnumItems = (value, names) => {
  if (value === "")
    return "";
  return [...new Set(value.split(" | "))].reduce((acc, val, index3) => {
    const name = names?.[index3];
    if (name) {
      return acc + `  ${import_esutils2.keyword.isIdentifierNameES5(name) ? name : `'${name}'`}: ${val},
`;
    }
    let key = val.startsWith("'") ? val.slice(1, -1) : val;
    const isNumber2 = isNumeric(key);
    if (isNumber2) {
      key = toNumberKey(key);
    }
    if (key.length > 1) {
      key = sanitize(key, {
        whitespace: "_",
        underscore: true,
        dash: true,
        special: true
      });
    }
    return acc + `  ${import_esutils2.keyword.isIdentifierNameES5(key) ? key : `'${key}'`}= ${val},
`;
  }, "");
};
var toNumberKey = (value) => {
  if (value[0] === "-") {
    return `NUMBER_MINUS_${value.slice(1)}`;
  }
  if (value[0] === "+") {
    return `NUMBER_PLUS_${value.slice(1)}`;
  }
  return `NUMBER_${value}`;
};

// src/resolvers/ref.ts
var import_lodash4 = __toESM(require("lodash.get"));

// src/getters/ref.ts
var import_lodash3 = __toESM(require("lodash.get"));
var RefComponentSuffix = {
  schemas: "",
  responses: "Response",
  parameters: "Parameter",
  requestBodies: "Body"
};
var regex2 = new RegExp("~1", "g");
var resolveUrl = (from, to) => {
  const resolvedUrl = new URL(to, new URL(from, "resolve://"));
  if (resolvedUrl.protocol === "resolve:") {
    const { pathname, search: search2, hash } = resolvedUrl;
    return pathname + search2 + hash;
  }
  return resolvedUrl.toString();
};
var getRefInfo = ($ref, context) => {
  const [pathname, ref] = $ref.split("#");
  const refPaths = ref?.slice(1).split("/").map((part) => part.replace(regex2, "/"));
  const suffix = refPaths ? (0, import_lodash3.default)(context.override, [...refPaths.slice(0, 2), "suffix"], "") : "";
  const originalName = ref ? refPaths[refPaths.length - 1] : path_exports.getSchemaFileName(pathname);
  if (!pathname) {
    return {
      name: pascal(originalName) + suffix,
      originalName,
      refPaths
    };
  }
  const path2 = isUrl(context.specKey) ? resolveUrl(context.specKey, pathname) : path_exports.resolve(getFileInfo(context.specKey).dirname, pathname);
  return {
    name: pascal(originalName) + suffix,
    originalName,
    specKey: path2,
    refPaths
  };
};

// src/resolvers/ref.ts
var resolveRef = (schema, context, imports = []) => {
  if (schema?.schema?.$ref) {
    const resolvedRef = resolveRef(
      schema?.schema,
      context,
      imports
    );
    if ("examples" in schema) {
      schema.examples = resolveExampleRefs(schema.examples, context);
    }
    if ("examples" in resolvedRef.schema) {
      resolvedRef.schema.examples = resolveExampleRefs(
        resolvedRef.schema.examples,
        context
      );
    }
    return {
      schema: {
        ...schema,
        schema: resolvedRef.schema
      },
      imports
    };
  }
  if (!isReference(schema)) {
    if ("examples" in schema) {
      schema.examples = resolveExampleRefs(schema.examples, context);
    }
    return { schema, imports };
  }
  const {
    currentSchema,
    refInfo: { specKey, name, originalName }
  } = getSchema(schema, context);
  if (!currentSchema) {
    throw `Oops... \u{1F37B}. Ref not found: ${schema.$ref}`;
  }
  return resolveRef(
    currentSchema,
    { ...context, specKey: specKey || context.specKey },
    [...imports, { name, specKey, schemaName: originalName }]
  );
};
function getSchema(schema, context) {
  const refInfo = getRefInfo(schema.$ref, context);
  const { specKey, refPaths } = refInfo;
  let schemaByRefPaths = refPaths && (0, import_lodash4.default)(context.specs[specKey || context.specKey], refPaths);
  if (!schemaByRefPaths) {
    schemaByRefPaths = context.specs?.[specKey || context.specKey];
  }
  if (isReference(schemaByRefPaths)) {
    return getSchema(schemaByRefPaths, context);
  }
  const currentSchema = schemaByRefPaths ? schemaByRefPaths : context.specs[specKey || context.specKey];
  return {
    currentSchema,
    refInfo
  };
}
var resolveExampleRefs = (examples, context) => {
  if (!examples) {
    return void 0;
  }
  if (Array.isArray(examples)) {
    return examples.map((example) => {
      if (isReference(example)) {
        const { schema } = resolveRef(example, context);
        return schema.value;
      }
      return example;
    });
  } else {
    return Object.entries(examples).reduce((acc, [key, example]) => {
      let schema = example;
      if (isReference(example)) {
        schema = resolveRef(example, context).schema.value;
      }
      return {
        ...acc,
        [key]: schema
      };
    }, {});
  }
};

// src/resolvers/value.ts
var resolveValue = ({
  schema,
  name,
  context
}) => {
  if (isReference(schema)) {
    const { schema: schemaObject, imports } = resolveRef(
      schema,
      context
    );
    const resolvedImport = imports[0];
    const importSpecKey = resolvedImport.specKey || (context.specKey !== context.target ? context.specKey : void 0);
    let hasReadonlyProps = false;
    if (!name || !context.parents?.includes(name)) {
      const scalar2 = getScalar({
        item: schemaObject,
        name: resolvedImport.name,
        context: {
          ...context,
          specKey: importSpecKey || context.specKey,
          ...name ? { parents: [...context.parents || [], name] } : {}
        }
      });
      hasReadonlyProps = scalar2.hasReadonlyProps;
    }
    return {
      value: resolvedImport.name,
      imports: [
        {
          name: resolvedImport.name,
          specKey: importSpecKey,
          schemaName: resolvedImport.schemaName
        }
      ],
      type: schemaObject?.type || "object",
      schemas: [],
      isEnum: !!schemaObject?.enum,
      originalSchema: schemaObject,
      hasReadonlyProps,
      isRef: true
    };
  }
  const scalar = getScalar({ item: schema, name, context });
  return {
    ...scalar,
    originalSchema: schema,
    isRef: false
  };
};

// src/resolvers/object.ts
var resolveObjectOriginal = ({
  schema,
  propName,
  combined = false,
  context
}) => {
  const resolvedValue = resolveValue({
    schema,
    name: propName,
    context
  });
  const doc = jsDoc(resolvedValue.originalSchema ?? {});
  if (propName && !resolvedValue.isEnum && resolvedValue?.type === "object" && new RegExp(/{|&|\|/).test(resolvedValue.value)) {
    return {
      value: propName,
      imports: [{ name: propName }],
      schemas: [
        ...resolvedValue.schemas,
        {
          name: propName,
          model: `${doc}export type ${propName} = ${resolvedValue.value};
`,
          imports: resolvedValue.imports
        }
      ],
      isEnum: false,
      type: "object",
      originalSchema: resolvedValue.originalSchema,
      isRef: resolvedValue.isRef,
      hasReadonlyProps: resolvedValue.hasReadonlyProps
    };
  }
  if (propName && resolvedValue.isEnum && !combined && !resolvedValue.isRef) {
    const enumValue = getEnum(
      resolvedValue.value,
      propName,
      resolvedValue.originalSchema?.["x-enumNames"],
      context.override.useNativeEnums
    );
    return {
      value: propName,
      imports: [{ name: propName }],
      schemas: [
        ...resolvedValue.schemas,
        {
          name: propName,
          model: doc + enumValue,
          imports: resolvedValue.imports
        }
      ],
      isEnum: false,
      type: "enum",
      originalSchema: resolvedValue.originalSchema,
      isRef: resolvedValue.isRef,
      hasReadonlyProps: resolvedValue.hasReadonlyProps
    };
  }
  return resolvedValue;
};
var resolveObjectCacheMap = /* @__PURE__ */ new Map();
var resolveObject = ({
  schema,
  propName,
  combined = false,
  context
}) => {
  const hashKey = JSON.stringify({
    schema,
    propName,
    combined,
    specKey: context.specKey
  });
  if (resolveObjectCacheMap.has(hashKey)) {
    return resolveObjectCacheMap.get(hashKey);
  }
  const result = resolveObjectOriginal({
    schema,
    propName,
    combined,
    context
  });
  resolveObjectCacheMap.set(hashKey, result);
  return result;
};

// src/getters/array.ts
var getArray = ({
  schema,
  name,
  context
}) => {
  if (schema.items) {
    const resolvedObject = resolveObject({
      schema: schema.items,
      propName: name + context.override.components.schemas.itemSuffix,
      context
    });
    return {
      value: `${schema.readOnly === true ? "readonly " : ""}${resolvedObject.value.includes("|") ? `(${resolvedObject.value})[]` : `${resolvedObject.value}[]`}`,
      imports: resolvedObject.imports,
      schemas: resolvedObject.schemas,
      isEnum: false,
      type: "array",
      isRef: false,
      hasReadonlyProps: resolvedObject.hasReadonlyProps,
      example: schema.example,
      examples: resolveExampleRefs(schema.examples, context)
    };
  } else {
    throw new Error("All arrays must have an `items` key define");
  }
};

// src/getters/res-req-types.ts
var import_esutils3 = require("esutils");
var import_lodash5 = __toESM(require("lodash.uniqby"));
var formDataContentTypes = ["multipart/form-data"];
var formUrlEncodedContentTypes = ["application/x-www-form-urlencoded"];
var getResReqContentTypes = ({
  mediaType,
  propName,
  context
}) => {
  if (!mediaType.schema) {
    return void 0;
  }
  const resolvedObject = resolveObject({
    schema: mediaType.schema,
    propName,
    context
  });
  return resolvedObject;
};
var getResReqTypes = (responsesOrRequests, name, context, defaultType = "unknown") => {
  const typesArray = responsesOrRequests.filter(([_2, res]) => Boolean(res)).map(([key, res]) => {
    if (isReference(res)) {
      const {
        schema: bodySchema,
        imports: [{ name: name2, specKey, schemaName }]
      } = resolveRef(res, context);
      const [contentType, mediaType] = Object.entries(bodySchema.content ?? {})[0] ?? [];
      const isFormData = formDataContentTypes.includes(contentType);
      const isFormUrlEncoded = formUrlEncodedContentTypes.includes(contentType);
      if (!isFormData && !isFormUrlEncoded || !mediaType?.schema) {
        return [
          {
            value: name2,
            imports: [{ name: name2, specKey, schemaName }],
            schemas: [],
            type: "unknown",
            isEnum: false,
            isRef: true,
            hasReadonlyProps: false,
            originalSchema: mediaType?.schema,
            example: mediaType?.example,
            examples: resolveExampleRefs(mediaType?.examples, context),
            key,
            contentType
          }
        ];
      }
      const formData = isFormData ? getSchemaFormDataAndUrlEncoded({
        name: name2,
        schemaObject: mediaType?.schema,
        context: {
          ...context,
          specKey: specKey || context.specKey
        },
        isRef: true
      }) : void 0;
      const formUrlEncoded = isFormUrlEncoded ? getSchemaFormDataAndUrlEncoded({
        name: name2,
        schemaObject: mediaType?.schema,
        context: {
          ...context,
          specKey: specKey || context.specKey
        },
        isUrlEncoded: true,
        isRef: true
      }) : void 0;
      return [
        {
          value: name2,
          imports: [{ name: name2, specKey, schemaName }],
          schemas: [],
          type: "unknown",
          isEnum: false,
          hasReadonlyProps: false,
          formData,
          formUrlEncoded,
          isRef: true,
          originalSchema: mediaType?.schema,
          example: mediaType.example,
          examples: resolveExampleRefs(mediaType.examples, context),
          key,
          contentType
        }
      ];
    }
    if (res.content) {
      const contents = Object.entries(res.content).map(
        ([contentType, mediaType], index3, arr) => {
          let propName = key ? pascal(name) + pascal(key) : void 0;
          if (propName && arr.length > 1) {
            propName = propName + pascal(getNumberWord(index3 + 1));
          }
          const resolvedValue = getResReqContentTypes({
            mediaType,
            propName,
            context
          });
          if (!resolvedValue) {
            return;
          }
          const isFormData = formDataContentTypes.includes(contentType);
          const isFormUrlEncoded = formUrlEncodedContentTypes.includes(contentType);
          if (!isFormData && !isFormUrlEncoded || !propName) {
            return {
              ...resolvedValue,
              imports: resolvedValue.imports,
              contentType,
              example: mediaType.example,
              examples: resolveExampleRefs(mediaType.examples, context)
            };
          }
          const formData = isFormData ? getSchemaFormDataAndUrlEncoded({
            name: propName,
            schemaObject: mediaType.schema,
            context
          }) : void 0;
          const formUrlEncoded = isFormUrlEncoded ? getSchemaFormDataAndUrlEncoded({
            name: propName,
            schemaObject: mediaType.schema,
            context,
            isUrlEncoded: true
          }) : void 0;
          return {
            ...resolvedValue,
            imports: resolvedValue.imports,
            formData,
            formUrlEncoded,
            contentType,
            example: mediaType.example,
            examples: resolveExampleRefs(mediaType.examples, context)
          };
        }
      );
      return contents.filter((x3) => x3).map((x3) => ({ ...x3, key }));
    }
    return [
      {
        value: defaultType,
        imports: [],
        schemas: [],
        type: defaultType,
        isEnum: false,
        key,
        isRef: false,
        hasReadonlyProps: false,
        contentType: "application/json"
      }
    ];
  });
  return (0, import_lodash5.default)(
    typesArray.flatMap((it) => it),
    "value"
  );
};
var getSchemaFormDataAndUrlEncoded = ({
  name,
  schemaObject,
  context,
  isUrlEncoded,
  isRef
}) => {
  const { schema, imports } = resolveRef(schemaObject, context);
  const propName = camel(
    !isRef && isReference(schemaObject) ? imports[0].name : name
  );
  const variableName = isUrlEncoded ? "formUrlEncoded" : "formData";
  let form = isUrlEncoded ? `const ${variableName} = new URLSearchParams();
` : `const ${variableName} = new FormData();
`;
  if (schema.type === "object") {
    if (schema.oneOf || schema.anyOf || schema.allOf) {
      const combinedSchemas = schema.oneOf || schema.anyOf || schema.allOf;
      const shouldCast = !!schema.oneOf || !!schema.anyOf;
      const combinedSchemasFormData = combinedSchemas.map((schema2) => {
        const { schema: combinedSchema, imports: imports2 } = resolveRef(
          schema2,
          context
        );
        return resolveSchemaPropertiesToFormData({
          schema: combinedSchema,
          variableName,
          propName: shouldCast ? `(${propName} as any)` : propName,
          context
        });
      }).filter((x3) => x3).join("\n");
      form += combinedSchemasFormData;
    }
    if (schema.properties) {
      const formDataValues = resolveSchemaPropertiesToFormData({
        schema,
        variableName,
        propName,
        context
      });
      form += formDataValues;
    }
    return form;
  }
  if (schema.type === "array") {
    return `${form}${propName}.forEach(value => ${variableName}.append('data', value))
`;
  }
  if (schema.type === "number" || schema.type === "boolean") {
    return `${form}${variableName}.append('data', ${propName}.toString())
`;
  }
  return `${form}${variableName}.append('data', ${propName})
`;
};
var resolveSchemaPropertiesToFormData = ({
  schema,
  variableName,
  propName,
  context
}) => {
  const formDataValues = Object.entries(schema.properties ?? {}).reduce(
    (acc, [key, value]) => {
      const { schema: property } = resolveRef(value, context);
      let formDataValue = "";
      const formatedKey = !import_esutils3.keyword.isIdentifierNameES5(key) ? `['${key}']` : `.${key}`;
      const valueKey = `${propName}${formatedKey}`;
      if (property.type === "object") {
        formDataValue = `${variableName}.append('${key}', JSON.stringify(${valueKey}));
`;
      } else if (property.type === "array") {
        formDataValue = `${valueKey}.forEach(value => ${variableName}.append('${key}', value));
`;
      } else if (property.type === "number" || property.type === "integer" || property.type === "boolean") {
        formDataValue = `${variableName}.append('${key}', ${valueKey}.toString())
`;
      } else {
        formDataValue = `${variableName}.append('${key}', ${valueKey})
`;
      }
      const isRequired = schema.required?.includes(key);
      if (property.nullable) {
        if (isRequired) {
          return acc + `if(${valueKey} !== null) {
 ${formDataValue} }
`;
        }
        return acc + `if(${valueKey} !== undefined && ${valueKey} !== null) {
 ${formDataValue} }
`;
      }
      if (isRequired) {
        return acc + formDataValue;
      }
      return acc + `if(${valueKey} !== undefined) {
 ${formDataValue} }
`;
    },
    ""
  );
  return formDataValues;
};

// src/getters/body.ts
var getBody = ({
  requestBody,
  operationName,
  context,
  contentType
}) => {
  const allBodyTypes = getResReqTypes(
    [[context.override.components.requestBodies.suffix, requestBody]],
    operationName,
    context
  );
  const filteredBodyTypes = contentType ? allBodyTypes.filter((type) => {
    let include = true;
    let exclude = false;
    if (contentType.include) {
      include = contentType.include.includes(type.contentType);
    }
    if (contentType.exclude) {
      exclude = contentType.exclude.includes(type.contentType);
    }
    return include && !exclude;
  }) : allBodyTypes;
  const imports = filteredBodyTypes.flatMap(({ imports: imports2 }) => imports2);
  const schemas = filteredBodyTypes.flatMap(({ schemas: schemas2 }) => schemas2);
  const definition = filteredBodyTypes.map(({ value }) => value).join(" | ");
  const hasReadonlyProps = filteredBodyTypes.some((x3) => x3.hasReadonlyProps);
  const nonReadonlyDefinition = hasReadonlyProps && definition ? `NonReadonly<${definition}>` : definition;
  let implementation = generalJSTypesWithArray.includes(definition.toLowerCase()) || filteredBodyTypes.length > 1 ? camel(operationName) + context.override.components.requestBodies.suffix : camel(definition);
  if (implementation) {
    implementation = sanitize(implementation, {
      underscore: "_",
      whitespace: "_",
      dash: true,
      es5keyword: true,
      es5IdentifierName: true
    });
  }
  return {
    originalSchema: requestBody,
    definition: nonReadonlyDefinition,
    implementation,
    imports,
    schemas,
    ...filteredBodyTypes.length === 1 ? {
      formData: filteredBodyTypes[0].formData,
      formUrlEncoded: filteredBodyTypes[0].formUrlEncoded,
      contentType: filteredBodyTypes[0].contentType
    } : {
      formData: "",
      formUrlEncoded: "",
      contentType: ""
    }
  };
};

// src/getters/combine.ts
var import_lodash6 = __toESM(require("lodash.omit"));

// src/getters/keys.ts
var import_esutils4 = require("esutils");
var getKey = (key) => {
  return import_esutils4.keyword.isIdentifierNameES5(key) ? key : `'${key}'`;
};

// src/getters/object.ts
var getObject = ({
  item,
  name,
  context,
  nullable
}) => {
  if (isReference(item)) {
    const { name: name2, specKey } = getRefInfo(item.$ref, context);
    return {
      value: name2 + nullable,
      imports: [{ name: name2, specKey }],
      schemas: [],
      isEnum: false,
      type: "object",
      isRef: true,
      hasReadonlyProps: item.readOnly || false,
      example: item.example,
      examples: resolveExampleRefs(item.examples, context)
    };
  }
  if (item.allOf || item.oneOf || item.anyOf) {
    const separator2 = item.allOf ? "allOf" : item.oneOf ? "oneOf" : "anyOf";
    return combineSchemas({
      schema: item,
      name,
      separator: separator2,
      context,
      nullable
    });
  }
  if (item.type instanceof Array) {
    return combineSchemas({
      schema: { anyOf: item.type.map((type) => ({ type })) },
      name,
      separator: "anyOf",
      context,
      nullable
    });
  }
  if (item.properties && Object.entries(item.properties).length > 0) {
    return Object.entries(item.properties).sort((a3, b3) => {
      return a3[0].localeCompare(b3[0]);
    }).reduce(
      (acc, [key, schema], index3, arr) => {
        const isRequired = (Array.isArray(item.required) ? item.required : []).includes(key);
        let propName = "";
        if (name) {
          const isKeyStartWithUnderscore = key.startsWith("_");
          propName += pascal(
            `${isKeyStartWithUnderscore ? "_" : ""}${name}_${key}`
          );
        }
        const allSpecSchemas = context.specs[context.target]?.components?.schemas ?? {};
        const isNameAlreadyTaken = Object.keys(allSpecSchemas).some(
          (schemaName) => pascal(schemaName) === propName
        );
        if (isNameAlreadyTaken) {
          propName = propName + "Property";
        }
        const resolvedValue = resolveObject({
          schema,
          propName,
          context
        });
        const isReadOnly = item.readOnly || schema.readOnly;
        if (!index3) {
          acc.value += "{";
        }
        const doc = jsDoc(schema, true);
        acc.hasReadonlyProps ||= isReadOnly || false;
        acc.imports.push(...resolvedValue.imports);
        acc.value += `
  ${doc ? `${doc}  ` : ""}${isReadOnly ? "readonly " : ""}${getKey(key)}${isRequired ? "" : "?"}: ${resolvedValue.value};`;
        acc.schemas.push(...resolvedValue.schemas);
        if (arr.length - 1 === index3) {
          if (item.additionalProperties) {
            if (isBoolean(item.additionalProperties)) {
              acc.value += `
  [key: string]: any;
 }`;
            } else {
              const resolvedValue2 = resolveValue({
                schema: item.additionalProperties,
                name,
                context
              });
              acc.value += `
  [key: string]: ${resolvedValue2.value};
}`;
            }
          } else {
            acc.value += "\n}";
          }
          acc.value += nullable;
        }
        return acc;
      },
      {
        imports: [],
        schemas: [],
        value: "",
        isEnum: false,
        type: "object",
        isRef: false,
        schema: {},
        hasReadonlyProps: false,
        example: item.example,
        examples: resolveExampleRefs(item.examples, context)
      }
    );
  }
  if (item.additionalProperties) {
    if (isBoolean(item.additionalProperties)) {
      return {
        value: `{ [key: string]: any }` + nullable,
        imports: [],
        schemas: [],
        isEnum: false,
        type: "object",
        isRef: false,
        hasReadonlyProps: item.readOnly || false
      };
    }
    const resolvedValue = resolveValue({
      schema: item.additionalProperties,
      name,
      context
    });
    return {
      value: `{[key: string]: ${resolvedValue.value}}` + nullable,
      imports: resolvedValue.imports ?? [],
      schemas: resolvedValue.schemas ?? [],
      isEnum: false,
      type: "object",
      isRef: false,
      hasReadonlyProps: resolvedValue.hasReadonlyProps
    };
  }
  return {
    value: (item.type === "object" ? "{ [key: string]: any }" : "unknown") + nullable,
    imports: [],
    schemas: [],
    isEnum: false,
    type: "object",
    isRef: false,
    hasReadonlyProps: item.readOnly || false
  };
};

// src/getters/scalar.ts
var getScalar = ({
  item,
  name,
  context
}) => {
  const nullable = item.nullable ? " | null" : "";
  const enumItems = item.enum?.filter((enumItem) => enumItem !== null);
  if (!item.type && item.items) {
    item.type = "array";
  }
  switch (item.type) {
    case "number":
    case "integer": {
      let value = item.format === "int64" && context.override.useBigInt ? "bigint" : "number";
      let isEnum = false;
      if (enumItems) {
        value = enumItems.map((enumItem) => `${enumItem}`).join(" | ");
        isEnum = true;
      }
      return {
        value: value + nullable,
        isEnum,
        type: "number",
        schemas: [],
        imports: [],
        isRef: false,
        hasReadonlyProps: item.readOnly || false,
        example: item.example,
        examples: resolveExampleRefs(item.examples, context)
      };
    }
    case "boolean":
      return {
        value: "boolean" + nullable,
        type: "boolean",
        isEnum: false,
        schemas: [],
        imports: [],
        isRef: false,
        hasReadonlyProps: item.readOnly || false,
        example: item.example,
        examples: resolveExampleRefs(item.examples, context)
      };
    case "array": {
      const { value, ...rest } = getArray({
        schema: item,
        name,
        context
      });
      return {
        value: value + nullable,
        ...rest
      };
    }
    case "string": {
      let value = "string";
      let isEnum = false;
      if (enumItems) {
        value = `${enumItems.map(
          (enumItem) => isString2(enumItem) ? `'${escape2(enumItem)}'` : `${enumItem}`
        ).filter(Boolean).join(` | `)}`;
        isEnum = true;
      }
      if (item.format === "binary") {
        value = "Blob";
      }
      if (context.override.useDates) {
        if (item.format === "date" || item.format === "date-time") {
          value = "Date";
        }
      }
      return {
        value: value + nullable,
        isEnum,
        type: "string",
        imports: [],
        schemas: [],
        isRef: false,
        hasReadonlyProps: item.readOnly || false,
        example: item.example,
        examples: resolveExampleRefs(item.examples, context)
      };
    }
    case "null":
      return {
        value: "null",
        isEnum: false,
        type: "null",
        imports: [],
        schemas: [],
        isRef: false,
        hasReadonlyProps: item.readOnly || false
      };
    case "object":
    default: {
      if (enumItems) {
        const value2 = `${enumItems.map(
          (enumItem) => isString2(enumItem) ? `'${escape2(enumItem)}'` : `${enumItem}`
        ).filter(Boolean).join(` | `)}`;
        return {
          value: value2 + nullable,
          isEnum: true,
          type: "string",
          imports: [],
          schemas: [],
          isRef: false,
          hasReadonlyProps: item.readOnly || false,
          example: item.example,
          examples: resolveExampleRefs(item.examples, context)
        };
      }
      const { value, ...rest } = getObject({
        item,
        name,
        context,
        nullable
      });
      return { value, ...rest };
    }
  }
};

// src/getters/combine.ts
var combineValues = ({
  resolvedData,
  resolvedValue,
  separator: separator2
}) => {
  const isAllEnums = resolvedData.isEnum.every((v2) => v2);
  if (isAllEnums) {
    return `${resolvedData.values.join(` | `)}${resolvedValue ? ` | ${resolvedValue.value}` : ""}`;
  }
  if (separator2 === "allOf") {
    return `${resolvedData.values.join(` & `)}${resolvedValue ? ` & ${resolvedValue.value}` : ""}`;
  }
  let values = resolvedData.values;
  const hasObjectSubschemas = resolvedData.allProperties.length;
  if (hasObjectSubschemas) {
    values = [];
    for (let i3 = 0; i3 < resolvedData.values.length; i3 += 1) {
      const subSchema = resolvedData.originalSchema[i3];
      if (subSchema?.type !== "object") {
        values.push(resolvedData.values[i3]);
        continue;
      }
      const missingProperties = resolvedData.allProperties.filter(
        (p2) => !Object.keys(subSchema.properties).includes(p2)
      );
      values.push(
        `${resolvedData.values[i3]}${missingProperties.length ? ` & {${missingProperties.map((p2) => `${p2}?: never`).join("; ")}}` : ""}`
      );
    }
  }
  if (resolvedValue) {
    return `(${values.join(` & ${resolvedValue.value}) | (`)} & ${resolvedValue.value})`;
  }
  return values.join(" | ");
};
var combineSchemas = ({
  name,
  schema,
  separator: separator2,
  context,
  nullable
}) => {
  const items = schema[separator2] ?? [];
  const resolvedData = items.reduce(
    (acc, subSchema) => {
      let propName = name ? name + pascal(separator2) : void 0;
      if (propName && acc.schemas.length) {
        propName = propName + pascal(getNumberWord(acc.schemas.length + 1));
      }
      const resolvedValue2 = resolveObject({
        schema: subSchema,
        propName,
        combined: true,
        context
      });
      acc.values.push(resolvedValue2.value);
      acc.imports.push(...resolvedValue2.imports);
      acc.schemas.push(...resolvedValue2.schemas);
      acc.isEnum.push(resolvedValue2.isEnum);
      acc.types.push(resolvedValue2.type);
      acc.isRef.push(resolvedValue2.isRef);
      acc.originalSchema.push(resolvedValue2.originalSchema);
      acc.hasReadonlyProps ||= resolvedValue2.hasReadonlyProps;
      if (resolvedValue2.type === "object") {
        acc.allProperties.push(
          ...Object.keys(resolvedValue2.originalSchema.properties)
        );
      }
      return acc;
    },
    {
      values: [],
      imports: [],
      schemas: [],
      isEnum: [],
      // check if only enums
      isRef: [],
      types: [],
      originalSchema: [],
      allProperties: [],
      hasReadonlyProps: false,
      example: schema.example,
      examples: resolveExampleRefs(schema.examples, context)
    }
  );
  const isAllEnums = resolvedData.isEnum.every((v2) => v2);
  let resolvedValue;
  if (schema.properties) {
    resolvedValue = getScalar({ item: (0, import_lodash6.default)(schema, separator2), name, context });
  }
  const value = combineValues({ resolvedData, separator: separator2, resolvedValue });
  if (isAllEnums && name && items.length > 1) {
    const newEnum = `

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ${pascal(
      name
    )} = ${getCombineEnumValue(resolvedData)}`;
    return {
      value: `typeof ${pascal(name)}[keyof typeof ${pascal(name)}] ${nullable};` + newEnum,
      imports: resolvedData.imports.map((toImport) => ({
        ...toImport,
        values: true
      })),
      schemas: resolvedData.schemas,
      isEnum: false,
      type: "object",
      isRef: false,
      hasReadonlyProps: resolvedData.hasReadonlyProps,
      example: schema.example,
      examples: resolveExampleRefs(schema.examples, context)
    };
  }
  return {
    value: value + nullable,
    imports: resolvedValue ? [...resolvedData.imports, ...resolvedValue.imports] : resolvedData.imports,
    schemas: resolvedValue ? [...resolvedData.schemas, ...resolvedValue.schemas] : resolvedData.schemas,
    isEnum: false,
    type: "object",
    isRef: false,
    hasReadonlyProps: resolvedData?.hasReadonlyProps || resolvedValue?.hasReadonlyProps || false,
    example: schema.example,
    examples: resolveExampleRefs(schema.examples, context)
  };
};
var getCombineEnumValue = ({
  values,
  isRef,
  originalSchema
}) => {
  if (values.length === 1) {
    if (isRef[0]) {
      return values[0];
    }
    return `{${getEnumImplementation(values[0])}} as const`;
  }
  const enums = values.map((e3, i3) => {
    if (isRef[i3]) {
      return `...${e3},`;
    }
    const names = originalSchema[i3]?.["x-enumNames"];
    return getEnumImplementation(e3, names);
  }).join("");
  return `{${enums}} as const`;
};

// src/getters/discriminators.ts
var resolveDiscriminators = (schemas, context) => {
  const transformedSchemas = { ...schemas };
  for (const schema of Object.values(transformedSchemas)) {
    if (schema.discriminator?.mapping) {
      const { mapping, propertyName } = schema.discriminator;
      for (const [mappingKey, mappingValue] of Object.entries(mapping)) {
        let subTypeSchema;
        try {
          const { originalName } = getRefInfo(mappingValue, context);
          const name = pascal(originalName);
          subTypeSchema = transformedSchemas[name];
        } catch (e3) {
          subTypeSchema = transformedSchemas[mappingValue];
        }
        if (!subTypeSchema) {
          continue;
        }
        subTypeSchema.properties = {
          ...subTypeSchema.properties,
          [propertyName]: {
            type: "string",
            enum: [mappingKey]
          }
        };
        subTypeSchema.required = [
          ...subTypeSchema.required ?? [],
          propertyName
        ];
      }
    }
  }
  return transformedSchemas;
};

// src/getters/operation.ts
var getOperationId = (operation, route, verb) => {
  if (operation.operationId) {
    return operation.operationId;
  }
  return pascal(
    [
      verb,
      ...route.split("/").map(
        (p2) => sanitize(p2, {
          dash: true,
          underscore: "-",
          dot: "-",
          whitespace: "-"
        })
      )
    ].join("-")
  );
};

// src/getters/parameters.ts
var getParameters = ({
  parameters = [],
  context
}) => {
  return parameters.reduce(
    (acc, p2) => {
      if (isReference(p2)) {
        const { schema: parameter, imports } = resolveRef(
          p2,
          context
        );
        if (parameter.in === "path" || parameter.in === "query" || parameter.in === "header") {
          acc[parameter.in].push({ parameter, imports });
        }
      } else {
        if (p2.in === "query" || p2.in === "path" || p2.in === "header") {
          acc[p2.in].push({ parameter: p2, imports: [] });
        }
      }
      return acc;
    },
    {
      path: [],
      query: [],
      header: []
    }
  );
};

// src/getters/params.ts
var getParamsInPath = (path2) => {
  let n3;
  const output = [];
  const templatePathRegex = /\{(.*?)\}/g;
  while ((n3 = templatePathRegex.exec(path2)) !== null) {
    output.push(n3[1]);
  }
  return output;
};
var getParams = ({
  route,
  pathParams = [],
  operationId,
  context,
  output
}) => {
  const params = getParamsInPath(route);
  return params.map((p2) => {
    const pathParam = pathParams.find(
      ({ parameter }) => sanitize(camel(parameter.name), {
        es5keyword: true,
        underscore: true,
        dash: true
      }) === p2
    );
    if (!pathParam) {
      throw new Error(
        `The path params ${p2} can't be found in parameters (${operationId})`
      );
    }
    const {
      name: nameWithoutSanitize,
      required = false,
      schema
    } = pathParam.parameter;
    const name = sanitize(camel(nameWithoutSanitize), { es5keyword: true });
    if (!schema) {
      return {
        name,
        definition: `${name}${!required ? "?" : ""}: unknown`,
        implementation: `${name}${!required ? "?" : ""}: unknown`,
        default: false,
        required,
        imports: []
      };
    }
    const resolvedValue = resolveValue({
      schema,
      context: {
        ...context,
        ...pathParam.imports.length ? {
          specKey: pathParam.imports[0].specKey
        } : {}
      }
    });
    let paramType = resolvedValue.value;
    if (output.allParamsOptional) {
      paramType = `${paramType} | undefined | null`;
    }
    const definition = `${name}${!required || resolvedValue.originalSchema.default ? "?" : ""}: ${resolvedValue.value}`;
    const implementation = `${name}${!required && !resolvedValue.originalSchema.default ? "?" : ""}${!resolvedValue.originalSchema.default ? `: ${paramType}` : `: ${paramType} = ${stringify(resolvedValue.originalSchema.default)}`}`;
    return {
      name,
      definition,
      implementation,
      default: resolvedValue.originalSchema.default,
      required,
      imports: resolvedValue.imports,
      originalSchema: resolvedValue.originalSchema
    };
  });
};

// src/getters/props.ts
var getProps = ({
  body,
  queryParams,
  params,
  operationName,
  headers,
  context
}) => {
  const bodyProp = {
    name: body.implementation,
    definition: `${body.implementation}: ${body.definition}`,
    implementation: `${body.implementation}: ${body.definition}`,
    default: false,
    required: true,
    type: GetterPropType.BODY
  };
  const queryParamsProp = {
    name: "params",
    definition: `params${queryParams?.isOptional ? "?" : ""}: ${queryParams?.schema.name}`,
    implementation: `params${queryParams?.isOptional ? "?" : ""}: ${queryParams?.schema.name}`,
    default: false,
    required: !isUndefined(queryParams?.isOptional) ? !queryParams?.isOptional : false,
    type: GetterPropType.QUERY_PARAM
  };
  const headersProp = {
    name: "headers",
    definition: `headers${headers?.isOptional ? "?" : ""}: ${headers?.schema.name}`,
    implementation: `headers${headers?.isOptional ? "?" : ""}: ${headers?.schema.name}`,
    default: false,
    required: !isUndefined(headers?.isOptional) ? !headers?.isOptional : false,
    type: GetterPropType.HEADER
  };
  let paramGetterProps;
  if (context.override.useNamedParameters && params.length > 0) {
    const parameterTypeName = `${pascal(operationName)}PathParameters`;
    const name = "pathParams";
    const namedParametersTypeDefinition = `export type ${parameterTypeName} = {
 ${params.map((property) => property.definition).join(",\n    ")},
 }`;
    const isOptional = params.every((param) => param.default);
    const implementation = `{ ${params.map(
      (property) => property.default ? `${property.name} = ${property.default}` : property.name
    ).join(", ")} }: ${parameterTypeName}${isOptional ? " = {}" : ""}`;
    const destructured = `{ ${params.map((property) => property.name).join(", ")} }`;
    paramGetterProps = [
      {
        type: GetterPropType.NAMED_PATH_PARAMS,
        name,
        definition: `${name}: ${parameterTypeName}`,
        implementation,
        default: false,
        destructured,
        required: true,
        schema: {
          name: parameterTypeName,
          model: namedParametersTypeDefinition,
          imports: params.flatMap((property) => property.imports)
        }
      }
    ];
  } else {
    paramGetterProps = params.map((param) => ({
      ...param,
      type: GetterPropType.PARAM
    }));
  }
  const props = [
    ...paramGetterProps,
    ...body.definition ? [bodyProp] : [],
    ...queryParams ? [queryParamsProp] : [],
    ...headers ? [headersProp] : []
  ];
  const sortedProps = sortByPriority(props);
  return sortedProps;
};

// src/getters/query-params.ts
var getQueryParamsTypes = (queryParams, operationName, context) => {
  return queryParams.map(({ parameter, imports: parameterImports }) => {
    const {
      name,
      required,
      schema: schemaParam,
      content
    } = parameter;
    const queryName = sanitize(`${pascal(operationName)}${pascal(name)}`, {
      underscore: "_",
      whitespace: "_",
      dash: true,
      es5keyword: true,
      es5IdentifierName: true
    });
    const schema = schemaParam || content["application/json"].schema;
    const resolvedValue = resolveValue({
      schema,
      context,
      name: queryName
    });
    const key = getKey(name);
    const doc = jsDoc(parameter);
    if (parameterImports.length) {
      return {
        definition: `${doc}${key}${!required || schema.default ? "?" : ""}: ${parameterImports[0].name};`,
        imports: parameterImports,
        schemas: [],
        originalSchema: resolvedValue.originalSchema
      };
    }
    if (resolvedValue.isEnum && !resolvedValue.isRef) {
      const enumName = queryName;
      const enumValue = getEnum(
        resolvedValue.value,
        enumName,
        resolvedValue.originalSchema?.["x-enumNames"],
        context.override.useNativeEnums
      );
      return {
        definition: `${doc}${key}${!required || schema.default ? "?" : ""}: ${enumName};`,
        imports: [{ name: enumName }],
        schemas: [
          ...resolvedValue.schemas,
          { name: enumName, model: enumValue, imports: resolvedValue.imports }
        ],
        originalSchema: resolvedValue.originalSchema
      };
    }
    const definition = `${doc}${key}${!required || schema.default ? "?" : ""}: ${resolvedValue.value};`;
    return {
      definition,
      imports: resolvedValue.imports,
      schemas: resolvedValue.schemas,
      originalSchema: resolvedValue.originalSchema
    };
  });
};
var getQueryParams = ({
  queryParams = [],
  operationName,
  context,
  suffix = "params"
}) => {
  if (!queryParams.length) {
    return;
  }
  const types = getQueryParamsTypes(queryParams, operationName, context);
  const imports = types.flatMap(({ imports: imports2 }) => imports2);
  const schemas = types.flatMap(({ schemas: schemas2 }) => schemas2);
  const name = `${pascal(operationName)}${pascal(suffix)}`;
  const type = types.map(({ definition }) => definition).join("\n");
  const allOptional = queryParams.every(({ parameter }) => !parameter.required);
  const schema = {
    name,
    model: `export type ${name} = {
${type}
};
`,
    imports
  };
  return {
    schema,
    deps: schemas,
    isOptional: allOptional
  };
};

// src/getters/response.ts
var getResponse = ({
  responses,
  operationName,
  context,
  contentType
}) => {
  if (!responses) {
    return {
      imports: [],
      definition: {
        success: "",
        errors: ""
      },
      isBlob: false,
      types: { success: [], errors: [] },
      schemas: [],
      contentTypes: []
    };
  }
  const types = getResReqTypes(
    Object.entries(responses),
    operationName,
    context,
    "void"
  );
  const filteredTypes = contentType ? types.filter((type) => {
    let include = true;
    let exclude = false;
    if (contentType.include) {
      include = contentType.include.includes(type.contentType);
    }
    if (contentType.exclude) {
      exclude = contentType.exclude.includes(type.contentType);
    }
    return include && !exclude;
  }) : types;
  const imports = filteredTypes.flatMap(({ imports: imports2 }) => imports2);
  const schemas = filteredTypes.flatMap(({ schemas: schemas2 }) => schemas2);
  const contentTypes = [
    ...new Set(filteredTypes.map(({ contentType: contentType2 }) => contentType2))
  ];
  const groupedByStatus = filteredTypes.reduce(
    (acc, type) => {
      if (type.key.startsWith("2")) {
        acc.success.push(type);
      } else {
        acc.errors.push(type);
      }
      return acc;
    },
    { success: [], errors: [] }
  );
  const success = groupedByStatus.success.map(({ value, formData }) => formData ? "Blob" : value).join(" | ");
  const errors = groupedByStatus.errors.map(({ value }) => value).join(" | ");
  const defaultType = filteredTypes.find(({ key }) => key === "default")?.value;
  return {
    imports,
    definition: {
      success: success || (defaultType ?? "unknown"),
      errors: errors || (defaultType ?? "unknown")
    },
    isBlob: success === "Blob",
    types: groupedByStatus,
    contentTypes,
    schemas,
    originalSchema: responses
  };
};

// src/getters/route.ts
var TEMPLATE_TAG_REGEX = /\${(\w+)}/g;
var TEMPLATE_TAG_IN_PATH_REGEX = /\/([\w]+)(?:\$\{)/g;
var hasParam = (path2) => /[^{]*{[\w*_-]*}.*/.test(path2);
var getRoutePath = (path2) => {
  const matches = path2.match(/([^{]*){?([\w*_-]*)}?(.*)/);
  if (!matches?.length)
    return path2;
  const prev = matches[1];
  const param = sanitize(camel(matches[2]), {
    es5keyword: true,
    underscore: true,
    dash: true,
    dot: true
  });
  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];
  if (hasParam(path2)) {
    return `${prev}\${${param}}${next}`;
  } else {
    return `${prev}${param}${next}`;
  }
};
var getRoute = (route) => {
  const splittedRoute = route.split("/");
  return splittedRoute.reduce((acc, path2, i3) => {
    if (!path2 && !i3) {
      return acc;
    }
    if (!path2.includes("{")) {
      return `${acc}/${path2}`;
    }
    return `${acc}/${getRoutePath(path2)}`;
  }, "");
};
var getRouteAsArray = (route) => route.replace(TEMPLATE_TAG_IN_PATH_REGEX, "/$1/${").split("/").filter((i3) => i3 !== "").map(
  (i3) => (
    // @note - array is mixed with string and var
    i3.includes("${") ? i3.replace(TEMPLATE_TAG_REGEX, "$1") : `'${i3}'`
  )
).join(",").replace(",,", "");

// src/generators/component-definition.ts
var generateComponentDefinition = (responses = {}, context, suffix) => {
  if ((0, import_lodash7.default)(responses)) {
    return [];
  }
  return Object.entries(responses).reduce(
    (acc, [name, response]) => {
      const allResponseTypes = getResReqTypes(
        [[suffix, response]],
        name,
        context,
        "void"
      );
      const imports = allResponseTypes.flatMap(({ imports: imports2 }) => imports2);
      const schemas = allResponseTypes.flatMap(({ schemas: schemas2 }) => schemas2);
      const type = allResponseTypes.map(({ value }) => value).join(" | ");
      const modelName = sanitize(`${pascal(name)}${suffix}`, {
        underscore: "_",
        whitespace: "_",
        dash: true,
        es5keyword: true,
        es5IdentifierName: true
      });
      const doc = jsDoc(response);
      const model = `${doc}export type ${modelName} = ${type || "unknown"};
`;
      acc.push(...schemas);
      if (modelName !== type) {
        acc.push({
          name: modelName,
          model,
          imports
        });
      }
      return acc;
    },
    []
  );
};

// src/generators/imports.ts
var import_lodash8 = __toESM(require("lodash.uniq"));
var import_lodash9 = __toESM(require("lodash.uniqwith"));
var generateImports = ({
  imports = [],
  target,
  isRootKey: isRootKey2,
  specsName,
  specKey: currentSpecKey
}) => {
  if (!imports.length) {
    return "";
  }
  return (0, import_lodash9.default)(
    imports,
    (a3, b3) => a3.name === b3.name && a3.default === b3.default && a3.specKey === b3.specKey
  ).sort().map(({ specKey, name, values, alias }) => {
    const isSameSpecKey = currentSpecKey === specKey;
    if (specKey && !isSameSpecKey) {
      const path2 = specKey !== target ? specsName[specKey] : "";
      if (!isRootKey2 && specKey) {
        return `import ${!values ? "type " : ""}{ ${name}${alias ? ` as ${alias}` : ""} } from '../${path_exports.join(path2, camel(name))}';`;
      }
      return `import ${!values ? "type " : ""}{ ${name}${alias ? ` as ${alias}` : ""} } from './${path_exports.join(path2, camel(name))}';`;
    }
    return `import ${!values ? "type " : ""}{ ${name}${alias ? ` as ${alias}` : ""} } from './${camel(name)}';`;
  }).join("\n");
};
var generateMutatorImports = ({
  mutators,
  implementation,
  oneMore
}) => {
  const imports = (0, import_lodash9.default)(
    mutators,
    (a3, b3) => a3.name === b3.name && a3.default === b3.default
  ).reduce((acc, mutator) => {
    const path2 = `${oneMore ? "../" : ""}${mutator.path}`;
    const importDefault = mutator.default ? mutator.name : `{ ${mutator.name} }`;
    acc += `import ${importDefault} from '${path2}';`;
    acc += "\n";
    if (implementation && (mutator.hasErrorType || mutator.bodyTypeName)) {
      let errorImportName = "";
      if (mutator.hasErrorType && implementation.includes(mutator.errorTypeName) && !acc.includes(mutator.errorTypeName)) {
        errorImportName = mutator.default ? `ErrorType as ${mutator.errorTypeName}` : mutator.errorTypeName;
      }
      let bodyImportName = "";
      if (mutator.bodyTypeName && implementation.includes(mutator.bodyTypeName) && !acc.includes(mutator.bodyTypeName)) {
        bodyImportName = mutator.default ? `BodyType as ${mutator.bodyTypeName}` : mutator.bodyTypeName;
      }
      if (bodyImportName || errorImportName) {
        acc += `import type { ${errorImportName}${errorImportName && bodyImportName ? ", " : ""}${bodyImportName} } from '${path2}';`;
        acc += "\n";
      }
    }
    return acc;
  }, "");
  return imports;
};
var generateDependency = ({
  deps,
  isAllowSyntheticDefaultImports,
  dependency,
  specsName,
  key,
  onlyTypes
}) => {
  const defaultDep = deps.find(
    (e3) => e3.default && (isAllowSyntheticDefaultImports || !e3.syntheticDefaultImport)
  );
  const syntheticDefaultImportDep = !isAllowSyntheticDefaultImports ? deps.find((e3) => e3.syntheticDefaultImport) : void 0;
  const depsString = (0, import_lodash8.default)(
    deps.filter((e3) => !e3.default && !e3.syntheticDefaultImport).map(({ name, alias }) => alias ? `${name} as ${alias}` : name)
  ).sort().join(",\n  ");
  let importString = "";
  const syntheticDefaultImport = syntheticDefaultImportDep ? `import * as ${syntheticDefaultImportDep.name} from '${dependency}';` : "";
  if (syntheticDefaultImport) {
    if (deps.length === 1) {
      return syntheticDefaultImport;
    }
    importString += `${syntheticDefaultImport}
`;
  }
  importString += `import ${onlyTypes ? "type " : ""}${defaultDep ? `${defaultDep.name}${depsString ? "," : ""}` : ""}${depsString ? `{
  ${depsString}
}` : ""} from '${dependency}${key !== "default" && specsName[key] ? `/${specsName[key]}` : ""}'`;
  return importString;
};
var addDependency = ({
  implementation,
  exports,
  dependency,
  specsName,
  hasSchemaDir,
  isAllowSyntheticDefaultImports
}) => {
  const toAdds = exports.filter(
    (e3) => implementation.includes(e3.alias || e3.name)
  );
  if (!toAdds.length) {
    return void 0;
  }
  const groupedBySpecKey = toAdds.reduce((acc, dep) => {
    const key = hasSchemaDir && dep.specKey ? dep.specKey : "default";
    if (dep.values && (isAllowSyntheticDefaultImports || !dep.syntheticDefaultImport)) {
      acc[key] = {
        ...acc[key],
        values: [...acc[key]?.values ?? [], dep]
      };
      return acc;
    }
    acc[key] = {
      ...acc[key],
      types: [...acc[key]?.types ?? [], dep]
    };
    return acc;
  }, {});
  return Object.entries(groupedBySpecKey).map(([key, { values, types }]) => {
    let dep = "";
    if (values) {
      dep += generateDependency({
        deps: values,
        isAllowSyntheticDefaultImports,
        dependency,
        specsName,
        key,
        onlyTypes: false
      });
    }
    if (types) {
      if (values) {
        dep += "\n";
      }
      dep += generateDependency({
        deps: types,
        isAllowSyntheticDefaultImports,
        dependency,
        specsName,
        key,
        onlyTypes: true
      });
    }
    return dep;
  }).join("\n");
};
var getLibName = (code) => {
  const splitString = code.split(" from ");
  return splitString[splitString.length - 1].split(";")[0].trim();
};
var generateDependencyImports = (implementation, imports, specsName, hasSchemaDir, isAllowSyntheticDefaultImports) => {
  const dependencies = imports.map(
    (dep) => addDependency({
      ...dep,
      implementation,
      specsName,
      hasSchemaDir,
      isAllowSyntheticDefaultImports
    })
  ).filter(Boolean).sort((a3, b3) => {
    const aLib = getLibName(a3);
    const bLib = getLibName(b3);
    if (aLib === bLib) {
      return 0;
    }
    if (aLib.startsWith("'.") && !bLib.startsWith("'.")) {
      return 1;
    }
    return aLib < bLib ? -1 : 1;
  }).join("\n");
  return dependencies ? dependencies + "\n" : "";
};
var generateVerbImports = ({
  response,
  body,
  queryParams,
  props,
  headers,
  params
}) => [
  ...response.imports,
  ...body.imports,
  ...props.flatMap(
    (prop) => prop.type === GetterPropType.NAMED_PATH_PARAMS ? [{ name: prop.schema.name }] : []
  ),
  ...queryParams ? [{ name: queryParams.schema.name }] : [],
  ...headers ? [{ name: headers.schema.name }] : [],
  ...params.flatMap(({ imports }) => imports)
];

// src/generators/models-inline.ts
var generateModelInline = (acc, model) => acc + `${model}
`;
var generateModelsInline = (obj) => {
  const schemas = Object.values(obj).flatMap((it) => it).sort((a3, b3) => a3.imports.some((i3) => i3.name === b3.name) ? 1 : -1);
  return schemas.reduce(
    (acc, { model }) => generateModelInline(acc, model),
    ""
  );
};

// src/generators/mutator.ts
var import_acorn = require("acorn");
var import_chalk4 = __toESM(require("chalk"));
var import_fs_extra = __toESM(require("fs-extra"));
var BODY_TYPE_NAME = "BodyType";
var getImport = (output, mutator) => {
  const outputFileInfo = getFileInfo(output);
  const mutatorFileInfo = getFileInfo(mutator.path);
  const { pathWithoutExtension } = getFileInfo(
    path_exports.relativeSafe(outputFileInfo.dirname, mutatorFileInfo.path)
  );
  return pathWithoutExtension;
};
var generateMutator = async ({
  output,
  mutator,
  name,
  workspace,
  tsconfig
}) => {
  if (!mutator || !output) {
    return;
  }
  const isDefault = mutator.default;
  const importName = mutator.name ? mutator.name : `${name}Mutator`;
  const importPath = mutator.path;
  let rawFile = await import_fs_extra.default.readFile(importPath, "utf8");
  rawFile = removeComments(rawFile);
  const hasErrorType = rawFile.includes("export type ErrorType") || rawFile.includes("export interface ErrorType");
  const hasBodyType = rawFile.includes(`export type ${BODY_TYPE_NAME}`) || rawFile.includes(`export interface ${BODY_TYPE_NAME}`);
  const errorTypeName = !mutator.default ? "ErrorType" : `${pascal(name)}ErrorType`;
  const bodyTypeName = !mutator.default ? BODY_TYPE_NAME : `${pascal(name)}${BODY_TYPE_NAME}`;
  const { file, cached } = await loadFile(importPath, {
    isDefault: false,
    root: workspace,
    alias: mutator.alias,
    tsconfig,
    load: false
  });
  if (file) {
    const mutatorInfoName = isDefault ? "default" : mutator.name;
    const mutatorInfo = parseFile(
      file,
      mutatorInfoName,
      getEcmaVersion(tsconfig?.compilerOptions?.target)
    );
    if (!mutatorInfo) {
      createLogger().error(
        import_chalk4.default.red(
          `Your mutator file doesn't have the ${mutatorInfoName} exported function`
        )
      );
      process.exit(1);
    }
    const path2 = getImport(output, mutator);
    const isHook = mutator.name ? !!mutator.name.startsWith("use") && !mutatorInfo.numberOfParams : !mutatorInfo.numberOfParams;
    return {
      name: mutator.name || !isHook ? importName : `use${pascal(importName)}`,
      path: path2,
      default: isDefault,
      hasErrorType,
      errorTypeName,
      hasSecondArg: !isHook ? mutatorInfo.numberOfParams > 1 : mutatorInfo.returnNumberOfParams > 1,
      hasThirdArg: mutatorInfo.numberOfParams > 2,
      isHook,
      ...hasBodyType ? { bodyTypeName } : {}
    };
  } else {
    const path2 = getImport(output, mutator);
    if (!cached) {
      createLogger().warn(
        import_chalk4.default.yellow(`Failed to parse provided mutator function`)
      );
    }
    return {
      name: importName,
      path: path2,
      default: isDefault,
      hasSecondArg: false,
      hasThirdArg: false,
      isHook: false,
      hasErrorType,
      errorTypeName,
      ...hasBodyType ? { bodyTypeName } : {}
    };
  }
};
var getEcmaVersion = (target) => {
  if (!target) {
    return;
  }
  if (target.toLowerCase() === "esnext") {
    return "latest";
  }
  try {
    return Number(target.toLowerCase().replace("es", ""));
  } catch {
    return;
  }
};
var removeComments = (file) => {
  const commentRegex = /\/\/.*|\/\*[\s\S]*?\*\//g;
  const cleanedFile = file.replace(commentRegex, "");
  return cleanedFile;
};
var parseFile = (file, name, ecmaVersion = 6) => {
  try {
    const ast = import_acorn.Parser.parse(file, { ecmaVersion });
    const node = ast?.body?.find((childNode) => {
      if (childNode.type === "ExpressionStatement") {
        if (childNode.expression.arguments?.[1]?.properties?.some(
          (p2) => p2.key?.name === name
        )) {
          return true;
        }
        if (childNode.expression.left?.property?.name === name) {
          return true;
        }
        return childNode.expression.right?.properties?.some(
          (p2) => p2.key.name === name
        );
      }
    });
    if (!node) {
      return;
    }
    if (node.expression.type === "AssignmentExpression") {
      if (node.expression.right.type === "FunctionExpression" || node.expression.right.type === "ArrowFunctionExpression") {
        return {
          numberOfParams: node.expression.right.params.length
        };
      }
      if (node.expression.right.name) {
        return parseFunction(ast, node.expression.right.name);
      }
      const property2 = node.expression.right?.properties.find(
        (p2) => p2.key.name === name
      );
      if (property2.value.name) {
        return parseFunction(ast, property2.value.name);
      }
      if (property2.value.type === "FunctionExpression" || property2.value.type === "ArrowFunctionExpression") {
        return {
          numberOfParams: property2.value.params.length
        };
      }
      return;
    }
    const property = node.expression.arguments[1].properties.find(
      (p2) => p2.key?.name === name
    );
    return parseFunction(ast, property.value.body.name);
  } catch (e3) {
    return;
  }
};
var parseFunction = (ast, name) => {
  const node = ast?.body?.find((childNode) => {
    if (childNode.type === "VariableDeclaration") {
      return childNode.declarations.find((d2) => d2.id.name === name);
    }
    if (childNode.type === "FunctionDeclaration" && childNode.id.name === name) {
      return childNode;
    }
  });
  if (!node) {
    return;
  }
  if (node.type === "FunctionDeclaration") {
    const returnStatement2 = node.body?.body?.find(
      (b3) => b3.type === "ReturnStatement"
    );
    if (returnStatement2?.argument?.params) {
      return {
        numberOfParams: node.params.length,
        returnNumberOfParams: returnStatement2.argument.params.length
      };
    }
    return {
      numberOfParams: node.params.length
    };
  }
  const declaration = node.declarations.find((d2) => d2.id.name === name);
  if (declaration.init.name) {
    return parseFunction(ast, declaration.init.name);
  }
  if (declaration.init.body.type === "ArrowFunctionExpression") {
    return {
      numberOfParams: declaration.init.params.length,
      returnNumberOfParams: declaration.init.body.params.length
    };
  }
  const returnStatement = declaration.init.body?.body?.find(
    (b3) => b3.type === "ReturnStatement"
  );
  if (returnStatement?.argument?.params) {
    return {
      numberOfParams: declaration.init.params.length,
      returnNumberOfParams: returnStatement.argument.params.length
    };
  }
  return {
    numberOfParams: declaration.init.params.length
  };
};

// src/generators/options.ts
var generateBodyOptions = (body, isFormData, isFormUrlEncoded) => {
  if (isFormData && body.formData) {
    return "\n      formData,";
  }
  if (isFormUrlEncoded && body.formUrlEncoded) {
    return "\n      formUrlEncoded,";
  }
  if (body.implementation) {
    return `
      ${body.implementation},`;
  }
  return "";
};
var generateAxiosOptions = ({
  response,
  isExactOptionalPropertyTypes,
  queryParams,
  headers,
  requestOptions,
  hasSignal,
  isVue,
  paramsSerializer,
  paramsSerializerOptions
}) => {
  const isRequestOptions = requestOptions !== false;
  if (!queryParams && !headers && !response.isBlob) {
    if (isRequestOptions) {
      return "options";
    }
    if (hasSignal) {
      return !isExactOptionalPropertyTypes ? "signal" : "...(signal ? { signal } : {})";
    }
    return "";
  }
  let value = "";
  if (!isRequestOptions) {
    if (queryParams) {
      value += "\n        params,";
    }
    if (headers) {
      value += "\n        headers,";
    }
    if (hasSignal) {
      value += !isExactOptionalPropertyTypes ? "\n        signal," : "\n        ...(signal ? { signal } : {}),";
    }
  }
  if (response.isBlob && (!isObject(requestOptions) || !requestOptions.hasOwnProperty("responseType"))) {
    value += `
        responseType: 'blob',`;
  }
  if (isObject(requestOptions)) {
    value += `
 ${stringify(requestOptions)?.slice(1, -1)}`;
  }
  if (isRequestOptions) {
    value += "\n    ...options,";
    if (queryParams) {
      if (isVue) {
        value += "\n        params: {...unref(params), ...options?.params},";
      } else {
        value += "\n        params: {...params, ...options?.params},";
      }
    }
    if (headers) {
      value += "\n        headers: {...headers, ...options?.headers},";
    }
  }
  if (queryParams && (paramsSerializer || paramsSerializerOptions?.qs)) {
    if (paramsSerializer) {
      value += `
        paramsSerializer: ${paramsSerializer.name},`;
    } else {
      value += `
        paramsSerializer: (params) => qs.stringify(params, ${JSON.stringify(
        paramsSerializerOptions.qs
      )}),`;
    }
  }
  return value;
};
var generateOptions = ({
  route,
  body,
  headers,
  queryParams,
  response,
  verb,
  requestOptions,
  isFormData,
  isFormUrlEncoded,
  isAngular,
  isExactOptionalPropertyTypes,
  hasSignal,
  isVue,
  paramsSerializer,
  paramsSerializerOptions
}) => {
  const isBodyVerb = VERBS_WITH_BODY.includes(verb);
  const bodyOptions = isBodyVerb ? generateBodyOptions(body, isFormData, isFormUrlEncoded) : "";
  const axiosOptions = generateAxiosOptions({
    response,
    queryParams: queryParams?.schema,
    headers: headers?.schema,
    requestOptions,
    isExactOptionalPropertyTypes,
    hasSignal,
    isVue: isVue ?? false,
    paramsSerializer,
    paramsSerializerOptions
  });
  const options = axiosOptions ? `{${axiosOptions}}` : "";
  if (verb === Verbs.DELETE) {
    if (!bodyOptions) {
      return `
      \`${route}\`,${axiosOptions === "options" ? axiosOptions : options}
    `;
    }
    return `
      \`${route}\`,{${isAngular ? "body" : "data"}:${bodyOptions} ${axiosOptions === "options" ? `...${axiosOptions}` : axiosOptions}}
    `;
  }
  return `
      \`${route}\`,${isBodyVerb ? bodyOptions || "undefined," : ""}${axiosOptions === "options" ? axiosOptions : options}
    `;
};
var generateBodyMutatorConfig = (body, isFormData, isFormUrlEncoded) => {
  if (isFormData && body.formData) {
    return ",\n       data: formData";
  }
  if (isFormUrlEncoded && body.formUrlEncoded) {
    return ",\n       data: formUrlEncoded";
  }
  if (body.implementation) {
    return `,
      data: ${body.implementation}`;
  }
  return "";
};
var generateQueryParamsAxiosConfig = (response, isVue, queryParams) => {
  if (!queryParams && !response.isBlob) {
    return "";
  }
  let value = "";
  if (queryParams) {
    if (isVue) {
      value += ",\n        params: unref(params)";
    } else {
      value += ",\n        params";
    }
  }
  if (response.isBlob) {
    value += `,
        responseType: 'blob'`;
  }
  return value;
};
var generateMutatorConfig = ({
  route,
  body,
  headers,
  queryParams,
  response,
  verb,
  isFormData,
  isFormUrlEncoded,
  isBodyVerb,
  hasSignal,
  isExactOptionalPropertyTypes,
  isVue
}) => {
  const bodyOptions = isBodyVerb ? generateBodyMutatorConfig(body, isFormData, isFormUrlEncoded) : "";
  const queryParamsOptions = generateQueryParamsAxiosConfig(
    response,
    isVue ?? false,
    queryParams
  );
  const headerOptions = body.contentType ? `,
      headers: {'Content-Type': '${body.contentType}', ${headers ? "...headers" : ""}}` : headers ? ",\n      headers" : "";
  return `{url: \`${route}\`, method: '${verb.toUpperCase()}'${headerOptions}${bodyOptions}${queryParamsOptions}${!isBodyVerb && hasSignal ? `, ${isExactOptionalPropertyTypes ? "...(signal ? { signal }: {})" : "signal"}` : ""}
    }`;
};
var generateMutatorRequestOptions = (requestOptions, hasSecondArgument) => {
  if (!hasSecondArgument) {
    return isObject(requestOptions) ? `{${stringify(requestOptions)?.slice(1, -1)}}` : "";
  }
  if (isObject(requestOptions)) {
    return `{${stringify(requestOptions)?.slice(1, -1)} ...options}`;
  }
  return "options";
};
var generateFormDataAndUrlEncodedFunction = ({
  body,
  formData,
  formUrlEncoded,
  isFormData,
  isFormUrlEncoded
}) => {
  if (isFormData && body.formData) {
    if (formData) {
      return `const formData = ${formData.name}(${body.implementation})`;
    }
    return body.formData;
  }
  if (isFormUrlEncoded && body.formUrlEncoded) {
    if (formUrlEncoded) {
      return `const formUrlEncoded = ${formUrlEncoded.name}(${body.implementation})`;
    }
    return body.formUrlEncoded;
  }
  return "";
};

// src/generators/parameter-definition.ts
var generateParameterDefinition = (parameters = {}, context, suffix) => {
  return Object.entries(parameters).reduce(
    (acc, [parameterName, parameter]) => {
      const modelName = sanitize(`${pascal(parameterName)}${suffix}`, {
        underscore: "_",
        whitespace: "_",
        dash: true,
        es5keyword: true,
        es5IdentifierName: true
      });
      const { schema, imports } = resolveRef(
        parameter,
        context
      );
      if (schema.in !== "query") {
        return acc;
      }
      if (!schema.schema || imports.length) {
        acc.push({
          name: modelName,
          imports: imports.length ? [
            {
              name: imports[0].name,
              specKey: imports[0].specKey,
              schemaName: imports[0].schemaName
            }
          ] : [],
          model: `export type ${modelName} = ${imports.length ? imports[0].name : "unknown"};
`
        });
        return acc;
      }
      const resolvedObject = resolveObject({
        schema: schema.schema,
        propName: modelName,
        context
      });
      const doc = jsDoc(parameter);
      const model = `${doc}export type ${modelName} = ${resolvedObject.value || "unknown"};
`;
      acc.push(...resolvedObject.schemas);
      if (modelName !== resolvedObject.value) {
        acc.push({
          name: modelName,
          model,
          imports: resolvedObject.imports
        });
      }
      return acc;
    },
    []
  );
};

// src/generators/schema-definition.ts
var import_lodash10 = __toESM(require("lodash.isempty"));

// src/generators/interface.ts
var generateInterface = ({
  name,
  schema,
  context,
  suffix
}) => {
  const scalar = getScalar({
    item: schema,
    name,
    context
  });
  const isEmptyObject = scalar.value === "{}";
  let model = "";
  model += jsDoc(schema);
  if (isEmptyObject) {
    if (context.tslint) {
      model += "// tslint:disable-next-line:no-empty-interface\n";
    } else {
      model += "// eslint-disable-next-line @typescript-eslint/no-empty-interface\n";
    }
  }
  if (!generalJSTypesWithArray.includes(scalar.value) && !context?.override?.useTypeOverInterfaces) {
    model += `export interface ${name} ${scalar.value}
`;
  } else {
    model += `export type ${name} = ${scalar.value};
`;
  }
  const externalModulesImportsOnly = scalar.imports.filter(
    (importName) => importName.name !== name
  );
  return [
    ...scalar.schemas,
    {
      name,
      model,
      imports: externalModulesImportsOnly
    }
  ];
};

// src/generators/schema-definition.ts
var generateSchemasDefinition = (schemas = {}, context, suffix) => {
  if ((0, import_lodash10.default)(schemas)) {
    return [];
  }
  const transformedSchemas = resolveDiscriminators(schemas, context);
  const models = Object.entries(transformedSchemas).reduce(
    (acc, [name, schema]) => {
      const schemaName = sanitize(`${pascal(name)}${suffix}`, {
        underscore: "_",
        whitespace: "_",
        dash: true,
        es5keyword: true,
        es5IdentifierName: true
      });
      if (shouldCreateInterface(schema)) {
        acc.push(
          ...generateInterface({
            name: schemaName,
            schema,
            context,
            suffix
          })
        );
        return acc;
      } else {
        const resolvedValue = resolveValue({
          schema,
          name: schemaName,
          context
        });
        let output = "";
        let imports = resolvedValue.imports;
        output += jsDoc(schema);
        if (resolvedValue.isEnum && !resolvedValue.isRef) {
          output += getEnum(
            resolvedValue.value,
            schemaName,
            resolvedValue.originalSchema?.["x-enumNames"],
            context.override.useNativeEnums
          );
        } else if (schemaName === resolvedValue.value && resolvedValue.isRef) {
          const { schema: referredSchema } = resolveRef(schema, context);
          if (!shouldCreateInterface(referredSchema)) {
            const imp = resolvedValue.imports.find(
              (imp2) => imp2.name === schemaName
            );
            if (!imp) {
              output += `export type ${schemaName} = ${resolvedValue.value};
`;
            } else {
              const alias = imp?.specKey ? `${pascal(path_exports.getSpecName(imp.specKey, context.specKey))}${resolvedValue.value}` : `${resolvedValue.value}Bis`;
              output += `export type ${schemaName} = ${alias};
`;
              imports = imports.map(
                (imp2) => imp2.name === schemaName ? { ...imp2, alias } : imp2
              );
            }
          }
        } else {
          output += `export type ${schemaName} = ${resolvedValue.value};
`;
        }
        acc.push(...resolvedValue.schemas, {
          name: schemaName,
          model: output,
          imports
        });
        return acc;
      }
    },
    []
  );
  return models;
};
function shouldCreateInterface(schema) {
  return (!schema.type || schema.type === "object") && !schema.allOf && !schema.oneOf && !schema.anyOf && !isReference(schema) && !schema.nullable && !schema.enum;
}

// src/generators/verbs-options.ts
var generateVerbOptions = async ({
  verb,
  output,
  operation,
  route,
  verbParameters = [],
  context
}) => {
  const {
    responses,
    requestBody,
    parameters: operationParameters,
    tags = [],
    deprecated,
    description,
    summary
  } = operation;
  const operationId = getOperationId(operation, route, verb);
  const overrideOperation = output.override.operations[operation.operationId];
  const overrideTag = Object.entries(output.override.tags).reduce(
    (acc, [tag, options]) => tags.includes(tag) ? mergeDeep(acc, options) : acc,
    {}
  );
  const override = {
    ...output.override,
    ...overrideTag,
    ...overrideOperation
  };
  const overrideOperationName = overrideOperation?.operationName || output.override?.operationName;
  const overriddenOperationName = overrideOperationName ? overrideOperationName(operation, route, verb) : camel(operationId);
  const operationName = sanitize(overriddenOperationName, { es5keyword: true });
  const response = getResponse({
    responses,
    operationName,
    context,
    contentType: override.contentType
  });
  const body = getBody({
    requestBody,
    operationName,
    context,
    contentType: override.contentType
  });
  const parameters = getParameters({
    parameters: [...verbParameters, ...operationParameters ?? []],
    context
  });
  const queryParams = getQueryParams({
    queryParams: parameters.query,
    operationName,
    context
  });
  const headers = output.headers ? await getQueryParams({
    queryParams: parameters.header,
    operationName,
    context,
    suffix: "headers"
  }) : void 0;
  const params = getParams({
    route,
    pathParams: parameters.path,
    operationId,
    context,
    output
  });
  const props = getProps({
    body,
    queryParams,
    params,
    headers,
    operationName,
    context
  });
  const mutator = await generateMutator({
    output: output.target,
    name: operationName,
    mutator: override?.mutator,
    workspace: context.workspace,
    tsconfig: context.tsconfig
  });
  const formData = isString2(override?.formData) || isObject(override?.formData) ? await generateMutator({
    output: output.target,
    name: operationName,
    mutator: override.formData,
    workspace: context.workspace,
    tsconfig: context.tsconfig
  }) : void 0;
  const formUrlEncoded = isString2(override?.formUrlEncoded) || isObject(override?.formUrlEncoded) ? await generateMutator({
    output: output.target,
    name: operationName,
    mutator: override.formUrlEncoded,
    workspace: context.workspace,
    tsconfig: context.tsconfig
  }) : void 0;
  const paramsSerializer = isString2(override?.paramsSerializer) || isObject(override?.paramsSerializer) ? await generateMutator({
    output: output.target,
    name: "paramsSerializer",
    mutator: override.paramsSerializer,
    workspace: context.workspace,
    tsconfig: context.tsconfig
  }) : void 0;
  const doc = jsDoc({ description, deprecated, summary });
  const verbOption = {
    verb,
    tags,
    summary: operation.summary,
    operationId,
    operationName,
    response,
    body,
    headers,
    queryParams,
    params,
    props,
    mutator,
    formData,
    formUrlEncoded,
    paramsSerializer,
    override,
    doc,
    deprecated,
    originalOperation: operation
  };
  const transformer = await dynamicImport(
    override?.transformer,
    context.workspace
  );
  return transformer ? transformer(verbOption) : verbOption;
};
var generateVerbsOptions = ({
  verbs,
  input,
  output,
  route,
  context
}) => asyncReduce(
  _filteredVerbs(verbs, input.filters),
  async (acc, [verb, operation]) => {
    if (isVerb(verb)) {
      const verbOptions = await generateVerbOptions({
        verb,
        output,
        verbParameters: verbs.parameters,
        route,
        operation,
        context
      });
      acc.push(verbOptions);
    }
    return acc;
  },
  []
);
var _filteredVerbs = (verbs, filters) => {
  if (filters === void 0 || filters.tags === void 0) {
    return Object.entries(verbs);
  }
  return Object.entries(verbs).filter(
    ([_verb, operation]) => {
      const operationTags = operation.tags || [];
      const filterTags = filters.tags || [];
      return operationTags.some(
        (tag) => filterTags.some(
          (filterTag) => filterTag instanceof RegExp ? filterTag.test(tag) : filterTag === tag
        )
      );
    }
  );
};

// src/writers/schemas.ts
var import_fs_extra2 = __toESM(require("fs-extra"));
var getSchema2 = ({
  schema: { imports, model },
  target,
  isRootKey: isRootKey2,
  specsName,
  header,
  specKey
}) => {
  let file = header;
  file += generateImports({
    imports: imports.filter(
      (imp) => !model.includes(`type ${imp.alias || imp.name} =`) && !model.includes(`interface ${imp.alias || imp.name} {`)
    ),
    target,
    isRootKey: isRootKey2,
    specsName,
    specKey
  });
  file += imports.length ? "\n\n" : "\n";
  file += model;
  return file;
};
var getPath = (path2, name) => path_exports.join(path2, `/${name}.ts`);
var writeModelInline = (acc, model) => acc + `${model}
`;
var writeModelsInline = (array) => array.reduce((acc, { model }) => writeModelInline(acc, model), "");
var writeSchema = async ({
  path: path2,
  schema,
  target,
  specKey,
  isRootKey: isRootKey2,
  specsName,
  header
}) => {
  const name = camel(schema.name);
  try {
    await import_fs_extra2.default.outputFile(
      getPath(path2, name),
      getSchema2({ schema, target, isRootKey: isRootKey2, specsName, header, specKey })
    );
  } catch (e3) {
    throw `Oups... \u{1F37B}. An Error occurred while writing schema ${name} => ${e3}`;
  }
};
var writeSchemas = async ({
  schemaPath,
  schemas,
  target,
  specKey,
  isRootKey: isRootKey2,
  specsName,
  header,
  indexFiles
}) => {
  await Promise.all(
    schemas.map(
      (schema) => writeSchema({
        path: schemaPath,
        schema,
        target,
        specKey,
        isRootKey: isRootKey2,
        specsName,
        header
      })
    )
  );
  if (indexFiles) {
    const schemaFilePath = path_exports.join(schemaPath, "/index.ts");
    await import_fs_extra2.default.ensureFile(schemaFilePath);
    const schemaNamesSet = /* @__PURE__ */ new Set();
    const duplicateNamesMap = /* @__PURE__ */ new Map();
    schemas.forEach((schema) => {
      if (!schemaNamesSet.has(schema.name)) {
        schemaNamesSet.add(schema.name);
      } else {
        duplicateNamesMap.set(
          schema.name,
          (duplicateNamesMap.get(schema.name) || 0) + 1
        );
      }
    });
    if (duplicateNamesMap.size) {
      throw new Error(
        "Duplicate schema names detected:\n" + Array.from(duplicateNamesMap).map((duplicate) => `  ${duplicate[1]}x ${duplicate[0]}`).join("\n")
      );
    }
    try {
      const data = await import_fs_extra2.default.readFile(schemaFilePath);
      const stringData = data.toString();
      const importStatements = schemas.filter((schema) => {
        return !stringData.includes(`export * from './${camel(schema.name)}'`) && !stringData.includes(`export * from "./${camel(schema.name)}"`);
      }).map((schema) => `export * from './${camel(schema.name)}';`);
      const currentFileExports = stringData.match(/export \* from(.*)('|")/g)?.map((s2) => s2 + ";") ?? [];
      const exports = [...currentFileExports, ...importStatements].sort().join("\n");
      const fileContent = `${header}
${exports}`;
      await import_fs_extra2.default.writeFile(schemaFilePath, fileContent);
    } catch (e3) {
      throw `Oups... \u{1F37B}. An Error occurred while writing schema index file ${schemaFilePath} => ${e3}`;
    }
  }
};

// src/writers/types.ts
var getOrvalGeneratedTypes = () => `
// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;
`;

// src/writers/single-mode.ts
var import_fs_extra3 = __toESM(require("fs-extra"));

// src/writers/target.ts
var generateTarget = (builder, options) => {
  const operationNames = Object.values(builder.operations).map(
    ({ operationName }) => operationName
  );
  const isAngularClient = options?.client === OutputClient.ANGULAR;
  const titles = builder.title({
    outputClient: options.client,
    title: pascal(builder.info.title),
    customTitleFunc: options.override.title,
    output: options
  });
  const target = Object.values(builder.operations).reduce(
    (acc, operation, index3, arr) => {
      acc.imports.push(...operation.imports);
      acc.importsMock.push(...operation.importsMock);
      acc.implementation += operation.implementation + "\n";
      acc.implementationMock.function += operation.implementationMock.function;
      acc.implementationMock.handler += operation.implementationMock.handler;
      if (operation.mutator) {
        acc.mutators.push(operation.mutator);
      }
      if (operation.formData) {
        acc.formData.push(operation.formData);
      }
      if (operation.formUrlEncoded) {
        acc.formUrlEncoded.push(operation.formUrlEncoded);
      }
      if (operation.paramsSerializer) {
        acc.paramsSerializer.push(operation.paramsSerializer);
      }
      if (operation.clientMutators) {
        acc.clientMutators.push(...operation.clientMutators);
      }
      if (index3 === arr.length - 1) {
        const isMutator = acc.mutators.some(
          (mutator) => isAngularClient ? mutator.hasThirdArg : mutator.hasSecondArg
        );
        const typescriptVersion = options.packageJson?.dependencies?.["typescript"] ?? options.packageJson?.devDependencies?.["typescript"] ?? "4.4.0";
        const hasAwaitedType = compareVersions(typescriptVersion, "4.5.0");
        const header = builder.header({
          outputClient: options.client,
          isRequestOptions: options.override.requestOptions !== false,
          isMutator,
          isGlobalMutator: !!options.override.mutator,
          provideIn: options.override.angular.provideIn,
          hasAwaitedType,
          titles,
          output: options
        });
        acc.implementation = header.implementation + acc.implementation;
        acc.implementationMock.handler = header.implementationMock + acc.implementationMock.handler;
        const footer = builder.footer({
          outputClient: options?.client,
          operationNames,
          hasMutator: !!acc.mutators.length,
          hasAwaitedType,
          titles,
          output: options
        });
        acc.implementation += footer.implementation;
        acc.implementationMock.handler += footer.implementationMock;
      }
      return acc;
    },
    {
      imports: [],
      implementation: "",
      implementationMock: {
        function: "",
        handler: ""
      },
      importsMock: [],
      mutators: [],
      clientMutators: [],
      formData: [],
      formUrlEncoded: [],
      paramsSerializer: []
    }
  );
  return {
    ...target,
    implementationMock: target.implementationMock.function + target.implementationMock.handler
  };
};

// src/writers/single-mode.ts
var writeSingleMode = async ({
  builder,
  output,
  specsName,
  header,
  needSchema
}) => {
  try {
    const { path: path2, dirname: dirname3 } = getFileInfo(output.target, {
      backupFilename: camel(builder.info.title)
    });
    const {
      imports,
      importsMock,
      implementation,
      implementationMock,
      mutators,
      clientMutators,
      formData,
      formUrlEncoded,
      paramsSerializer
    } = generateTarget(builder, output);
    let data = header;
    const schemasPath = output.schemas ? path_exports.relativeSafe(dirname3, getFileInfo(output.schemas).dirname) : void 0;
    const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(
      output.tsconfig
    );
    data += builder.imports({
      client: output.client,
      implementation,
      imports: schemasPath ? [
        {
          exports: imports.filter(
            (imp) => !importsMock.some((impMock) => imp.name === impMock.name)
          ),
          dependency: schemasPath
        }
      ] : [],
      specsName,
      hasSchemaDir: !!output.schemas,
      isAllowSyntheticDefaultImports,
      hasGlobalMutator: !!output.override.mutator,
      hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,
      packageJson: output.packageJson,
      output
    });
    if (output.mock) {
      data += builder.importsMock({
        implementation: implementationMock,
        imports: schemasPath ? [{ exports: importsMock, dependency: schemasPath }] : [],
        specsName,
        hasSchemaDir: !!output.schemas,
        isAllowSyntheticDefaultImports,
        options: !isFunction2(output.mock) ? output.mock : void 0
      });
    }
    if (mutators) {
      data += generateMutatorImports({ mutators, implementation });
    }
    if (clientMutators) {
      data += generateMutatorImports({ mutators: clientMutators });
    }
    if (formData) {
      data += generateMutatorImports({ mutators: formData });
    }
    if (formUrlEncoded) {
      data += generateMutatorImports({ mutators: formUrlEncoded });
    }
    if (paramsSerializer) {
      data += generateMutatorImports({ mutators: paramsSerializer });
    }
    if (implementation.includes("NonReadonly<")) {
      data += getOrvalGeneratedTypes();
      data += "\n";
    }
    if (!output.schemas && needSchema) {
      data += generateModelsInline(builder.schemas);
    }
    data += `

${implementation}`;
    if (output.mock) {
      data += "\n\n";
      data += implementationMock;
    }
    await import_fs_extra3.default.outputFile(path2, data);
    return [path2];
  } catch (e3) {
    throw `Oups... \u{1F37B}. An Error occurred while writing file => ${e3}`;
  }
};

// src/writers/split-mode.ts
var import_fs_extra4 = __toESM(require("fs-extra"));
var writeSplitMode = async ({
  builder,
  output,
  specsName,
  header,
  needSchema
}) => {
  try {
    const { filename, dirname: dirname3, extension } = getFileInfo(output.target, {
      backupFilename: camel(builder.info.title)
    });
    const {
      imports,
      implementation,
      implementationMock,
      importsMock,
      mutators,
      clientMutators,
      formData,
      formUrlEncoded,
      paramsSerializer
    } = generateTarget(builder, output);
    let implementationData = header;
    let mockData = header;
    const relativeSchemasPath = output.schemas ? path_exports.relativeSafe(dirname3, getFileInfo(output.schemas).dirname) : "./" + filename + ".schemas";
    const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(
      output.tsconfig
    );
    implementationData += builder.imports({
      client: output.client,
      implementation,
      imports: [{ exports: imports, dependency: relativeSchemasPath }],
      specsName,
      hasSchemaDir: !!output.schemas,
      isAllowSyntheticDefaultImports,
      hasGlobalMutator: !!output.override.mutator,
      hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,
      packageJson: output.packageJson,
      output
    });
    mockData += builder.importsMock({
      implementation: implementationMock,
      imports: [
        {
          exports: importsMock,
          dependency: relativeSchemasPath
        }
      ],
      specsName,
      hasSchemaDir: !!output.schemas,
      isAllowSyntheticDefaultImports,
      options: !isFunction2(output.mock) ? output.mock : void 0
    });
    const schemasPath = !output.schemas ? path_exports.join(dirname3, filename + ".schemas" + extension) : void 0;
    if (schemasPath && needSchema) {
      const schemasData = header + generateModelsInline(builder.schemas);
      await import_fs_extra4.default.outputFile(
        path_exports.join(dirname3, filename + ".schemas" + extension),
        schemasData
      );
    }
    if (mutators) {
      implementationData += generateMutatorImports({
        mutators,
        implementation
      });
    }
    if (clientMutators) {
      implementationData += generateMutatorImports({
        mutators: clientMutators
      });
    }
    if (formData) {
      implementationData += generateMutatorImports({ mutators: formData });
    }
    if (formUrlEncoded) {
      implementationData += generateMutatorImports({
        mutators: formUrlEncoded
      });
    }
    if (paramsSerializer) {
      implementationData += generateMutatorImports({
        mutators: paramsSerializer
      });
    }
    if (implementation.includes("NonReadonly<")) {
      implementationData += getOrvalGeneratedTypes();
    }
    implementationData += `
${implementation}`;
    mockData += `
${implementationMock}`;
    const implementationFilename = filename + (OutputClient.ANGULAR === output.client ? ".service" : "") + extension;
    const implementationPath = path_exports.join(dirname3, implementationFilename);
    await import_fs_extra4.default.outputFile(
      path_exports.join(dirname3, implementationFilename),
      implementationData
    );
    const mockPath = output.mock ? path_exports.join(
      dirname3,
      filename + "." + getMockFileExtensionByTypeName(output.mock) + extension
    ) : void 0;
    if (mockPath) {
      await import_fs_extra4.default.outputFile(mockPath, mockData);
    }
    return [
      implementationPath,
      ...schemasPath ? [schemasPath] : [],
      ...mockPath ? [mockPath] : []
    ];
  } catch (e3) {
    throw `Oups... \u{1F37B}. An Error occurred while splitting => ${e3}`;
  }
};

// src/writers/split-tags-mode.ts
var import_fs_extra5 = __toESM(require("fs-extra"));

// src/writers/target-tags.ts
var addDefaultTagIfEmpty = (operation) => ({
  ...operation,
  tags: operation.tags.length ? operation.tags : ["default"]
});
var generateTargetTags = (currentAcc, operation) => {
  return operation.tags.map(kebab).reduce((acc, tag) => {
    const currentOperation = acc[tag];
    if (!currentOperation) {
      acc[tag] = {
        imports: operation.imports,
        importsMock: operation.importsMock,
        mutators: operation.mutator ? [operation.mutator] : [],
        clientMutators: operation.clientMutators ?? [],
        formData: operation.formData ? [operation.formData] : [],
        formUrlEncoded: operation.formUrlEncoded ? [operation.formUrlEncoded] : [],
        paramsSerializer: operation.paramsSerializer ? [operation.paramsSerializer] : [],
        implementation: operation.implementation,
        implementationMock: {
          function: operation.implementationMock.function,
          handler: operation.implementationMock.handler
        }
      };
      return acc;
    }
    acc[tag] = {
      implementation: currentOperation.implementation + operation.implementation,
      imports: [...currentOperation.imports, ...operation.imports],
      importsMock: [...currentOperation.importsMock, ...operation.importsMock],
      implementationMock: {
        function: currentOperation.implementationMock.function + operation.implementationMock.function,
        handler: currentOperation.implementationMock.handler + operation.implementationMock.handler
      },
      mutators: operation.mutator ? [...currentOperation.mutators ?? [], operation.mutator] : currentOperation.mutators,
      clientMutators: operation.clientMutators ? [
        ...currentOperation.clientMutators ?? [],
        ...operation.clientMutators
      ] : currentOperation.clientMutators,
      formData: operation.formData ? [...currentOperation.formData ?? [], operation.formData] : currentOperation.formData,
      formUrlEncoded: operation.formUrlEncoded ? [...currentOperation.formUrlEncoded ?? [], operation.formUrlEncoded] : currentOperation.formUrlEncoded,
      paramsSerializer: operation.paramsSerializer ? [
        ...currentOperation.paramsSerializer ?? [],
        operation.paramsSerializer
      ] : currentOperation.paramsSerializer
    };
    return acc;
  }, currentAcc);
};
var generateTargetForTags = (builder, options) => {
  const isAngularClient = options.client === OutputClient.ANGULAR;
  const allTargetTags = Object.values(builder.operations).map(addDefaultTagIfEmpty).reduce((acc, operation, index3, arr) => {
    const targetTags = generateTargetTags(acc, operation);
    if (index3 === arr.length - 1) {
      return Object.entries(targetTags).reduce((acc2, [tag, target]) => {
        const isMutator = !!target.mutators?.some(
          (mutator) => isAngularClient ? mutator.hasThirdArg : mutator.hasSecondArg
        );
        const operationNames = Object.values(builder.operations).filter(({ tags }) => tags.map(kebab).includes(kebab(tag))).map(({ operationName }) => operationName);
        const typescriptVersion = options.packageJson?.dependencies?.["typescript"] ?? options.packageJson?.devDependencies?.["typescript"] ?? "4.4.0";
        const hasAwaitedType = compareVersions(typescriptVersion, "4.5.0");
        const titles = builder.title({
          outputClient: options.client,
          title: pascal(tag),
          customTitleFunc: options.override.title,
          output: options
        });
        const footer = builder.footer({
          outputClient: options?.client,
          operationNames,
          hasMutator: !!target.mutators?.length,
          hasAwaitedType,
          titles,
          output: options
        });
        const header = builder.header({
          outputClient: options.client,
          isRequestOptions: options.override.requestOptions !== false,
          isMutator,
          isGlobalMutator: !!options.override.mutator,
          provideIn: options.override.angular.provideIn,
          hasAwaitedType,
          titles,
          output: options
        });
        acc2[tag] = {
          implementation: header.implementation + target.implementation + footer.implementation,
          implementationMock: {
            function: target.implementationMock.function,
            handler: header.implementationMock + target.implementationMock.handler + footer.implementationMock
          },
          imports: target.imports,
          importsMock: target.importsMock,
          mutators: target.mutators,
          clientMutators: target.clientMutators,
          formData: target.formData,
          formUrlEncoded: target.formUrlEncoded,
          paramsSerializer: target.paramsSerializer
        };
        return acc2;
      }, {});
    }
    return targetTags;
  }, {});
  return Object.entries(allTargetTags).reduce(
    (acc, [tag, target]) => {
      acc[tag] = {
        ...target,
        implementationMock: target.implementationMock.function + target.implementationMock.handler
      };
      return acc;
    },
    {}
  );
};

// src/writers/split-tags-mode.ts
var import_lodash11 = __toESM(require("lodash.uniqby"));
var writeSplitTagsMode = async ({
  builder,
  output,
  specsName,
  header,
  needSchema
}) => {
  const { filename, dirname: dirname3, extension } = getFileInfo(output.target, {
    backupFilename: camel(builder.info.title)
  });
  const target = generateTargetForTags(builder, output);
  const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(
    output.tsconfig
  );
  const generatedFilePathsArray = await Promise.all(
    Object.entries(target).map(async ([tag, target2]) => {
      try {
        const {
          imports,
          implementation,
          implementationMock,
          importsMock,
          mutators,
          clientMutators,
          formData,
          formUrlEncoded,
          paramsSerializer
        } = target2;
        let implementationData = header;
        let mockData = header;
        const relativeSchemasPath = output.schemas ? "../" + path_exports.relativeSafe(dirname3, getFileInfo(output.schemas).dirname) : "../" + filename + ".schemas";
        const importsForBuilder = output.schemas ? (0, import_lodash11.default)(imports, "name").map((i3) => ({
          exports: [i3],
          dependency: path_exports.join(relativeSchemasPath, camel(i3.name))
        })) : [{ exports: imports, dependency: relativeSchemasPath }];
        implementationData += builder.imports({
          client: output.client,
          implementation,
          imports: importsForBuilder,
          specsName,
          hasSchemaDir: !!output.schemas,
          isAllowSyntheticDefaultImports,
          hasGlobalMutator: !!output.override.mutator,
          hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,
          packageJson: output.packageJson,
          output
        });
        mockData += builder.importsMock({
          implementation: implementationMock,
          imports: [
            {
              exports: importsMock,
              dependency: relativeSchemasPath
            }
          ],
          specsName,
          hasSchemaDir: !!output.schemas,
          isAllowSyntheticDefaultImports,
          options: !isFunction2(output.mock) ? output.mock : void 0
        });
        const schemasPath = !output.schemas ? path_exports.join(dirname3, filename + ".schemas" + extension) : void 0;
        if (schemasPath && needSchema) {
          const schemasData = header + generateModelsInline(builder.schemas);
          await import_fs_extra5.default.outputFile(schemasPath, schemasData);
        }
        if (mutators) {
          implementationData += generateMutatorImports({
            mutators,
            implementation,
            oneMore: true
          });
        }
        if (clientMutators) {
          implementationData += generateMutatorImports({
            mutators: clientMutators,
            oneMore: true
          });
        }
        if (formData) {
          implementationData += generateMutatorImports({
            mutators: formData,
            oneMore: true
          });
        }
        if (formUrlEncoded) {
          implementationData += generateMutatorImports({
            mutators: formUrlEncoded,
            oneMore: true
          });
        }
        if (paramsSerializer) {
          implementationData += generateMutatorImports({
            mutators: paramsSerializer,
            oneMore: true
          });
        }
        if (implementation.includes("NonReadonly<")) {
          implementationData += getOrvalGeneratedTypes();
          implementationData += "\n";
        }
        implementationData += `
${implementation}`;
        mockData += `
${implementationMock}`;
        const implementationFilename = tag + (OutputClient.ANGULAR === output.client ? ".service" : "") + extension;
        const implementationPath = path_exports.join(
          dirname3,
          tag,
          implementationFilename
        );
        await import_fs_extra5.default.outputFile(implementationPath, implementationData);
        const mockPath = output.mock ? path_exports.join(
          dirname3,
          tag,
          tag + "." + getMockFileExtensionByTypeName(output.mock) + extension
        ) : void 0;
        if (mockPath) {
          await import_fs_extra5.default.outputFile(mockPath, mockData);
        }
        return [
          implementationPath,
          ...schemasPath ? [schemasPath] : [],
          ...mockPath ? [mockPath] : []
        ];
      } catch (e3) {
        throw `Oups... \u{1F37B}. An Error occurred while splitting tag ${tag} => ${e3}`;
      }
    })
  );
  return generatedFilePathsArray.flatMap((it) => it);
};

// src/writers/tags-mode.ts
var import_fs_extra6 = __toESM(require("fs-extra"));
var writeTagsMode = async ({
  builder,
  output,
  specsName,
  header,
  needSchema
}) => {
  const { filename, dirname: dirname3, extension } = getFileInfo(output.target, {
    backupFilename: camel(builder.info.title)
  });
  const target = generateTargetForTags(builder, output);
  const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(
    output.tsconfig
  );
  const generatedFilePathsArray = await Promise.all(
    Object.entries(target).map(async ([tag, target2]) => {
      try {
        const {
          imports,
          implementation,
          implementationMock,
          importsMock,
          mutators,
          clientMutators,
          formData,
          formUrlEncoded,
          paramsSerializer
        } = target2;
        let data = header;
        const schemasPathRelative = output.schemas ? path_exports.relativeSafe(dirname3, getFileInfo(output.schemas).dirname) : "./" + filename + ".schemas";
        data += builder.imports({
          client: output.client,
          implementation,
          imports: [
            {
              exports: imports.filter(
                (imp) => !importsMock.some((impMock) => imp.name === impMock.name)
              ),
              dependency: schemasPathRelative
            }
          ],
          specsName,
          hasSchemaDir: !!output.schemas,
          isAllowSyntheticDefaultImports,
          hasGlobalMutator: !!output.override.mutator,
          hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,
          packageJson: output.packageJson,
          output
        });
        if (output.mock) {
          data += builder.importsMock({
            implementation: implementationMock,
            imports: [
              { exports: importsMock, dependency: schemasPathRelative }
            ],
            specsName,
            hasSchemaDir: !!output.schemas,
            isAllowSyntheticDefaultImports,
            options: !isFunction2(output.mock) ? output.mock : void 0
          });
        }
        const schemasPath = !output.schemas ? path_exports.join(dirname3, filename + ".schemas" + extension) : void 0;
        if (schemasPath && needSchema) {
          const schemasData = header + generateModelsInline(builder.schemas);
          await import_fs_extra6.default.outputFile(schemasPath, schemasData);
        }
        if (mutators) {
          data += generateMutatorImports({ mutators, implementation });
        }
        if (clientMutators) {
          data += generateMutatorImports({
            mutators: clientMutators
          });
        }
        if (formData) {
          data += generateMutatorImports({ mutators: formData });
        }
        if (formUrlEncoded) {
          data += generateMutatorImports({ mutators: formUrlEncoded });
        }
        if (paramsSerializer) {
          data += generateMutatorImports({ mutators: paramsSerializer });
        }
        data += "\n\n";
        if (implementation.includes("NonReadonly<")) {
          data += getOrvalGeneratedTypes();
          data += "\n";
        }
        data += implementation;
        if (output.mock) {
          data += "\n\n";
          data += implementationMock;
        }
        const implementationPath = path_exports.join(
          dirname3,
          `${kebab(tag)}${extension}`
        );
        await import_fs_extra6.default.outputFile(implementationPath, data);
        return [implementationPath, ...schemasPath ? [schemasPath] : []];
      } catch (e3) {
        throw `Oups... \u{1F37B}. An Error occurred while writing tag ${tag} => ${e3}`;
      }
    })
  );
  return generatedFilePathsArray.flatMap((it) => it);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BODY_TYPE_NAME,
  GetterPropType,
  LogLevels,
  OutputClient,
  OutputMockType,
  OutputMode,
  RefComponentSuffix,
  SchemaType,
  URL_REGEX,
  VERBS_WITH_BODY,
  Verbs,
  _filteredVerbs,
  addDependency,
  asyncReduce,
  camel,
  combineSchemas,
  compareVersions,
  count,
  createDebugger,
  createLogger,
  createSuccessMessage,
  dynamicImport,
  errorMessage,
  escape,
  generalJSTypes,
  generalJSTypesWithArray,
  generateAxiosOptions,
  generateBodyMutatorConfig,
  generateBodyOptions,
  generateComponentDefinition,
  generateDependencyImports,
  generateFormDataAndUrlEncodedFunction,
  generateImports,
  generateModelInline,
  generateModelsInline,
  generateMutator,
  generateMutatorConfig,
  generateMutatorImports,
  generateMutatorRequestOptions,
  generateOptions,
  generateParameterDefinition,
  generateQueryParamsAxiosConfig,
  generateSchemasDefinition,
  generateTarget,
  generateTargetForTags,
  generateVerbImports,
  generateVerbsOptions,
  getArray,
  getBody,
  getEnum,
  getEnumImplementation,
  getExtension,
  getFileInfo,
  getKey,
  getMockFileExtensionByTypeName,
  getNumberWord,
  getObject,
  getOperationId,
  getOrvalGeneratedTypes,
  getParameters,
  getParams,
  getParamsInPath,
  getProps,
  getQueryParams,
  getRefInfo,
  getResReqTypes,
  getResponse,
  getRoute,
  getRouteAsArray,
  getScalar,
  ibmOpenapiValidator,
  ibmOpenapiValidatorErrors,
  ibmOpenapiValidatorWarnings,
  isBoolean,
  isDirectory,
  isFunction,
  isModule,
  isNull,
  isNumber,
  isNumeric,
  isObject,
  isReference,
  isRootKey,
  isSchema,
  isString,
  isSyntheticDefaultImportsAllow,
  isUndefined,
  isUrl,
  isVerb,
  jsDoc,
  jsStringEscape,
  kebab,
  loadFile,
  log,
  mergeDeep,
  mismatchArgsMessage,
  openApiConverter,
  pascal,
  removeFiles,
  resolveDiscriminators,
  resolveExampleRefs,
  resolveObject,
  resolveRef,
  resolveValue,
  sanitize,
  snake,
  sortByPriority,
  startMessage,
  stringify,
  toObjectString,
  upath,
  upper,
  writeModelInline,
  writeModelsInline,
  writeSchema,
  writeSchemas,
  writeSingleMode,
  writeSplitMode,
  writeSplitTagsMode,
  writeTagsMode
});
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

urijs/src/punycode.js:
  (*! https://mths.be/punycode v1.4.0 by @mathias *)

urijs/src/IPv6.js:
  (*!
   * URI.js - Mutating URLs
   * IPv6 Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/SecondLevelDomains.js:
  (*!
   * URI.js - Mutating URLs
   * Second Level Domain (SLD) Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/URI.js:
  (*!
   * URI.js - Mutating URLs
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)
*/
//# sourceMappingURL=index.js.map