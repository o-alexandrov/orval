{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n  SchemaObject,\n} from 'openapi3-ts';\nimport {\n  camel,\n  ClientBuilder,\n  ClientGeneratorsBuilder,\n  escape,\n  GeneratorDependency,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  isString,\n  resolveRef,\n  ContextSpecs,\n  isObject,\n  isBoolean,\n  jsStringEscape,\n} from '@orval/core';\nimport uniq from 'lodash.uniq';\n\nconst ZOD_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'z',\n        alias: 'zod',\n        values: true,\n      },\n    ],\n    dependency: 'zod',\n  },\n];\n\nexport const getZodDependencies = () => ZOD_DEPENDENCIES;\n\nconst resolveZodType = (schemaTypeValue: SchemaObject['type']) => {\n  switch (schemaTypeValue) {\n    case 'integer':\n      return 'number';\n    case 'null':\n      return 'mixed';\n    default:\n      return schemaTypeValue ?? 'any';\n  }\n};\n\n// counter for unique naming\nlet counter = 0;\n\n// https://github.com/colinhacks/zod#coercion-for-primitives\nconst COERCEABLE_TYPES = ['string', 'number', 'boolean', 'bigint', 'date'];\n\nconst generateZodValidationSchemaDefinition = (\n  schema: SchemaObject | undefined,\n  _required: boolean | undefined,\n  name: string,\n): { functions: [string, any][]; consts: string[] } => {\n  if (!schema) return { functions: [], consts: [] };\n\n  const consts: string[] = [];\n  const functions: [string, any][] = [];\n  const type = resolveZodType(schema.type);\n  const required = schema.default !== undefined ? false : _required ?? false;\n  const nullable = schema.nullable ?? false;\n  const min =\n    schema.minimum ??\n    schema.exclusiveMinimum ??\n    schema.minLength ??\n    schema.minItems ??\n    undefined;\n  const max =\n    schema.maximum ??\n    schema.exclusiveMaximum ??\n    schema.maxLength ??\n    schema.maxItems ??\n    undefined;\n  const matches = schema.pattern ?? undefined;\n\n  switch (type) {\n    case 'array':\n      const items = schema.items as SchemaObject | undefined;\n      functions.push([\n        'array',\n        generateZodValidationSchemaDefinition(items, true, camel(name)),\n      ]);\n      break;\n    case 'string': {\n      if (schema.enum && type === 'string') {\n        break;\n      }\n\n      if (schema.format === 'date') {\n        functions.push(['date', undefined]);\n        break;\n      }\n\n      functions.push([type as string, undefined]);\n\n      if (schema.format === 'date-time') {\n        functions.push(['datetime', undefined]);\n        break;\n      }\n\n      if (schema.format === 'email') {\n        functions.push(['email', undefined]);\n        break;\n      }\n\n      if (schema.format === 'uri' || schema.format === 'hostname') {\n        functions.push(['url', undefined]);\n        break;\n      }\n\n      if (schema.format === 'uuid') {\n        functions.push(['uuid', undefined]);\n        break;\n      }\n\n      break;\n    }\n    case 'object':\n    default: {\n      if (schema.allOf || schema.oneOf || schema.anyOf) {\n        const separator = schema.allOf\n          ? 'allOf'\n          : schema.oneOf\n          ? 'oneOf'\n          : 'anyOf';\n\n        const schemas = (schema.allOf ?? schema.oneOf ?? schema.anyOf) as (\n          | SchemaObject\n          | ReferenceObject\n        )[];\n\n        functions.push([\n          separator,\n          schemas.map((schema) =>\n            generateZodValidationSchemaDefinition(\n              schema as SchemaObject,\n              true,\n              camel(name),\n            ),\n          ),\n        ]);\n        break;\n      }\n\n      if (schema.properties) {\n        functions.push([\n          'object',\n          Object.keys(schema.properties)\n            .map((key) => ({\n              [key]: generateZodValidationSchemaDefinition(\n                schema.properties?.[key] as any,\n                schema.required?.includes(key),\n                camel(`${name}-${key}`),\n              ),\n            }))\n            .reduce((acc, curr) => ({ ...acc, ...curr }), {}),\n        ]);\n\n        break;\n      }\n\n      if (schema.additionalProperties) {\n        functions.push([\n          'additionalProperties',\n          isBoolean(schema.additionalProperties)\n            ? schema.additionalProperties\n            : generateZodValidationSchemaDefinition(\n                schema.additionalProperties as SchemaObject,\n                true,\n                name,\n              ),\n        ]);\n\n        break;\n      }\n\n      functions.push([type as string, undefined]);\n      break;\n    }\n  }\n\n  if (min !== undefined) {\n    if (min === 1) {\n      functions.push(['min', `${min}`]);\n    } else {\n      counter++;\n      consts.push(`export const ${name}Min${counter} = ${min};\\n`);\n      functions.push(['min', `${name}Min${counter}`]);\n    }\n  }\n  if (max !== undefined) {\n    counter++;\n    consts.push(`export const ${name}Max${counter} = ${max};\\n`);\n    functions.push(['max', `${name}Max${counter}`]);\n  }\n  if (matches) {\n    const isStartWithSlash = matches.startsWith('/');\n    const isEndWithSlash = matches.endsWith('/');\n\n    const regexp = `new RegExp('${jsStringEscape(\n      matches.slice(isStartWithSlash ? 1 : 0, isEndWithSlash ? -1 : undefined),\n    )}')`;\n\n    consts.push(`export const ${name}RegExp = ${regexp};\\n`);\n    functions.push(['regex', `${name}RegExp`]);\n  }\n\n  if (schema.enum && type !== 'number') {\n    functions.push([\n      'enum',\n      [\n        `[${schema.enum\n          .map((value) => (isString(value) ? `'${escape(value)}'` : `${value}`))\n          .join(', ')}]`,\n      ],\n    ]);\n  }\n\n  if (!required && nullable) {\n    functions.push(['nullish', undefined]);\n  } else if (nullable) {\n    functions.push(['nullable', undefined]);\n  } else if (!required) {\n    functions.push(['optional', undefined]);\n  }\n\n  return { functions, consts: uniq(consts) };\n};\n\nexport type ZodValidationSchemaDefinitionInput = Record<\n  string,\n  { functions: [string, any][]; consts: string[] }\n>;\n\nexport const parseZodValidationSchemaDefinition = (\n  input: ZodValidationSchemaDefinitionInput,\n  coerceTypes = false,\n): { zod: string; consts: string } => {\n  if (!Object.keys(input).length) {\n    return { zod: '', consts: '' };\n  }\n\n  let consts = '';\n\n  const parseProperty = (property: [string, any]): string => {\n    const [fn, args = ''] = property;\n    if (fn === 'allOf') {\n      return args.reduce(\n        (acc: string, { functions }: { functions: [string, any][] }) => {\n          const value = functions.map(parseProperty).join('');\n          const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n\n          if (!acc) {\n            acc += valueWithZod;\n            return acc;\n          }\n\n          acc += `.and(${valueWithZod})`;\n\n          return acc;\n        },\n        '',\n      );\n    }\n\n    if (fn === 'oneOf' || fn === 'anyOf') {\n      return args.reduce(\n        (acc: string, { functions }: { functions: [string, any][] }) => {\n          const value = functions.map(parseProperty).join('');\n          const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n\n          if (!acc) {\n            acc += valueWithZod;\n            return acc;\n          }\n\n          acc += `.or(${valueWithZod})`;\n\n          return acc;\n        },\n        '',\n      );\n    }\n\n    if (fn === 'additionalProperties') {\n      const value = args.functions.map(parseProperty).join('');\n      const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n      consts += args.consts;\n      return `zod.record(zod.string(), ${valueWithZod})`;\n    }\n\n    if (fn === 'object') {\n      const parsed = parseZodValidationSchemaDefinition(args);\n      consts += parsed.consts;\n      return ` ${parsed.zod}`;\n    }\n    if (fn === 'array') {\n      const value = args.functions.map(parseProperty).join('');\n      if (typeof args.consts === 'string') {\n        consts += args.consts;\n      } else if (Array.isArray(args.consts)) {\n        consts += args.consts.join('\\n');\n      }\n      return `.array(${value.startsWith('.') ? 'zod' : ''}${value})`;\n    }\n\n    if (coerceTypes && COERCEABLE_TYPES.includes(fn)) {\n      return `.coerce.${fn}(${args})`;\n    }\n\n    return `.${fn}(${args})`;\n  };\n\n  consts += Object.entries(input).reduce((acc, [key, schema]) => {\n    return acc + schema.consts.join('\\n');\n  }, '');\n\n  const zod = `zod.object({\n${Object.entries(input)\n  .map(([key, schema]) => {\n    const value = schema.functions.map(parseProperty).join('');\n    return `  \"${key}\": ${value.startsWith('.') ? 'zod' : ''}${value}`;\n  })\n  .join(',\\n')}\n})`;\n\n  return { zod, consts };\n};\n\nconst deferenceScalar = (value: any, context: ContextSpecs): unknown => {\n  if (isObject(value)) {\n    return deference(value, context);\n  } else if (Array.isArray(value)) {\n    return value.map((item) => deferenceScalar(item, context));\n  } else {\n    return value;\n  }\n};\n\nconst deference = (\n  schema: SchemaObject | ReferenceObject,\n  context: ContextSpecs,\n): SchemaObject => {\n  const refName = '$ref' in schema ? schema.$ref : undefined;\n  if (refName && context.parents?.includes(refName)) {\n    return {};\n  }\n\n  const childContext: ContextSpecs = {\n    ...context,\n    ...(refName\n      ? { parents: [...(context.parents || []), refName] }\n      : undefined),\n  };\n\n  const { schema: resolvedSchema } = resolveRef<SchemaObject>(\n    schema,\n    childContext,\n  );\n\n  return Object.entries(resolvedSchema).reduce((acc, [key, value]) => {\n    acc[key] = deferenceScalar(value, childContext);\n    return acc;\n  }, {} as any);\n};\n\nconst generateZodRoute = (\n  { operationName, body, verb }: GeneratorVerbOptions,\n  { pathRoute, context, override }: GeneratorOptions,\n) => {\n  const spec = context.specs[context.specKey].paths[pathRoute] as\n    | PathItemObject\n    | undefined;\n\n  const parameters = spec?.[verb]?.parameters;\n  const requestBody = spec?.[verb]?.requestBody;\n  const response = spec?.[verb]?.responses?.['200'] as\n    | ResponseObject\n    | ReferenceObject;\n\n  const resolvedResponse = response\n    ? resolveRef<ResponseObject>(response, context).schema\n    : undefined;\n\n  const resolvedResponseJsonSchema = resolvedResponse?.content?.[\n    'application/json'\n  ]?.schema\n    ? resolveRef<SchemaObject>(\n        resolvedResponse.content['application/json'].schema,\n        context,\n      ).schema\n    : undefined;\n\n  const zodDefinitionsResponseProperties =\n    resolvedResponseJsonSchema?.properties ??\n    ({} as { [p: string]: SchemaObject | ReferenceObject });\n\n  const zodDefinitionsResponse = Object.entries(\n    zodDefinitionsResponseProperties,\n  )\n    .map(([key, response]) => {\n      const schema = deference(response, context);\n\n      return {\n        [key]: generateZodValidationSchemaDefinition(\n          schema,\n          !!resolvedResponseJsonSchema?.required?.find(\n            (requiredKey: string) => requiredKey === key,\n          ),\n          camel(`${operationName}-response-${key}`),\n        ),\n      };\n    })\n    .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n\n  const resolvedRequestBody = requestBody\n    ? resolveRef<RequestBodyObject>(requestBody, context).schema\n    : undefined;\n\n  const resolvedRequestBodyJsonSchema = resolvedRequestBody?.content?.[\n    'application/json'\n  ]?.schema\n    ? resolveRef<SchemaObject>(\n        resolvedRequestBody.content['application/json'].schema,\n        context,\n      ).schema\n    : undefined;\n\n  const zodDefinitionsBodyProperties =\n    resolvedRequestBodyJsonSchema?.properties ??\n    ({} as { [p: string]: SchemaObject | ReferenceObject });\n\n  const zodDefinitionsBody = Object.entries(zodDefinitionsBodyProperties)\n    .map(([key, body]) => {\n      const schema = deference(body, context);\n\n      return {\n        [key]: generateZodValidationSchemaDefinition(\n          schema,\n          !!resolvedRequestBodyJsonSchema?.required?.find(\n            (requiredKey: string) => requiredKey === key,\n          ),\n          camel(`${operationName}-body-${key}`),\n        ),\n      };\n    })\n    .reduce((acc, curr) => ({ ...acc, ...curr }), {});\n\n  const zodDefinitionsParameters = (parameters ?? []).reduce(\n    (acc, val) => {\n      const { schema: parameter } = resolveRef<ParameterObject>(val, context);\n\n      if (!parameter.schema) {\n        return acc;\n      }\n\n      const schema = deference(parameter.schema, context);\n\n      const definition = generateZodValidationSchemaDefinition(\n        schema,\n        parameter.required,\n        camel(`${operationName}-${parameter.in}-${parameter.name}`),\n      );\n\n      if (parameter.in === 'header') {\n        return {\n          ...acc,\n          headers: { ...acc.headers, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'query') {\n        return {\n          ...acc,\n          queryParams: { ...acc.queryParams, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'path') {\n        return {\n          ...acc,\n          params: { ...acc.params, [parameter.name]: definition },\n        };\n      }\n\n      return acc;\n    },\n    {\n      headers: {},\n      queryParams: {},\n      params: {},\n    } as Record<\n      'headers' | 'queryParams' | 'params',\n      Record<string, { functions: [string, any][]; consts: string[] }>\n    >,\n  );\n\n  const inputParams = parseZodValidationSchemaDefinition(\n    zodDefinitionsParameters.params,\n  );\n  const inputQueryParams = parseZodValidationSchemaDefinition(\n    zodDefinitionsParameters.queryParams,\n    override.coerceTypes,\n  );\n  const inputHeaders = parseZodValidationSchemaDefinition(\n    zodDefinitionsParameters.headers,\n  );\n  const inputBody = parseZodValidationSchemaDefinition(zodDefinitionsBody);\n  const inputResponse = parseZodValidationSchemaDefinition(\n    zodDefinitionsResponse,\n  );\n\n  if (\n    !inputParams.zod &&\n    !inputQueryParams.zod &&\n    !inputHeaders.zod &&\n    !inputBody.zod &&\n    !inputResponse.zod\n  ) {\n    return '';\n  }\n\n  return [\n    ...(inputParams.consts ? [inputParams.consts] : []),\n    ...(inputParams.zod\n      ? [`export const ${operationName}Params = ${inputParams.zod}`]\n      : []),\n    ...(inputQueryParams.consts ? [inputQueryParams.consts] : []),\n    ...(inputQueryParams.zod\n      ? [`export const ${operationName}QueryParams = ${inputQueryParams.zod}`]\n      : []),\n    ...(inputHeaders.consts ? [inputHeaders.consts] : []),\n    ...(inputHeaders.zod\n      ? [`export const ${operationName}Header = ${inputHeaders.zod}`]\n      : []),\n    ...(inputBody.consts ? [inputBody.consts] : []),\n    ...(inputBody.zod\n      ? [`export const ${operationName}Body = ${inputBody.zod}`]\n      : []),\n    ...(inputResponse.consts ? [inputResponse.consts] : []),\n    ...(inputResponse.zod\n      ? [`export const ${operationName}Response = ${inputResponse.zod}`]\n      : []),\n  ].join('\\n\\n');\n};\n\nexport const generateZod: ClientBuilder = (verbOptions, options) => {\n  const routeImplementation = generateZodRoute(verbOptions, options);\n\n  return {\n    implementation: routeImplementation ? `${routeImplementation}\\n\\n` : '',\n    imports: [],\n  };\n};\n\nconst zodClientBuilder: ClientGeneratorsBuilder = {\n  client: generateZod,\n  dependencies: getZodDependencies,\n};\n\nexport const builder = () => () => zodClientBuilder;\n\nexport default builder;\n"],"mappings":"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","names":["schema","_a","_b","uniq","response","body"]}